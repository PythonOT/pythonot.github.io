

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ot.da &mdash; POT Python Optimal Transport 0.7.0b documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.gpu" href="ot.gpu.html" />
    <link rel="prev" title="ot.optim" href="ot.optim.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> POT Python Optimal Transport
          

          
          </a>

          
            
            
              <div class="version">
                0.7.0b
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quick start guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.da</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-ot-mapping-linear">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.OT_mapping_linear</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-basetransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.BaseTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-emdlaplacetransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDLaplaceTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-emdtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-jcpottransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.JCPOTTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-lineartransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-mappingtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.MappingTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhornl1l2transport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornL1l2Transport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhornlpl1transport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornLpl1Transport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhorntransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornTransport</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.gpu.html">ot.gpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../all.html">API and modules</a> &raquo;</li>
        
      <li>ot.da</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gen_modules/ot.da.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-ot.da">
<span id="ot-da"></span><h1>ot.da<a class="headerlink" href="#module-ot.da" title="Permalink to this headline">¶</a></h1>
<p>Domain adaptation with optimal transport</p>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="ot.da.OT_mapping_linear">
<code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">OT_mapping_linear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xs</span></em>, <em class="sig-param"><span class="n">xt</span></em>, <em class="sig-param"><span class="n">reg</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">ws</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">bias</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#OT_mapping_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.OT_mapping_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>return OT linear operator between samples</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(N(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(N(\mu_t,\Sigma_t)\)</span> as proposed in [14] and discussed in remark
2.29 in [15].</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(x)=Ax+b\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[A=\Sigma_s^{-1/2}(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2})^{1/2}
\Sigma_s^{-1/2}\]</div>
<div class="math notranslate nohighlight">
\[b=\mu_t-A\mu_s\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>np.ndarray</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the diagonals of convariances (&gt;0)</p></li>
<li><p><strong>ws</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias b else b=0 (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(d x d) ndarray</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1 x d) ndarray</em>) – bias</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">14</span></dt>
<dd><p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</dd>
<dt class="label" id="id2"><span class="brackets">15</span></dt>
<dd><p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-ot-da-ot-mapping-linear">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.OT_mapping_linear</span></code><a class="headerlink" href="#examples-using-ot-da-ot-mapping-linear" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><div class="figure align-default" id="id36">
<img alt="Linear OT mapping estimation" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></span><a class="headerlink" href="#id36" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py function">
<dt id="ot.da.distribution_estimation_uniform">
<code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">distribution_estimation_uniform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#distribution_estimation_uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.distribution_estimation_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>estimates a uniform distribution from an array of samples X</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The array of samples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mu</strong> – The uniform distribution estimated from X</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt id="ot.da.emd_laplace">
<code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">emd_laplace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">xs</span></em>, <em class="sig-param"><span class="n">xt</span></em>, <em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">sim</span><span class="o">=</span><span class="default_value">'knn'</span></em>, <em class="sig-param"><span class="n">sim_param</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reg</span><span class="o">=</span><span class="default_value">'pos'</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">numItermax</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">stopThr</span><span class="o">=</span><span class="default_value">1e-09</span></em>, <em class="sig-param"><span class="n">numInnerItermax</span><span class="o">=</span><span class="default_value">100000</span></em>, <em class="sig-param"><span class="n">stopInnerThr</span><span class="o">=</span><span class="default_value">1e-09</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#emd_laplace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.emd_laplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the optimal transport problem (OT) with Laplacian regularization</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma &lt;\gamma,M&gt;_F + eta\Omega_\alpha(\gamma)\\s.t.\ \gamma 1 = a\\     \gamma^T 1= b\\     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p>a and b are source and target weights (sum to 1)</p></li>
<li><p>xs and xt are source and target samples</p></li>
<li><p>M is the (ns,nt) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_\alpha\)</span> is the Laplacian regularization term
<span class="math notranslate nohighlight">\(\Omega_\alpha = (1-\alpha)/n_s^2\sum_{i,j}S^s_{i,j}\|T(\mathbf{x}^s_i)-T(\mathbf{x}^s_j)\|^2+\alpha/n_t^2\sum_{i,j}S^t_{i,j}^'\|T(\mathbf{x}^t_i)-T(\mathbf{x}^t_j)\|^2\)</span>
with <span class="math notranslate nohighlight">\(S^s_{i,j}, S^t_{i,j}\)</span> denoting source and target similarity matrices and <span class="math notranslate nohighlight">\(T(\cdot)\)</span> being a barycentric mapping</p></li>
</ul>
<p>The algorithm used for solving the problem is the conditional gradient algorithm as proposed in [5].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>xs</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>np.ndarray</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>sim</strong> (<em>string</em><em>, </em><em>optional</em>) – Type of similarity (‘knn’ or ‘gauss’) used to construct the Laplacian.</p></li>
<li><p><strong>sim_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Parameter (number of the nearest neighbors for sim=’knn’
or bandwidth for sim=’gauss’) used to compute the Laplacian.</p></li>
<li><p><strong>reg</strong> (<em>string</em>) – Type of Laplacian regularization</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Regularization term for Laplacian regularization</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Regularization term  for source domain’s importance in regularization</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner emd solver) (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns x nt) ndarray</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">5</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id4"><span class="brackets">30</span></dt>
<dd><p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”</p>
<blockquote>
<div><p>in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.emd()</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.optim.cg()</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt id="ot.da.joint_OT_mapping_kernel">
<code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">joint_OT_mapping_kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xs</span></em>, <em class="sig-param"><span class="n">xt</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">kerneltype</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">bias</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose2</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">numItermax</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">numInnerItermax</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">stopInnerThr</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">stopThr</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#joint_OT_mapping_kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.joint_OT_mapping_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Joint OT and nonlinear mapping estimation with kernels as proposed in [8]</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\gamma,L\in\mathcal{H}}\quad \|L(X_s) -
n_s\gamma X_t\|^2_F + \mu&lt;\gamma,M&gt;_F + \eta  \|L\|^2_\mathcal{H}\\s.t. \gamma 1 = a\\     \gamma^T 1= b\\     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>M is the (ns,nt) squared euclidean cost matrix between samples in
Xs and Xt (scaled by ns)</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a ns x d linear operator on a kernel matrix that
approximates the barycentric mapping</p></li>
<li><p>a and b are uniform source and target weights</p></li>
</ul>
<p>The problem consist in solving jointly an optimal transport matrix
<span class="math notranslate nohighlight">\(\gamma\)</span> and the nonlinear mapping that fits the barycentric mapping
<span class="math notranslate nohighlight">\(n_s\gamma X_t\)</span>.</p>
<p>One can also estimate a mapping with constant bias (see supplementary
material of [8]) using the bias optional argument.</p>
<p>The algorithm used for solving the problem is the block coordinate
descent that alternates between updates of G (using conditionnal gradient)
and the update of L using a classical kernel least square solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>np.ndarray</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>,</em><em>optional</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for the linear mapping L (&gt;0)</p></li>
<li><p><strong>kerneltype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>,</em><em>optional</em>) – kernel used by calling function ot.utils.kernel (gaussian by default)</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Gaussian kernel bandwidth.</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>,</em><em>optional</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of BCD iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns x nt) ndarray</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>L</strong> (<em>(ns x d) ndarray</em>) – Nonlinear mapping matrix (ns+1 x d if bias)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets">8</span></dt>
<dd><p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.emd()</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.optim.cg()</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt id="ot.da.joint_OT_mapping_linear">
<code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">joint_OT_mapping_linear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xs</span></em>, <em class="sig-param"><span class="n">xt</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">bias</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose2</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">numItermax</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">numInnerItermax</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">stopInnerThr</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">stopThr</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#joint_OT_mapping_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.joint_OT_mapping_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Joint OT and linear mapping estimation as proposed in [8]</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\gamma,L}\quad \|L(X_s) -n_s\gamma X_t\|^2_F +
  \mu&lt;\gamma,M&gt;_F + \eta  \|L -I\|^2_F\\s.t. \gamma 1 = a\\     \gamma^T 1= b\\     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><dl class="simple">
<dt>M is the (ns,nt) squared euclidean cost matrix between samples in</dt><dd><p>Xs and Xt (scaled by ns)</p>
</dd>
</dl>
</li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a dxd linear operator that approximates the barycentric
mapping</p></li>
<li><p><span class="math notranslate nohighlight">\(I\)</span> is the identity matrix (neutral linear mapping)</p></li>
<li><p>a and b are uniform source and target weights</p></li>
</ul>
<p>The problem consist in solving jointly an optimal transport matrix
<span class="math notranslate nohighlight">\(\gamma\)</span> and a linear mapping that fits the barycentric mapping
<span class="math notranslate nohighlight">\(n_s\gamma X_t\)</span>.</p>
<p>One can also estimate a mapping with constant bias (see supplementary
material of [8]) using the bias optional argument.</p>
<p>The algorithm used for solving the problem is the block coordinate
descent that alternates between updates of G (using conditionnal gradient)
and the update of L using a classical least square solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>np.ndarray</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>,</em><em>optional</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for the linear mapping L (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>,</em><em>optional</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of BCD iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns x nt) ndarray</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>L</strong> (<em>(d x d) ndarray</em>) – Linear mapping matrix (d+1 x d if bias)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets">8</span></dt>
<dd><p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.emd()</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.optim.cg()</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt id="ot.da.sinkhorn_l1l2_gl">
<code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">sinkhorn_l1l2_gl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">labels_a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">reg</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">numItermax</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">numInnerItermax</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">stopInnerThr</span><span class="o">=</span><span class="default_value">1e-09</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_l1l2_gl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.sinkhorn_l1l2_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with group
lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma &lt;\gamma,M&gt;_F + reg\cdot\Omega_e(\gamma)+
\eta \Omega_g(\gamma)\\s.t. \gamma 1 = a\\     \gamma^T 1= b\\     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>M is the (ns,nt) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term
<span class="math notranslate nohighlight">\(\Omega_e(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso regulaization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^2\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class
c in the source domain.</p></li>
<li><p>a and b are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalised conditional
gradient as proposed in  <a href="#id65"><span class="problematic" id="id7">[5]_</span></a> <a href="#id66"><span class="problematic" id="id8">[7]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns x nt) ndarray</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">5</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id10"><span class="brackets">7</span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence and
applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.optim.html#ot.optim.gcg" title="ot.optim.gcg"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.optim.gcg()</span></code></a></dt><dd><p>Generalized conditional gradient for OT problems</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt id="ot.da.sinkhorn_lpl1_mm">
<code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">sinkhorn_lpl1_mm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">labels_a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">reg</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">numItermax</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">numInnerItermax</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">stopInnerThr</span><span class="o">=</span><span class="default_value">1e-09</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_lpl1_mm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.sinkhorn_lpl1_mm" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with nonconvex
group lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma &lt;\gamma,M&gt;_F + reg\cdot\Omega_e(\gamma)
+ \eta \Omega_g(\gamma)\\s.t. \gamma 1 = a\\     \gamma^T 1= b\\     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>M is the (ns,nt) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega_e
(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso  regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^{1/2}_1\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class c
in the source domain.</p></li>
<li><p>a and b are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in  <a href="#id67"><span class="problematic" id="id11">[5]_</span></a> <a href="#id68"><span class="problematic" id="id12">[7]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns x nt) ndarray</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets">5</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id14"><span class="brackets">7</span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.emd()</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn()</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.optim.cg()</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div></div>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="ot.da.BaseTransport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">BaseTransport</code><a class="reference internal" href="../_modules/ot/da.html#BaseTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.BaseTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for OTDA objects</p>
<p class="rubric">Notes</p>
<p>All estimators should specify all the parameters that can be set
at the class level in their <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as explicit keyword
arguments (no <code class="docutils literal notranslate"><span class="pre">*args</span></code> or <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>).</p>
<p>the fit method should:</p>
<ul class="simple">
<li><p>estimate a cost matrix and store it in a <cite>cost_</cite> attribute</p></li>
<li><p>estimate a coupling matrix and store it in a <cite>coupling_</cite></p></li>
</ul>
<p>attribute
- estimate distributions from source and target data and store them in
mu_s and mu_t attributes
- store Xs and Xt in attributes to be used later on in transform and
inverse_transform methods</p>
<p>transform method should always get as input a Xs parameter
inverse_transform method should always get as input a Xt parameter</p>
<p>transform_labels method should always get as input a ys parameter
inverse_transform_labels method should always get as input a yt parameter</p>
<dl class="py method">
<dt id="ot.da.BaseTransport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.BaseTransport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The training class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.BaseTransport.fit_transform">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.BaseTransport.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt) and transports source samples Xs onto target
ones Xt</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for training samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The source samples samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.BaseTransport.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">128</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.BaseTransport.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports target samples Xt onto source samples Xs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The target class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.BaseTransport.inverse_transform_labels">
<code class="sig-name descname">inverse_transform_labels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.BaseTransport.inverse_transform_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate target labels yt to obtain estimated source labels ys</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft source labels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.BaseTransport.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">128</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.BaseTransport.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports source samples Xs onto target ones Xt</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.BaseTransport.transform_labels">
<code class="sig-name descname">transform_labels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.BaseTransport.transform_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate source labels ys to obtain estimated target labels as in [27]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id15"><span class="brackets">27</span></dt>
<dd><p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="section" id="examples-using-ot-da-basetransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.BaseTransport</span></code><a class="headerlink" href="#examples-using-ot-da-basetransport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><div class="figure align-default" id="id37">
<img alt="Linear OT mapping estimation" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></span><a class="headerlink" href="#id37" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><div class="figure align-default" id="id38">
<img alt="OT for image color adaptation" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></span><a class="headerlink" href="#id38" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><div class="figure align-default" id="id39">
<img alt="OT with Laplacian regularization for domain adaptation" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></span><a class="headerlink" href="#id39" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><div class="figure align-default" id="id40">
<img alt="OT for image color adaptation with mapping estimation" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></span><a class="headerlink" href="#id40" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a semi supervised domain adaptation in a 2D setting. It explicits the p..."><div class="figure align-default" id="id41">
<img alt="OTDA unsupervised vs semi-supervised setting" src="../_images/sphx_glr_plot_otda_semi_supervised_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_semi_supervised.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-semi-supervised-py"><span class="std std-ref">OTDA unsupervised vs semi-supervised setting</span></a></span><a class="headerlink" href="#id41" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><div class="figure align-default" id="id42">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id42" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><div class="figure align-default" id="id43">
<img alt="OT for domain adaptation on empirical distributions" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></span><a class="headerlink" href="#id43" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><div class="figure align-default" id="id44">
<img alt="OT for multi-source target shift" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></span><a class="headerlink" href="#id44" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.EMDLaplaceTransport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">EMDLaplaceTransport</code><span class="sig-paren">(</span><em class="sig-param">reg_type='pos'</em>, <em class="sig-param">reg_lap=1.0</em>, <em class="sig-param">reg_src=1.0</em>, <em class="sig-param">metric='sqeuclidean'</em>, <em class="sig-param">norm=None</em>, <em class="sig-param">similarity='knn'</em>, <em class="sig-param">similarity_param=None</em>, <em class="sig-param">max_iter=100</em>, <em class="sig-param">tol=1e-09</em>, <em class="sig-param">max_inner_iter=100000</em>, <em class="sig-param">inner_tol=1e-09</em>, <em class="sig-param">log=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">distribution_estimation=&lt;function distribution_estimation_uniform&gt;</em>, <em class="sig-param">out_of_sample_map='ferradans'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.EMDLaplaceTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>Domain Adapatation OT method based on Earth Mover’s Distance with Laplacian regularization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_type</strong> (<em>string optional</em><em> (</em><em>default='pos'</em><em>)</em>) – Type of the regularization term: ‘pos’ and ‘disp’ for
regularization term defined in [2] and [6], respectively.</p></li>
<li><p><strong>reg_lap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Laplacian regularization parameter</p></li>
<li><p><strong>reg_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – Source relative importance in regularization</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>similarity</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;knn&quot;</em><em>)</em>) – The similarity to use either knn or gaussian</p></li>
<li><p><strong>similarity_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Parameter for the similarity: number of nearest neighbors or bandwidth
if similarity=”knn” or “gaussian”, respectively. If None is provided,
it is set to 3 or the average pairwise squared Euclidean distance, respectively.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in [6].</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt>
<code class="sig-name descname">coupling\_</code></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id16"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id17"><span class="brackets">2</span></dt>
<dd><p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”</p>
<blockquote>
<div><p>in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</div></blockquote>
</dd>
<dt class="label" id="id18"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ot.da.EMDLaplaceTransport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.EMDLaplaceTransport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-using-ot-da-emdlaplacetransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDLaplaceTransport</span></code><a class="headerlink" href="#examples-using-ot-da-emdlaplacetransport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><div class="figure align-default" id="id45">
<img alt="OT with Laplacian regularization for domain adaptation" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></span><a class="headerlink" href="#id45" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.EMDTransport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">EMDTransport</code><span class="sig-paren">(</span><em class="sig-param">metric='sqeuclidean'</em>, <em class="sig-param">norm=None</em>, <em class="sig-param">log=False</em>, <em class="sig-param">distribution_estimation=&lt;function distribution_estimation_uniform&gt;</em>, <em class="sig-param">out_of_sample_map='ferradans'</em>, <em class="sig-param">limit_max=10</em>, <em class="sig-param">max_iter=100000</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.EMDTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>Domain Adapatation OT method based on Earth Mover’s Distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in [6].</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt>
<code class="sig-name descname">coupling\_</code></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id19"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id20"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ot.da.EMDTransport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.EMDTransport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-using-ot-da-emdtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDTransport</span></code><a class="headerlink" href="#examples-using-ot-da-emdtransport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><div class="figure align-default" id="id46">
<img alt="OT for image color adaptation" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></span><a class="headerlink" href="#id46" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><div class="figure align-default" id="id47">
<img alt="OT with Laplacian regularization for domain adaptation" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></span><a class="headerlink" href="#id47" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><div class="figure align-default" id="id48">
<img alt="OT for image color adaptation with mapping estimation" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></span><a class="headerlink" href="#id48" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><div class="figure align-default" id="id49">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id49" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><div class="figure align-default" id="id50">
<img alt="OT for domain adaptation on empirical distributions" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></span><a class="headerlink" href="#id50" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.JCPOTTransport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">JCPOTTransport</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reg_e</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">metric</span><span class="o">=</span><span class="default_value">'sqeuclidean'</span></em>, <em class="sig-param"><span class="n">out_of_sample_map</span><span class="o">=</span><span class="default_value">'ferradans'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.JCPOTTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>Domain Adapatation OT method for multi-source target shift based on Wasserstein barycenter algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if no it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in [6].</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt>
<code class="sig-name descname">coupling\_</code></dt>
<dd><p>A set of optimal couplings between each source domain and the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of array-like objects, shape K x (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">proportions\_</code></dt>
<dd><p>Estimated class proportions in the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_classes,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">log\_</code></dt>
<dd><p>The dictionary of log, empty dic if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id21"><span class="brackets">1</span></dt>
<dd><p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS),
vol. 89, p.849-858, 2019.</p>
</dd>
<dt class="label" id="id22"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ot.da.JCPOTTransport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.JCPOTTransport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Building coupling matrices from a list of source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.JCPOTTransport.inverse_transform_labels">
<code class="sig-name descname">inverse_transform_labels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.inverse_transform_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.JCPOTTransport.inverse_transform_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate source labels ys to obtain target labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The target class labels</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_ys</strong> – A list of estimated soft source labels</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of K array-like objects, shape K x (nk_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.JCPOTTransport.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">128</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.JCPOTTransport.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports source samples Xs onto target ones Xt</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.JCPOTTransport.transform_labels">
<code class="sig-name descname">transform_labels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.JCPOTTransport.transform_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate source labels ys to obtain target labels as in [27]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ys</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>yt</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-using-ot-da-jcpottransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.JCPOTTransport</span></code><a class="headerlink" href="#examples-using-ot-da-jcpottransport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><div class="figure align-default" id="id51">
<img alt="OT for multi-source target shift" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></span><a class="headerlink" href="#id51" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.LinearTransport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">LinearTransport</code><span class="sig-paren">(</span><em class="sig-param">reg=1e-08</em>, <em class="sig-param">bias=True</em>, <em class="sig-param">log=False</em>, <em class="sig-param">distribution_estimation=&lt;function distribution_estimation_uniform&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.LinearTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>OT linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(N(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(N(\mu_t,\Sigma_t)\)</span> as proposed in [14] and discussed in
remark 2.29 in [15].</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(x)=Ax+b\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[A=\Sigma_s^{-1/2}(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2})^{1/2}
\Sigma_s^{-1/2}\]</div>
<div class="math notranslate nohighlight">
\[b=\mu_t-A\mu_s\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the daigonals of convariances (&gt;0)</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias b else b=0 (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id23"><span class="brackets">14</span></dt>
<dd><p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</dd>
<dt class="label" id="id24"><span class="brackets">15</span></dt>
<dd><p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ot.da.LinearTransport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.LinearTransport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.LinearTransport.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">128</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.LinearTransport.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports target samples Xt onto target samples Xs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.LinearTransport.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">128</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.LinearTransport.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports source samples Xs onto target ones Xt</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-using-ot-da-lineartransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearTransport</span></code><a class="headerlink" href="#examples-using-ot-da-lineartransport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><div class="figure align-default" id="id52">
<img alt="Linear OT mapping estimation" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></span><a class="headerlink" href="#id52" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.MappingTransport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">MappingTransport</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">bias</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">metric</span><span class="o">=</span><span class="default_value">'sqeuclidean'</span></em>, <em class="sig-param"><span class="n">norm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kernel</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">max_inner_iter</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">inner_tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose2</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.MappingTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>MappingTransport: DA methods that aims at jointly estimating a optimal
transport coupling and the associated mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.001</em><em>)</em>) – Regularization term for the linear mapping L (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>kernel</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;linear&quot;</em><em>)</em>) – The kernel to use either linear or gaussian</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – The gaussian kernel parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – record log if True</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt>
<code class="sig-name descname">coupling\_</code></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">mapping\_</code></dt>
<dd><p>(if bias) for kernel == linear
The associated mapping
array-like, shape (n_source_samples (+ 1), n_features)
(if bias) for kernel == gaussian</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_features (+ 1), n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">log\_</code></dt>
<dd><p>The dictionary of log, empty dic if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id25"><span class="brackets">8</span></dt>
<dd><p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ot.da.MappingTransport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.MappingTransport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds an optimal coupling and estimates the associated mapping
from source and target sets of samples (Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ot.da.MappingTransport.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.MappingTransport.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports source samples Xs onto target ones Xt</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-using-ot-da-mappingtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.MappingTransport</span></code><a class="headerlink" href="#examples-using-ot-da-mappingtransport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><div class="figure align-default" id="id53">
<img alt="OT for image color adaptation with mapping estimation" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></span><a class="headerlink" href="#id53" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents how to use MappingTransport to estimate at the same time both the couplin..."><div class="figure align-default" id="id54">
<img alt="OT mapping estimation for domain adaptation" src="../_images/sphx_glr_plot_otda_mapping_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-py"><span class="std std-ref">OT mapping estimation for domain adaptation</span></a></span><a class="headerlink" href="#id54" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.SinkhornL1l2Transport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">SinkhornL1l2Transport</code><span class="sig-paren">(</span><em class="sig-param">reg_e=1.0</em>, <em class="sig-param">reg_cl=0.1</em>, <em class="sig-param">max_iter=10</em>, <em class="sig-param">max_inner_iter=200</em>, <em class="sig-param">tol=1e-08</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">log=False</em>, <em class="sig-param">metric='sqeuclidean'</em>, <em class="sig-param">norm=None</em>, <em class="sig-param">distribution_estimation=&lt;function distribution_estimation_uniform&gt;</em>, <em class="sig-param">out_of_sample_map='ferradans'</em>, <em class="sig-param">limit_max=10</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.SinkhornL1l2Transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Domain Adapatation OT method based on sinkhorn algorithm +
l1l2 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if no it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in [6].</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt>
<code class="sig-name descname">coupling\_</code></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">log\_</code></dt>
<dd><p>The dictionary of log, empty dic if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id26"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id27"><span class="brackets">2</span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
<dt class="label" id="id28"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ot.da.SinkhornL1l2Transport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-using-ot-da-sinkhornl1l2transport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornL1l2Transport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhornl1l2transport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><div class="figure align-default" id="id55">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id55" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.SinkhornLpl1Transport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">SinkhornLpl1Transport</code><span class="sig-paren">(</span><em class="sig-param">reg_e=1.0</em>, <em class="sig-param">reg_cl=0.1</em>, <em class="sig-param">max_iter=10</em>, <em class="sig-param">max_inner_iter=200</em>, <em class="sig-param">log=False</em>, <em class="sig-param">tol=1e-08</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">metric='sqeuclidean'</em>, <em class="sig-param">norm=None</em>, <em class="sig-param">distribution_estimation=&lt;function distribution_estimation_uniform&gt;</em>, <em class="sig-param">out_of_sample_map='ferradans'</em>, <em class="sig-param">limit_max=inf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.SinkhornLpl1Transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Domain Adapatation OT method based on sinkhorn algorithm +
LpL1 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if no it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in [6].</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>defaul=np.infty</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit a cost defined by
limit_max.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt>
<code class="sig-name descname">coupling\_</code></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id29"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id30"><span class="brackets">2</span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
<dt class="label" id="id31"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ot.da.SinkhornLpl1Transport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.SinkhornLpl1Transport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-using-ot-da-sinkhornlpl1transport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornLpl1Transport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhornlpl1transport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><div class="figure align-default" id="id56">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id56" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><div class="figure align-default" id="id57">
<img alt="OT for domain adaptation on empirical distributions" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></span><a class="headerlink" href="#id57" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.SinkhornTransport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">SinkhornTransport</code><span class="sig-paren">(</span><em class="sig-param">reg_e=1.0</em>, <em class="sig-param">max_iter=1000</em>, <em class="sig-param">tol=1e-08</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">log=False</em>, <em class="sig-param">metric='sqeuclidean'</em>, <em class="sig-param">norm=None</em>, <em class="sig-param">distribution_estimation=&lt;function distribution_estimation_uniform&gt;</em>, <em class="sig-param">out_of_sample_map='ferradans'</em>, <em class="sig-param">limit_max=inf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.SinkhornTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>Domain Adapatation OT method based on Sinkhorn Algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1000</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if no it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – The precision required to stop the optimization algorithm.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in [6].</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>defaul=np.infty</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an cost defined
by this variable</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt>
<code class="sig-name descname">coupling\_</code></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">log\_</code></dt>
<dd><p>The dictionary of log, empty dic if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id32"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id33"><span class="brackets">2</span></dt>
<dd><p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems (NIPS)
26, 2013</p>
</dd>
<dt class="label" id="id34"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ot.da.SinkhornTransport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.SinkhornTransport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-using-ot-da-sinkhorntransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornTransport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhorntransport" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><div class="figure align-default" id="id58">
<img alt="OT for image color adaptation" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></span><a class="headerlink" href="#id58" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><div class="figure align-default" id="id59">
<img alt="OT with Laplacian regularization for domain adaptation" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></span><a class="headerlink" href="#id59" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><div class="figure align-default" id="id60">
<img alt="OT for image color adaptation with mapping estimation" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></span><a class="headerlink" href="#id60" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a semi supervised domain adaptation in a 2D setting. It explicits the p..."><div class="figure align-default" id="id61">
<img alt="OTDA unsupervised vs semi-supervised setting" src="../_images/sphx_glr_plot_otda_semi_supervised_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_semi_supervised.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-semi-supervised-py"><span class="std std-ref">OTDA unsupervised vs semi-supervised setting</span></a></span><a class="headerlink" href="#id61" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><div class="figure align-default" id="id62">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id62" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><div class="figure align-default" id="id63">
<img alt="OT for domain adaptation on empirical distributions" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></span><a class="headerlink" href="#id63" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><div class="figure align-default" id="id64">
<img alt="OT for multi-source target shift" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></span><a class="headerlink" href="#id64" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt id="ot.da.UnbalancedSinkhornTransport">
<em class="property">class </em><code class="sig-prename descclassname">ot.da.</code><code class="sig-name descname">UnbalancedSinkhornTransport</code><span class="sig-paren">(</span><em class="sig-param">reg_e=1.0</em>, <em class="sig-param">reg_m=0.1</em>, <em class="sig-param">method='sinkhorn'</em>, <em class="sig-param">max_iter=10</em>, <em class="sig-param">tol=1e-09</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">log=False</em>, <em class="sig-param">metric='sqeuclidean'</em>, <em class="sig-param">norm=None</em>, <em class="sig-param">distribution_estimation=&lt;function distribution_estimation_uniform&gt;</em>, <em class="sig-param">out_of_sample_map='ferradans'</em>, <em class="sig-param">limit_max=10</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>Domain Adapatation unbalanced OT method based on sinkhorn algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Mass regularization parameter</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’,  ‘sinkhorn_stabilized’ or
‘sinkhorn_epsilon_scaling’, see those function for specific parameters</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if no it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in [6].</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt>
<code class="sig-name descname">coupling\_</code></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">log\_</code></dt>
<dd><p>The dictionary of log, empty dic if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id35"><span class="brackets">1</span></dt>
<dd><p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).</p>
</dd>
</dl>
<p>Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.
.. [6] Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).</p>
<blockquote>
<div><p>Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</div></blockquote>
<dl class="py method">
<dt id="ot.da.UnbalancedSinkhornTransport.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xs</span></em>, <em class="sig-param"><span class="n">ys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
(Xs, ys) and (Xt, yt)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabeled, fill the
yt’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="sphx-glr-clear"></div></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ot.gpu.html" class="btn btn-neutral float-right" title="ot.gpu" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ot.optim.html" class="btn btn-neutral float-left" title="ot.optim" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2020, Rémi Flamary, Nicolas Courty

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>