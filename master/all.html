<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API and modules &mdash; POT Python Optimal Transport 0.8.0dev documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ot.lp" href="gen_modules/ot.lp.html" />
    <link rel="prev" title="Quick start guide" href="quickstart.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> POT Python Optimal Transport
          </a>
              <div class="version">
                0.8.0dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick start guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API and modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.da.html">ot.da</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.gpu.html">ot.gpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.sliced.html">ot.sliced</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Releases</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>API and modules</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/all.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-and-modules">
<span id="sphx-glr-api-reference"></span><h1>API and modules<a class="headerlink" href="#api-and-modules" title="Permalink to this headline">ÔÉÅ</a></h1>
<p><a class="reference internal" href="#module-ot" title="ot"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code></a>:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.lp.html#module-ot.lp" title="ot.lp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lp</span></code></a></p></td>
<td><p>Solvers for the original linear program OT problem</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.backend.html#module-ot.backend" title="ot.backend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend</span></code></a></p></td>
<td><p>Multi-lib backend for POT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.bregman.html#module-ot.bregman" title="ot.bregman"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bregman</span></code></a></p></td>
<td><p>Bregman projections solvers for entropic regularized OT</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.smooth.html#module-ot.smooth" title="ot.smooth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth</span></code></a></p></td>
<td><p>Smooth and Sparse Optimal Transport solvers (KL an L2 reg.)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.gromov.html#module-ot.gromov" title="ot.gromov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gromov</span></code></a></p></td>
<td><p>Gromov-Wasserstein and Fused-Gromov-Wasserstein solvers</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.optim.html#module-ot.optim" title="ot.optim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optim</span></code></a></p></td>
<td><p>Generic solvers for regularized OT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.da.html#module-ot.da" title="ot.da"><code class="xref py py-obj docutils literal notranslate"><span class="pre">da</span></code></a></p></td>
<td><p>Domain adaptation with optimal transport</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.gpu.html#module-ot.gpu" title="ot.gpu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gpu</span></code></a></p></td>
<td><p>GPU implementation for several OT solvers and utility functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.dr.html#module-ot.dr" title="ot.dr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dr</span></code></a></p></td>
<td><p>Dimension reduction with OT</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.utils.html#module-ot.utils" title="ot.utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">utils</span></code></a></p></td>
<td><p>Various useful functions</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.datasets.html#module-ot.datasets" title="ot.datasets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">datasets</span></code></a></p></td>
<td><p>Simple example datasets</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.plot.html#module-ot.plot" title="ot.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a></p></td>
<td><p>Functions for plotting OT matrices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.stochastic.html#module-ot.stochastic" title="ot.stochastic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stochastic</span></code></a></p></td>
<td><p>Stochastic solvers for regularized OT.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.unbalanced.html#module-ot.unbalanced" title="ot.unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unbalanced</span></code></a></p></td>
<td><p>Regularized Unbalanced OT solvers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.partial.html#module-ot.partial" title="ot.partial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial</span></code></a></p></td>
<td><p>Partial OT solvers</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.sliced.html#module-ot.sliced" title="ot.sliced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sliced</span></code></a></p></td>
<td><p>Sliced OT Distances</p></td>
</tr>
</tbody>
</table>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
</tbody>
</table>
<span class="target" id="module-ot"></span><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The list of automatically imported sub-modules is as follows:
<a class="reference internal" href="gen_modules/ot.lp.html#module-ot.lp" title="ot.lp"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.lp</span></code></a>, <a class="reference internal" href="gen_modules/ot.bregman.html#module-ot.bregman" title="ot.bregman"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.bregman</span></code></a>, <a class="reference internal" href="gen_modules/ot.optim.html#module-ot.optim" title="ot.optim"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.optim</span></code></a>
<a class="reference internal" href="gen_modules/ot.utils.html#module-ot.utils" title="ot.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.utils</span></code></a>, <a class="reference internal" href="gen_modules/ot.datasets.html#module-ot.datasets" title="ot.datasets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.datasets</span></code></a>,
<a class="reference internal" href="gen_modules/ot.gromov.html#module-ot.gromov" title="ot.gromov"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.gromov</span></code></a>, <a class="reference internal" href="gen_modules/ot.smooth.html#module-ot.smooth" title="ot.smooth"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.smooth</span></code></a>
<a class="reference internal" href="gen_modules/ot.stochastic.html#module-ot.stochastic" title="ot.stochastic"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.stochastic</span></code></a></p>
<p>The following sub-modules are not imported due to additional dependencies:</p>
<ul class="simple">
<li><p><a class="reference internal" href="gen_modules/ot.dr.html#module-ot.dr" title="ot.dr"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">ot.dr</span></code></a> : depends on <code class="code docutils literal notranslate"><span class="pre">pymanopt</span></code> and <code class="code docutils literal notranslate"><span class="pre">autograd</span></code>.</p></li>
<li><p><a class="reference internal" href="gen_modules/ot.gpu.html#module-ot.gpu" title="ot.gpu"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">ot.gpu</span></code></a> : depends on <code class="code docutils literal notranslate"><span class="pre">cupy</span></code> and a CUDA GPU.</p></li>
<li><p><a class="reference internal" href="gen_modules/ot.plot.html#module-ot.plot" title="ot.plot"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">ot.plot</span></code></a> : depends on <code class="code docutils literal notranslate"><span class="pre">matplotlib</span></code></p></li>
</ul>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="ot.barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/bregman.html#barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.barycenter" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Compute the entropic regularized wasserstein barycenter of distributions <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p>
<blockquote>
<div><p>The function solves the following optimization problem:</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = \mathop{\arg \min}_\mathbf{a} \sum_i W_{reg}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_{reg}(\cdot,\cdot)\)</span> is the entropic regularized Wasserstein distance (see <a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn()</span></code></a>)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
<li><p><cite>reg</cite> and <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> are respectively the regularization term and the cost matrix for OT</p></li>
</ul>
<p>The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="gen_modules/ot.bregman.html#references-barycenter"><span class="std std-ref">[3]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) ‚Äì <cite>n_hists</cite> training distributions <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> of size <cite>dim</cite></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>dim</em><em>)</em>) ‚Äì loss matrix for OT</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Regularization term &gt; 0</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em> (</em><em>optional</em><em>)</em>) ‚Äì method used for the solver either ‚Äòsinkhorn‚Äô or ‚Äòsinkhorn_stabilized‚Äô</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_hists</em><em>,</em><em>)</em>) ‚Äì Weights of each histogram <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> on the simplex (barycentric coodinates)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>(dim,) array-like</em>) ‚Äì Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-barycenter">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">3</span></dt>
<dd><p>Benamou, J. D., Carlier, G., Cuturi, M., Nenna, L., &amp; Peyr√©, G. (2015). Iterative Bregman projections for regularized transportation problems. SIAM Journal on Scientific Computing, 37(2), A1111-A1138.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.barycenter_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">barycenter_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/unbalanced.html#barycenter_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.barycenter_unbalanced" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Compute the entropic unbalanced wasserstein barycenter of A.</p>
<blockquote>
<div><p>The function solves the following optimization problem with a</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = arg\min_\mathbf{a} \sum_i Wu_{reg}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Wu_{reg}(\cdot,\cdot)\)</span> is the unbalanced entropic regularized</p></li>
</ul>
<p>Wasserstein distance (see ot.unbalanced.sinkhorn_unbalanced)
- <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span>
- reg and <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> are respectively the regularization term and
the cost matrix for OT
- reg_mis the marginal relaxation hyperparameter
The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a href="#id37"><span class="problematic" id="id2">[10]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) ‚Äì <cite>n_hists</cite> training distributions a_i of dimension dim</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>dim</em><em>, </em><em>dim</em><em>)</em>) ‚Äì ground metric matrix for OT.</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Marginal relaxation term &gt; 0</p></li>
<li><p><strong>weights</strong> (<em>np.ndarray</em><em> (</em><em>n_hists</em><em>,</em><em>) </em><em>optional</em>) ‚Äì Weight of each distribution (barycentric coodinates)
If None, uniform weights are used.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>(dim,) ndarray</em>) ‚Äì Unbalanced Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">3</span></dt>
<dd><p>Benamou, J. D., Carlier, G., Cuturi, M., Nenna, L., &amp; Peyr√©, G.
(2015). Iterative Bregman projections for regularized transportation
problems. SIAM Journal on Scientific Computing, 37(2), A1111-A1138.</p>
</dd>
<dt class="label" id="id4"><span class="brackets">10</span></dt>
<dd><p>Chizat, L., Peyr√©, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprin
arXiv:1607.05816.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.dist">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.dist" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Compute distance between samples in x1 and x2</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n1</em><em>,</em><em>d</em><em>)</em>) ‚Äì matrix with n1 samples of size d</p></li>
<li><p><strong>x2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n2</em><em>,</em><em>d</em><em>)</em><em>, </em><em>optional</em>) ‚Äì matrix with n2 samples of size d (if None then x2=x1)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em> | </em><em>callable</em><em>, </em><em>optional</em>) ‚Äì ‚Äòsqeuclidean‚Äô or ‚Äòeuclidean‚Äô on all backends. On numpy the function also
accepts  from the scipy.spatial.distance.cdist function : ‚Äòbraycurtis‚Äô,
‚Äòcanberra‚Äô, ‚Äòchebyshev‚Äô, ‚Äòcityblock‚Äô, ‚Äòcorrelation‚Äô, ‚Äòcosine‚Äô, ‚Äòdice‚Äô,
‚Äòeuclidean‚Äô, ‚Äòhamming‚Äô, ‚Äòjaccard‚Äô, ‚Äòkulsinski‚Äô, ‚Äòmahalanobis‚Äô,
‚Äòmatching‚Äô, ‚Äòminkowski‚Äô, ‚Äòrogerstanimoto‚Äô, ‚Äòrussellrao‚Äô, ‚Äòseuclidean‚Äô,
‚Äòsokalmichener‚Äô, ‚Äòsokalsneath‚Äô, ‚Äòsqeuclidean‚Äô, ‚Äòwminkowski‚Äô, ‚Äòyule‚Äô.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> ‚Äì distance matrix computed with given metric</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n1, n2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.emd">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">emd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp.html#emd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.emd" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma &lt;\gamma,M&gt;_F\\s.t. \gamma 1 = a\\     \gamma^T 1= b\\     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>M is the metric cost matrix</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the M matrix in numpy needs to be a C-order
numpy.array in float64 format. It will be converted if not in this
format</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends.</p>
</div>
<p>Uses the algorithm proposed in <a href="#id38"><span class="problematic" id="id5">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Loss matrix (c-order array in numpy with type float64)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) ‚Äì The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) ‚Äì If True, returns a dictionary containing the cost and dual variables.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) ‚Äì If True, centers the dual potential using function
<span class="xref std std-ref">center_ot_dual</span>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) ‚Äì If compiled with OpenMP, chooses the number of threads to parallelize.
‚Äúmax‚Äù selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (ns, nt)</em>) ‚Äì Optimal transportation matrix for the given
parameters</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) ‚Äì If input log is true, a dictionary containing the
cost and dual variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="go">array([[0.5, 0. ],</span>
<span class="go">       [0. , 0.5]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets">1</span></dt>
<dd><p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W. (2011,
December).  Displacement interpolation using Lagrangian mass transport.
In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p. 158). ACM.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT ot.optim.cg : General</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">regularized</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.emd2">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">emd2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp.html#emd2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.emd2" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma &lt;\gamma,M&gt;_F\\s.t. \gamma 1 = a\\     \gamma^T 1= b\\     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>M is the metric cost matrix</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends.</p>
</div>
<p>Uses the algorithm proposed in <a href="#id39"><span class="problematic" id="id7">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) ‚Äì Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) ‚Äì Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) ‚Äì Loss matrix (for numpy c-order array with type float64)</p></li>
<li><p><strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) ‚Äì Nb of processes used for multiple emd computation (deprecated)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) ‚Äì The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) ‚Äì If True, returns a dictionary containing dual
variables. Otherwise returns only the optimal transportation cost.</p></li>
<li><p><strong>return_matrix</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) ‚Äì If True, returns the optimal transportation matrix in the log.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) ‚Äì If True, centers the dual potential using function
<span class="xref std std-ref">center_ot_dual</span>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) ‚Äì If compiled with OpenMP, chooses the number of threads to parallelize.
‚Äúmax‚Äù selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float, array-like</em>) ‚Äì Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì If input log is true, a dictionary containing dual
variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets">1</span></dt>
<dd><p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.emd2_1d">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">emd2_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#emd2_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.emd2_1d" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p>x_a and x_b are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>When ‚Äòminkowski‚Äô is used as a metric, <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id40"><span class="problematic" id="id9">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>(</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) ‚Äì Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>(</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) ‚Äì Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) ‚Äì Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) ‚Äì Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) ‚Äì Metric to be used. Only strings listed in <a class="reference internal" href="#ot.dist" title="ot.dist"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.dist()</span></code></a> are accepted.
Due to implementation details, this function runs faster when
<cite>‚Äòsqeuclidean‚Äô</cite>, <cite>‚Äòminkowski‚Äô</cite>, <cite>‚Äòcityblock‚Äô</cite>,  or <cite>‚Äòeuclidean‚Äô</cite> metrics
are used.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) ‚Äì The p-norm to apply for if metric=‚Äôminkowski‚Äô</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) ‚Äì If True, returns math:<cite>gamma</cite> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy‚Äôs <cite>coo_matrix</cite>
format. Only used if log is set to True. Due to implementation details,
this function runs faster when dense is set to False.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) ‚Äì If True, returns a dictionary containing the transportation matrix.
Otherwise returns only the loss.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float</em>) ‚Äì Cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì If input log is True, a dictionary containing the Optimal transportation
matrix for the given parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd2_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id10"><span class="brackets">1</span></dt>
<dd><p>Peyr√©, G., &amp; Cuturi, M. (2017). ‚ÄúComputational Optimal
Transport‚Äù, 2018.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.emd2" title="ot.lp.emd2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd_1d</span></code></dt><dd><p>EMD for 1d distributions (returns the transportation matrix instead of the cost)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.emd_1d">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">emd_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#emd_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.emd_1d" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p>x_a and x_b are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>When ‚Äòminkowski‚Äô is used as a metric, <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id41"><span class="problematic" id="id11">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>(</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) ‚Äì Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>(</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) ‚Äì Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) ‚Äì Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) ‚Äì Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) ‚Äì Metric to be used. Only strings listed in <a class="reference internal" href="#ot.dist" title="ot.dist"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.dist()</span></code></a> are accepted.
Due to implementation details, this function runs faster when
<cite>‚Äòsqeuclidean‚Äô</cite>, <cite>‚Äòcityblock‚Äô</cite>,  or <cite>‚Äòeuclidean‚Äô</cite> metrics are used.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) ‚Äì The p-norm to apply for if metric=‚Äôminkowski‚Äô</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) ‚Äì If True, returns math:<cite>gamma</cite> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy‚Äôs <cite>coo_matrix</cite>
format. Due to implementation details, this function runs faster when
<cite>‚Äòsqeuclidean‚Äô</cite>, <cite>‚Äòminkowski‚Äô</cite>, <cite>‚Äòcityblock‚Äô</cite>,  or <cite>‚Äòeuclidean‚Äô</cite> metrics
are used.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) ‚Äì If True, returns a dictionary containing the cost.
Otherwise returns only the optimal transportation matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) ndarray</em>) ‚Äì Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì If input log is True, a dictionary containing the cost</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id12"><span class="brackets">1</span></dt>
<dd><p>Peyr√©, G., &amp; Cuturi, M. (2017). ‚ÄúComputational Optimal
Transport‚Äù, 2018.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2_1d</span></code></dt><dd><p>EMD for 1d distributions (returns cost instead of the transportation matrix)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.max_sliced_wasserstein_distance">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">max_sliced_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/sliced.html#max_sliced_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.max_sliced_wasserstein_distance" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Computes a Monte-Carlo approximation of the max p-Sliced Wasserstein distance</p>
<div class="math notranslate nohighlight">
\[\mathcal{Max-SWD}_p(\mu, \nu) = \underset{\theta _in
\mathcal{U}(\mathbb{S}^{d-1})}{\max} [\mathcal{W}_p^p(\theta_\#
\mu, \theta_\# \nu)]^{\frac{1}{p}}\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\theta_\# \mu\)</span> stands for the pushforwars of the projection <span class="math notranslate nohighlight">\(\mathbb{R}^d \ni X \mapsto \langle \theta, X \rangle\)</span></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_s</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>, </em><em>dim</em><em>)</em>) ‚Äì samples in the source domain</p></li>
<li><p><strong>X_t</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>, </em><em>dim</em><em>)</em>) ‚Äì samples in the target domain</p></li>
<li><p><strong>a</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) ‚Äì samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>,</em><em>)</em><em>, </em><em>optional</em>) ‚Äì samples weights in the target domain</p></li>
<li><p><strong>n_projections</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Number of projections used for the Monte-Carlo approximation</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional =</em>) ‚Äì Power p used for computing the sliced Wasserstein</p></li>
<li><p><strong>projections</strong> (<em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_projections</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Projection matrix (n_projections and seed are not used in this case)</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>RandomState</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><em>None</em></a><em>, </em><em>optional</em>) ‚Äì Seed used for random number generator</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì if True, sliced_wasserstein_distance returns the projections used and their associated EMD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cost</strong> (<em>float</em>) ‚Äì Sliced Wasserstein Cost</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) ‚Äì log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_samples_a</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">n_samples_a</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliced_wasserstein_distance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets">35</span></dt>
<dd><p>Deshpande, I., Hu, Y. T., Sun, R., Pyrros, A., Siddiqui, N., Koyejo, S., ‚Ä¶ &amp; Schwing, A. G. (2019). Max-sliced wasserstein distance and its use for gans. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 10648-10656).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/bregman.html#sinkhorn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solve the entropic regularization optimal transport problem and return the OT matrix</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma &lt;\gamma, \mathbf{M}&gt;_F + \mathrm{reg}\cdot\Omega(\gamma)\\s.t. \ \gamma \mathbf{1} &amp;= \mathbf{a}\\     \gamma^T \mathbf{1} &amp;= \mathbf{b}\\     \gamma &amp;\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (histograms, both sum to 1)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends.</p>
</div>
<p>The algorithm used for solving the problem is the Sinkhorn-Knopp matrix
scaling algorithm as proposed in <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[2]</span></a></p>
<p><strong>Choosing a Sinkhorn solver</strong></p>
<p>By default and when using a regularization parameter that is not too small
the default sinkhorn solver should be enough. If you need to use a small
regularization to get sharper OT matrices, you should use the
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_stabilized" title="ot.bregman.sinkhorn_stabilized"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_stabilized()</span></code></a> solver that will avoid numerical
errors. This last solver can be very slow in practice and might not even
converge to a reasonable OT matrix in a finite time. This is why
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_epsilon_scaling" title="ot.bregman.sinkhorn_epsilon_scaling"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_epsilon_scaling()</span></code></a> that relies on iterating the value
of the regularization (and using warm start) sometimes leads to better
solutions. Note that the greedy version of the sinkhorn
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.greenkhorn" title="ot.bregman.greenkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.greenkhorn()</span></code></a> can also lead to a speedup and the screening
version of the sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.screenkhorn" title="ot.bregman.screenkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.screenkhorn()</span></code></a> aim at providing  a
fast approximation of the Sinkhorn problem. For use of GPU and gradient
computation with small number of iterations we strongly recommend the
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_log" title="ot.bregman.sinkhorn_log"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_log</span></code></a> solver that will no need to check for
numerical problems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) ‚Äì samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) ‚Äì samples in the target domain, compute sinkhorn with multiple targets
and fixed <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is a matrix (return OT loss + dual variables in log)</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) ‚Äì loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Regularization term &gt;0</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) ‚Äì method used for the solver either ‚Äòsinkhorn‚Äô,‚Äôsinkhorn_log‚Äô,
‚Äògreenkhorn‚Äô, ‚Äòsinkhorn_stabilized‚Äô or ‚Äòsinkhorn_epsilon_scaling‚Äô, see
those function for specific parameters</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (dim_a, dim_b)</em>) ‚Äì Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">sinkhorn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0.36552929, 0.13447071],</span>
<span class="go">       [0.13447071, 0.36552929]])</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn">References</p>
<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets">2</span></dt>
<dd><ol class="upperalpha simple" start="13">
<li><p>Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013</p></li>
</ol>
</dd>
<dt class="label" id="id15"><span class="brackets">9</span></dt>
<dd><p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms for Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</dd>
<dt class="label" id="id16"><span class="brackets">10</span></dt>
<dd><p>Chizat, L., Peyr√©, G., Schmitzer, B., &amp; Vialard, F. X. (2016). Scaling algorithms for unbalanced transport problems. arXiv preprint arXiv:1607.05816.</p>
</dd>
<dt class="label" id="id17"><span class="brackets">34</span></dt>
<dd><p>Feydy, J., S√©journ√©, T., Vialard, F. X., Amari, S. I., Trouv√©, A., &amp; Peyr√©, G. (2019, April). Interpolating between optimal transport and MMD using Sinkhorn divergences. In The 22nd International Conference on Artificial Intelligence and Statistics (pp. 2681-2690). PMLR.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_knopp" title="ot.bregman.sinkhorn_knopp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_knopp</span></code></a></dt><dd><p>Classic Sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[2]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_stabilized" title="ot.bregman.sinkhorn_stabilized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_stabilized</span></code></a></dt><dd><p>Stabilized sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[9]</span></a> <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[10]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_epsilon_scaling" title="ot.bregman.sinkhorn_epsilon_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_epsilon_scaling</span></code></a></dt><dd><p>Sinkhorn with epslilon scaling <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[9]</span></a> <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[10]</span></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn2">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/bregman.html#sinkhorn2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn2" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solve the entropic regularization optimal transport problem and return the loss</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \min_\gamma &lt;\gamma, \mathbf{M}&gt;_F + \mathrm{reg}\cdot\Omega(\gamma)\\s.t. \ \gamma \mathbf{1} &amp;= \mathbf{a}\\     \gamma^T \mathbf{1} &amp;= \mathbf{b}\\     \gamma &amp;\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (histograms, both sum to 1)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends.</p>
</div>
<p>The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[2]</span></a></p>
<p><strong>Choosing a Sinkhorn solver</strong></p>
<p>By default and when using a regularization parameter that is not too small
the default sinkhorn solver should be enough. If you need to use a small
regularization to get sharper OT matrices, you should use the
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_log" title="ot.bregman.sinkhorn_log"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_log</span></code></a> solver that will avoid numerical
errors. This last solver can be very slow in practice and might not even
converge to a reasonable OT matrix in a finite time. This is why
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_epsilon_scaling" title="ot.bregman.sinkhorn_epsilon_scaling"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_epsilon_scaling</span></code></a> that relies on iterating the value
of the regularization (and using warm start) sometimes leads to better
solutions. Note that the greedy version of the sinkhorn
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.greenkhorn" title="ot.bregman.greenkhorn"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ot.bregman.greenkhorn</span></code></a> can also lead to a speedup and the screening
version of the sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.screenkhorn" title="ot.bregman.screenkhorn"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ot.bregman.screenkhorn</span></code></a> aim a providing  a
fast approximation of the Sinkhorn problem. For use of GPU and gradient
computation with small number of iterations we strongly recommend the
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_log" title="ot.bregman.sinkhorn_log"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_log</span></code></a> solver that will no need to check for
numerical problems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) ‚Äì samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) ‚Äì samples in the target domain, compute sinkhorn with multiple targets
and fixed <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is a matrix (return OT loss + dual variables in log)</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) ‚Äì loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Regularization term &gt;0</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) ‚Äì method used for the solver either ‚Äòsinkhorn‚Äô,‚Äôsinkhorn_log‚Äô,
‚Äòsinkhorn_stabilized‚Äô, see those function for specific parameters</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>(n_hists) float/array-like</em>) ‚Äì Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">sinkhorn2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0.26894142136999516</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn2">References</p>
<dl class="footnote brackets">
<dt class="label" id="id18"><span class="brackets">2</span></dt>
<dd><ol class="upperalpha simple" start="13">
<li><p>Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013</p></li>
</ol>
</dd>
<dt class="label" id="id19"><span class="brackets">9</span></dt>
<dd><p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms for Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</dd>
<dt class="label" id="id20"><span class="brackets">10</span></dt>
<dd><p>Chizat, L., Peyr√©, G., Schmitzer, B., &amp; Vialard, F. X. (2016). Scaling algorithms for unbalanced transport problems. arXiv preprint arXiv:1607.05816.</p>
</dd>
<dt class="label" id="id21"><span class="brackets">21</span></dt>
<dd><p>Altschuler J., Weed J., Rigollet P. : Near-linear time approximation</p>
</dd>
</dl>
<p>algorithms for optimal transport via Sinkhorn iteration, Advances in Neural
Information Processing Systems (NIPS) 31, 2017</p>
<dl class="footnote brackets">
<dt class="label" id="id22"><span class="brackets">34</span></dt>
<dd><p>Feydy, J., S√©journ√©, T., Vialard, F. X., Amari, S. I., Trouv√©, A., &amp; Peyr√©, G. (2019, April). Interpolating between optimal transport and MMD using Sinkhorn divergences. In The 22nd International Conference on Artificial Intelligence and Statistics (pp. 2681-2690). PMLR.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_knopp" title="ot.bregman.sinkhorn_knopp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_knopp</span></code></a></dt><dd><p>Classic Sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[2]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.greenkhorn" title="ot.bregman.greenkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.greenkhorn</span></code></a></dt><dd><p>Greenkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[21]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_stabilized" title="ot.bregman.sinkhorn_stabilized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_stabilized</span></code></a></dt><dd><p>Stabilized sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[9]</span></a> <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[10]</span></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn_lpl1_mm">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_lpl1_mm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/da.html#sinkhorn_lpl1_mm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn_lpl1_mm" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with nonconvex
group lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma &lt;\gamma,M&gt;_F + reg\cdot\Omega_e(\gamma)
+ \eta \Omega_g(\gamma)\\s.t. \gamma 1 = a\\     \gamma^T 1= b\\     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>M is the (ns,nt) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega_e
(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso  regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^{1/2}_1\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class c
in the source domain.</p></li>
<li><p>a and b are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in  <a class="footnote-reference brackets" href="#id25" id="id23">5</a> <a class="footnote-reference brackets" href="#id26" id="id24">7</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>)</em>) ‚Äì samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>)</em>) ‚Äì labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em><em> (</em><em>nt</em><em>,</em><em>)</em>) ‚Äì samples weights in the target domain</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) ‚Äì loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns x nt) ndarray</em>) ‚Äì Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id25"><span class="brackets"><a class="fn-backref" href="#id23">5</a></span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
‚ÄúOptimal Transport for Domain Adaptation,‚Äù in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id24">7</a></span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/unbalanced.html#sinkhorn_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn_unbalanced" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solve the unbalanced entropic regularization optimal transport problem
and return the OT plan</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \min_\gamma &lt;\gamma,M&gt;_F + reg\cdot\Omega(\gamma) + reg_m KL(\gamma 1, a) + reg_m KL(\gamma^T 1, b)\\s.t.
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>M is the (dim_a, dim_b) metric cost matrix</p></li>
<li><dl class="simple">
<dt><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization</dt><dd><p>term <span class="math notranslate nohighlight">\(\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p>
</dd>
</dl>
</li>
<li><p>a and b are source and target unbalanced distributions</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<dl class="simple">
<dt>The algorithm used for solving the problem is the generalized</dt><dd><p>Sinkhorn-Knopp matrix scaling algorithm as proposed in [10, 23]_</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) ‚Äì Unnormalized histogram of dimension dim_a</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>np.ndarray</em><em> (</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) ‚Äì One or multiple unnormalized histograms of dimension dim_b
If many, compute all the OT distances (a, b_i)</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) ‚Äì loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Marginal relaxation term &gt; 0</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) ‚Äì method used for the solver either ‚Äòsinkhorn‚Äô,  ‚Äòsinkhorn_stabilized‚Äô or
‚Äòsinkhorn_reg_scaling‚Äô, see those function for specific parameters</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><em>if n_hists == 1</em> ‚Äì</p>
<dl class="simple">
<dt>gamma<span class="classifier">(dim_a x dim_b) ndarray</span></dt><dd><p>Optimal transportation matrix for the given parameters</p>
</dd>
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
<li><p><em>else</em> ‚Äì</p>
<dl class="simple">
<dt>ot_distance<span class="classifier">(n_hists,) ndarray</span></dt><dd><p>the OT distance between <cite>a</cite> and each of the histograms <cite>b_i</cite></p>
</dd>
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">sinkhorn_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0.51122823, 0.18807035],</span>
<span class="go">       [0.18807035, 0.51122823]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id27"><span class="brackets">2</span></dt>
<dd><p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems
(NIPS) 26, 2013</p>
</dd>
<dt class="label" id="id28"><span class="brackets">9</span></dt>
<dd><p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms for
Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</dd>
<dt class="label" id="id29"><span class="brackets">10</span></dt>
<dd><p>Chizat, L., Peyr√©, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</dd>
<dt class="label" id="id30"><span class="brackets">25</span></dt>
<dd><p>Frogner C., Zhang C., Mobahi H., Araya-Polo M., Poggio T. :
Learning with a Wasserstein Loss,  Advances in Neural Information
Processing Systems (NIPS) 2015</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.unbalanced.html#ot.unbalanced.sinkhorn_knopp_unbalanced" title="ot.unbalanced.sinkhorn_knopp_unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_knopp_unbalanced</span></code></a></dt><dd><p>Unbalanced Classic Sinkhorn [10]</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.unbalanced.html#ot.unbalanced.sinkhorn_stabilized_unbalanced" title="ot.unbalanced.sinkhorn_stabilized_unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_stabilized_unbalanced</span></code></a></dt><dd><p>Unbalanced Stabilized sinkhorn [9][10]</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_reg_scaling_unbalanced</span></code></dt><dd><p>Unbalanced Sinkhorn with epslilon scaling [9][10]</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn_unbalanced2">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_unbalanced2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/unbalanced.html#sinkhorn_unbalanced2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn_unbalanced2" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Solve the entropic regularization unbalanced optimal transport problem and
return the loss</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \min_\gamma &lt;\gamma,M&gt;_F + reg\cdot\Omega(\gamma) + reg_m KL(\gamma 1, a) + reg_m KL(\gamma^T 1, b)\\s.t.
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>M is the (dim_a, dim_b) metric cost matrix</p></li>
<li><dl class="simple">
<dt><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization term</dt><dd><p><span class="math notranslate nohighlight">\(\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p>
</dd>
</dl>
</li>
<li><p>a and b are source and target unbalanced distributions</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in [10, 23]_</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) ‚Äì Unnormalized histogram of dimension dim_a</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>np.ndarray</em><em> (</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) ‚Äì One or multiple unnormalized histograms of dimension dim_b
If many, compute all the OT distances (a, b_i)</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) ‚Äì loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) ‚Äì Marginal relaxation term &gt; 0</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) ‚Äì method used for the solver either ‚Äòsinkhorn‚Äô,  ‚Äòsinkhorn_stabilized‚Äô or
‚Äòsinkhorn_reg_scaling‚Äô, see those function for specific parameters</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ot_distance</strong> (<em>(n_hists,) ndarray</em>) ‚Äì the OT distance between <cite>a</cite> and each of the histograms <cite>b_i</cite></p></li>
<li><p><strong>log</strong> (<em>dict</em>) ‚Äì log dictionary returned only if <cite>log</cite> is <cite>True</cite></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">sinkhorn_unbalanced2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="go">array([0.31912866])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id31"><span class="brackets">2</span></dt>
<dd><p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems
(NIPS) 26, 2013</p>
</dd>
<dt class="label" id="id32"><span class="brackets">9</span></dt>
<dd><p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms for
Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</dd>
<dt class="label" id="id33"><span class="brackets">10</span></dt>
<dd><p>Chizat, L., Peyr√©, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</dd>
<dt class="label" id="id34"><span class="brackets">25</span></dt>
<dd><p>Frogner C., Zhang C., Mobahi H., Araya-Polo M., Poggio T. :
Learning with a Wasserstein Loss,  Advances in Neural Information
Processing Systems (NIPS) 2015</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_knopp</span></code></dt><dd><p>Unbalanced Classic Sinkhorn [10]</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_stabilized</span></code></dt><dd><p>Unbalanced Stabilized sinkhorn [9][10]</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_reg_scaling</span></code></dt><dd><p>Unbalanced Sinkhorn with epslilon scaling [9][10]</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sliced_wasserstein_distance">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sliced_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/sliced.html#sliced_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sliced_wasserstein_distance" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Computes a Monte-Carlo approximation of the p-Sliced Wasserstein distance</p>
<div class="math notranslate nohighlight">
\[\mathcal{SWD}_p(\mu, \nu) = \underset{\theta \sim \mathcal{U}(\mathbb{S}^{d-1})}{\mathbb{E}}[\mathcal{W}_p^p(\theta_\# \mu, \theta_\# \nu)]^{\frac{1}{p}}\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\theta_\# \mu\)</span> stands for the pushforwars of the projection <span class="math notranslate nohighlight">\(\mathbb{R}^d \ni X \mapsto \langle \theta, X \rangle\)</span></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_s</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>, </em><em>dim</em><em>)</em>) ‚Äì samples in the source domain</p></li>
<li><p><strong>X_t</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>, </em><em>dim</em><em>)</em>) ‚Äì samples in the target domain</p></li>
<li><p><strong>a</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) ‚Äì samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>,</em><em>)</em><em>, </em><em>optional</em>) ‚Äì samples weights in the target domain</p></li>
<li><p><strong>n_projections</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Number of projections used for the Monte-Carlo approximation</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional =</em>) ‚Äì Power p used for computing the sliced Wasserstein</p></li>
<li><p><strong>projections</strong> (<em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_projections</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Projection matrix (n_projections and seed are not used in this case)</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><em>RandomState</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><em>None</em></a><em>, </em><em>optional</em>) ‚Äì Seed used for random number generator</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì if True, sliced_wasserstein_distance returns the projections used and their associated EMD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cost</strong> (<em>float</em>) ‚Äì Sliced Wasserstein Cost</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) ‚Äì log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_samples_a</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">n_samples_a</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliced_wasserstein_distance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id35"><span class="brackets">31</span></dt>
<dd><p>Bonneel, Nicolas, et al. ‚ÄúSliced and radon wasserstein barycenters of measures.‚Äù Journal of Mathematical Imaging and Vision 51.1 (2015): 22-45</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.tic">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">tic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#tic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.tic" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Python implementation of Matlab tic() function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.toc">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">toc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elapsed</span> <span class="pre">time</span> <span class="pre">:</span> <span class="pre">{}</span> <span class="pre">s'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#toc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.toc" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Python implementation of Matlab toc() function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.toq">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">toq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#toq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.toq" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Python implementation of Julia toc() function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unif">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">unif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#unif"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unif" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>return a uniform histogram of length n (simplex)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a>) ‚Äì number of bins in the histogram</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> ‚Äì histogram of length n such that h_i=1/n for all i</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array (n,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.wasserstein_1d">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">wasserstein_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#wasserstein_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.wasserstein_1d" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Computes the 1 dimensional OT loss [15] between two (batched) empirical
distributions</p>
<p>It is formally the p-Wasserstein distance raised to the power p.
We do so in a vectorized way by first building the individual quantile functions then integrating them.</p>
<p>This function should be preferred to <cite>emd_1d</cite> whenever the backend is
different to numpy, and when gradients over
either sample positions or weights are required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) ‚Äì locations of the first empirical distribution</p></li>
<li><p><strong>v_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em>) ‚Äì locations of the second empirical distribution</p></li>
<li><p><strong>u_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) ‚Äì weights of the first empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>v_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) ‚Äì weights of the second empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì order of the ground metric used, should be at least 1 (see [2, Chap. 2], default is 1</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì sort the distributions atoms locations, if False we will consider they have been sorted prior to being passed to
the function, default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cost</strong> ‚Äì the batched EMD</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float/array-like, shape (‚Ä¶)</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id36"><span class="brackets">15</span></dt>
<dd><p>Peyr√©, G., &amp; Cuturi, M. (2018). Computational Optimal Transport.</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="quickstart.html" class="btn btn-neutral float-left" title="Quick start guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="gen_modules/ot.lp.html" class="btn btn-neutral float-right" title="ot.lp" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, R√©mi Flamary, Nicolas Courty.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions shift-up" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Python Optimal Transport</span>
      versions
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions"><!-- Inserted RTD Footer -->

<div class="injected">

      
      
      <dl>
        <dt>Versions</dt>
        
        <dd><a href="https://pythonot.github.io/master">latest</a></dd>
       
        <dd><a href="https://pythonot.github.io/">stable</a></dd>
        
      </dl>
      

    
      
      <dl>
        <dt>On GitHub</dt>
        <dd>
          <a href="https://github.com/PythonOT/POT">Code on Github</a>
        </dd>
        
      </dl>
      
    
      
      

      <hr>
      


</div>
</div>
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>