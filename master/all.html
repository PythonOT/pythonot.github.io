<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API and modules &mdash; POT Python Optimal Transport 0.9.2dev documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=925fdc35"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ot.backend" href="gen_modules/ot.backend.html" />
    <link rel="prev" title="Quick start guide" href="quickstart.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9.2dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick start guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API and modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.coot.html">ot.coot</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.da.html">ot.da</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.factored.html">ot.factored</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.gaussian.html">ot.gaussian</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.mapping.html">ot.mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_modules/ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ot.barycenter"><code class="docutils literal notranslate"><span class="pre">barycenter()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.barycenter_unbalanced"><code class="docutils literal notranslate"><span class="pre">barycenter_unbalanced()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.binary_search_circle"><code class="docutils literal notranslate"><span class="pre">binary_search_circle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.dist"><code class="docutils literal notranslate"><span class="pre">dist()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.emd"><code class="docutils literal notranslate"><span class="pre">emd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.emd2"><code class="docutils literal notranslate"><span class="pre">emd2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.emd2_1d"><code class="docutils literal notranslate"><span class="pre">emd2_1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.emd_1d"><code class="docutils literal notranslate"><span class="pre">emd_1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.factored_optimal_transport"><code class="docutils literal notranslate"><span class="pre">factored_optimal_transport()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.fused_gromov_wasserstein"><code class="docutils literal notranslate"><span class="pre">fused_gromov_wasserstein()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.fused_gromov_wasserstein2"><code class="docutils literal notranslate"><span class="pre">fused_gromov_wasserstein2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.gromov_barycenters"><code class="docutils literal notranslate"><span class="pre">gromov_barycenters()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.gromov_wasserstein"><code class="docutils literal notranslate"><span class="pre">gromov_wasserstein()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.gromov_wasserstein2"><code class="docutils literal notranslate"><span class="pre">gromov_wasserstein2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lowrank_sinkhorn"><code class="docutils literal notranslate"><span class="pre">lowrank_sinkhorn()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.max_sliced_wasserstein_distance"><code class="docutils literal notranslate"><span class="pre">max_sliced_wasserstein_distance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.semidiscrete_wasserstein2_unif_circle"><code class="docutils literal notranslate"><span class="pre">semidiscrete_wasserstein2_unif_circle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.sinkhorn"><code class="docutils literal notranslate"><span class="pre">sinkhorn()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.sinkhorn2"><code class="docutils literal notranslate"><span class="pre">sinkhorn2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.sinkhorn_lpl1_mm"><code class="docutils literal notranslate"><span class="pre">sinkhorn_lpl1_mm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.sinkhorn_unbalanced"><code class="docutils literal notranslate"><span class="pre">sinkhorn_unbalanced()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.sinkhorn_unbalanced2"><code class="docutils literal notranslate"><span class="pre">sinkhorn_unbalanced2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.sliced_wasserstein_distance"><code class="docutils literal notranslate"><span class="pre">sliced_wasserstein_distance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.sliced_wasserstein_sphere"><code class="docutils literal notranslate"><span class="pre">sliced_wasserstein_sphere()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.sliced_wasserstein_sphere_unif"><code class="docutils literal notranslate"><span class="pre">sliced_wasserstein_sphere_unif()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.solve"><code class="docutils literal notranslate"><span class="pre">solve()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.solve_gromov"><code class="docutils literal notranslate"><span class="pre">solve_gromov()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.solve_sample"><code class="docutils literal notranslate"><span class="pre">solve_sample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.tic"><code class="docutils literal notranslate"><span class="pre">tic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.toc"><code class="docutils literal notranslate"><span class="pre">toc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.toq"><code class="docutils literal notranslate"><span class="pre">toq()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unif"><code class="docutils literal notranslate"><span class="pre">unif()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.wasserstein_1d"><code class="docutils literal notranslate"><span class="pre">wasserstein_1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.wasserstein_circle"><code class="docutils literal notranslate"><span class="pre">wasserstein_circle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.weak_optimal_transport"><code class="docutils literal notranslate"><span class="pre">weak_optimal_transport()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API and modules</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/all.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-and-modules">
<span id="sphx-glr-api-reference"></span><h1>API and modules<a class="headerlink" href="#api-and-modules" title="Link to this heading"></a></h1>
<p><a class="reference internal" href="#module-ot" title="ot"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code></a>:</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.backend.html#module-ot.backend" title="ot.backend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">backend</span></code></a></p></td>
<td><p>Multi-lib backend for POT</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.bregman.html#module-ot.bregman" title="ot.bregman"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bregman</span></code></a></p></td>
<td><p>Solvers related to Bregman projections for entropic regularized OT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.coot.html#module-ot.coot" title="ot.coot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coot</span></code></a></p></td>
<td><p>CO-Optimal Transport solver</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.da.html#module-ot.da" title="ot.da"><code class="xref py py-obj docutils literal notranslate"><span class="pre">da</span></code></a></p></td>
<td><p>Domain adaptation with optimal transport</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.datasets.html#module-ot.datasets" title="ot.datasets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">datasets</span></code></a></p></td>
<td><p>Simple example datasets</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.dr.html#module-ot.dr" title="ot.dr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dr</span></code></a></p></td>
<td><p>Dimension reduction with OT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.factored.html#module-ot.factored" title="ot.factored"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factored</span></code></a></p></td>
<td><p>Factored OT solvers (low rank, cost or OT plan)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.gaussian.html#module-ot.gaussian" title="ot.gaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gaussian</span></code></a></p></td>
<td><p>Optimal transport for Gaussian distributions</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.gnn.html#module-ot.gnn" title="ot.gnn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gnn</span></code></a></p></td>
<td><p>Layers and functions for optimal transport in Graph Neural Networks.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.gromov.html#module-ot.gromov" title="ot.gromov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gromov</span></code></a></p></td>
<td><p>Solvers related to Gromov-Wasserstein problems.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.lp.html#module-ot.lp" title="ot.lp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lp</span></code></a></p></td>
<td><p>Solvers for the original linear program OT problem.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.mapping.html#module-ot.mapping" title="ot.mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mapping</span></code></a></p></td>
<td><p>Optimal Transport maps and variants</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.optim.html#module-ot.optim" title="ot.optim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optim</span></code></a></p></td>
<td><p>Generic solvers for regularized OT or its semi-relaxed version.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.partial.html#module-ot.partial" title="ot.partial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial</span></code></a></p></td>
<td><p>Partial OT solvers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.plot.html#module-ot.plot" title="ot.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a></p></td>
<td><p>Functions for plotting OT matrices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.regpath.html#module-ot.regpath" title="ot.regpath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regpath</span></code></a></p></td>
<td><p>Regularization path OT solvers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.sliced.html#module-ot.sliced" title="ot.sliced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sliced</span></code></a></p></td>
<td><p>Sliced OT Distances</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.smooth.html#module-ot.smooth" title="ot.smooth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth</span></code></a></p></td>
<td><p>Smooth and Sparse (KL an L2 reg.) and sparsity-constrained OT solvers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.stochastic.html#module-ot.stochastic" title="ot.stochastic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stochastic</span></code></a></p></td>
<td><p>Stochastic solvers for regularized OT.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.unbalanced.html#module-ot.unbalanced" title="ot.unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unbalanced</span></code></a></p></td>
<td><p>Regularized Unbalanced OT solvers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/ot.utils.html#module-ot.utils" title="ot.utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">utils</span></code></a></p></td>
<td><p>Various useful functions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/ot.weak.html#module-ot.weak" title="ot.weak"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weak</span></code></a></p></td>
<td><p>Weak optimal ransport solvers</p></td>
</tr>
</tbody>
</table>
<section id="module-ot">
<span id="main-ot-functions"></span><h2>Main <a class="reference internal" href="#module-ot" title="ot"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code></a> functions<a class="headerlink" href="#module-ot" title="Link to this heading"></a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The list of automatically imported sub-modules is as follows:
<a class="reference internal" href="gen_modules/ot.lp.html#module-ot.lp" title="ot.lp"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.lp</span></code></a>, <a class="reference internal" href="gen_modules/ot.bregman.html#module-ot.bregman" title="ot.bregman"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.bregman</span></code></a>, <a class="reference internal" href="gen_modules/ot.optim.html#module-ot.optim" title="ot.optim"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.optim</span></code></a>
<a class="reference internal" href="gen_modules/ot.utils.html#module-ot.utils" title="ot.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.utils</span></code></a>, <a class="reference internal" href="gen_modules/ot.datasets.html#module-ot.datasets" title="ot.datasets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.datasets</span></code></a>,
<a class="reference internal" href="gen_modules/ot.gromov.html#module-ot.gromov" title="ot.gromov"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.gromov</span></code></a>, <a class="reference internal" href="gen_modules/ot.smooth.html#module-ot.smooth" title="ot.smooth"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.smooth</span></code></a>
<a class="reference internal" href="gen_modules/ot.stochastic.html#module-ot.stochastic" title="ot.stochastic"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.stochastic</span></code></a>, <a class="reference internal" href="gen_modules/ot.partial.html#module-ot.partial" title="ot.partial"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.partial</span></code></a>, <a class="reference internal" href="gen_modules/ot.regpath.html#module-ot.regpath" title="ot.regpath"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.regpath</span></code></a>
, <a class="reference internal" href="gen_modules/ot.unbalanced.html#module-ot.unbalanced" title="ot.unbalanced"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ot.unbalanced</span></code></a>, :py:mod`ot.mapping`.
The following sub-modules are not imported due to additional dependencies:
- <a class="reference internal" href="gen_modules/ot.dr.html#module-ot.dr" title="ot.dr"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">ot.dr</span></code></a> : depends on <code class="code docutils literal notranslate"><span class="pre">pymanopt</span></code> and <code class="code docutils literal notranslate"><span class="pre">autograd</span></code>.
- <a class="reference internal" href="gen_modules/ot.plot.html#module-ot.plot" title="ot.plot"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">ot.plot</span></code></a> : depends on <code class="code docutils literal notranslate"><span class="pre">matplotlib</span></code></p>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="ot.barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/bregman/_barycenter.html#barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.barycenter" title="Link to this definition"></a></dt>
<dd><p>Compute the entropic regularized wasserstein barycenter of distributions <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p>
<blockquote>
<div><p>The function solves the following optimization problem:</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = \mathop{\arg \min}_\mathbf{a} \quad \sum_i W_{reg}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_{reg}(\cdot,\cdot)\)</span> is the entropic regularized Wasserstein
distance (see <a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn()</span></code></a>)
if <cite>method</cite> is <cite>sinkhorn</cite> or <cite>sinkhorn_stabilized</cite> or <cite>sinkhorn_log</cite>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
<li><p><cite>reg</cite> and <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> are respectively the regularization term and
the cost matrix for OT</p></li>
</ul>
<p>The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling
algorithm as proposed in <a class="reference internal" href="gen_modules/ot.bregman.html#references-barycenter"><span class="std std-ref">[3]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – <cite>n_hists</cite> training distributions <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> of size <cite>dim</cite></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>dim</em><em>)</em>) – loss matrix for OT</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Regularization term &gt; 0</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em> (</em><em>optional</em><em>)</em>) – method used for the solver either ‘sinkhorn’ or ‘sinkhorn_stabilized’ or ‘sinkhorn_log’</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_hists</em><em>,</em><em>)</em>) – Weights of each histogram <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> on the simplex (barycentric coodinates)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>warn</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, raises a warning if the algorithm doesn’t convergence.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>(dim,) array-like</em>) – Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-barycenter">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Benamou, J. D., Carlier, G., Cuturi, M., Nenna, L., &amp; Peyré, G. (2015).
Iterative Bregman projections for regularized transportation problems.
SIAM Journal on Scientific Computing, 37(2), A1111-A1138.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.barycenter_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">barycenter_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/unbalanced.html#barycenter_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.barycenter_unbalanced" title="Link to this definition"></a></dt>
<dd><p>Compute the entropic unbalanced wasserstein barycenter of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<blockquote>
<div><p>The function solves the following optimization problem with <span class="math notranslate nohighlight">\(\mathbf{a}\)</span></p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = \mathop{\arg \min}_\mathbf{a} \quad \sum_i W_{u_{reg}}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_{u_{reg}}(\cdot,\cdot)\)</span> is the unbalanced entropic regularized Wasserstein distance (see <a class="reference internal" href="gen_modules/ot.unbalanced.html#id48" title="ot.unbalanced.sinkhorn_unbalanced"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced()</span></code></a>)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
<li><p>reg and <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> are respectively the regularization term and the cost matrix for OT</p></li>
<li><p>reg_mis the marginal relaxation hyperparameter</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-barycenter-unbalanced"><span class="std std-ref">[10]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array-like</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – <cite>n_hists</cite> training distributions <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> of dimension <cite>dim</cite></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>dim</em><em>, </em><em>dim</em><em>)</em>) – ground metric matrix for OT.</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Marginal relaxation term &gt; 0</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>n_hists</em><em>,</em><em>) </em><em>optional</em>) – Weight of each distribution (barycentric coodinates)
If None, uniform weights are used.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>(dim,) array-like</em>) – Unbalanced Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-barycenter-unbalanced">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Benamou, J. D., Carlier, G., Cuturi, M., Nenna, L., &amp; Peyré, G.
(2015). Iterative Bregman projections for regularized transportation
problems. SIAM Journal on Scientific Computing, 37(2), A1111-A1138.</p>
</aside>
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprin
arXiv:1607.05816.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.binary_search_circle">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">binary_search_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#binary_search_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.binary_search_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the Wasserstein distance on the circle using the Binary search algorithm proposed in [44].
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<div class="math notranslate nohighlight">
\[W_p^p(u,v) = \inf_{\theta\in\mathbb{R}}\int_0^1 |F_u^{-1}(q)  - (F_v-\theta)^{-1}(q)|^p\ \mathrm{d}q\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F_u\)</span> and <span class="math notranslate nohighlight">\(F_v\)</span> are respectively the cdfs of <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span></p></li>
</ul>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the target domain (coordinates on [0,1[)</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Power p used for computing the Wasserstein distance</p></li>
<li><p><strong>Lm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Lower bound dC</p></li>
<li><p><strong>Lp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Upper bound dC</p></li>
<li><p><strong>tm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Lower bound theta</p></li>
<li><p><strong>tp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Upper bound theta</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stopping condition</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, sort the values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, returns also the optimal theta</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float</em>) – Cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – log dictionary returned only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_search_circle</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.1])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<p>Delon, Julie, Julien Salomon, and Andrei Sobolevski. “Fast transport optimization for Monge costs on the circle.” SIAM Journal on Applied Mathematics 70.7 (2010): 2239-2258.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.dist">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.dist" title="Link to this definition"></a></dt>
<dd><p>Compute distance between samples in <span class="math notranslate nohighlight">\(\mathbf{x_1}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x_2}\)</span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n1</em><em>,</em><em>d</em><em>)</em>) – matrix with <cite>n1</cite> samples of size <cite>d</cite></p></li>
<li><p><strong>x2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n2</em><em>,</em><em>d</em><em>)</em><em>, </em><em>optional</em>) – matrix with <cite>n2</cite> samples of size <cite>d</cite> (if None then <span class="math notranslate nohighlight">\(\mathbf{x_2} = \mathbf{x_1}\)</span>)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em> | </em><em>callable</em><em>, </em><em>optional</em>) – ‘sqeuclidean’ or ‘euclidean’ on all backends. On numpy the function also
accepts  from the scipy.spatial.distance.cdist function : ‘braycurtis’,
‘canberra’, ‘chebyshev’, ‘cityblock’, ‘correlation’, ‘cosine’, ‘dice’,
‘euclidean’, ‘hamming’, ‘jaccard’, ‘kulczynski1’, ‘mahalanobis’,
‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’,
‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘wminkowski’, ‘yule’.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – p-norm for the Minkowski and the Weighted Minkowski metrics. Default value is 2.</p></li>
<li><p><strong>w</strong> (<em>array-like</em><em>, </em><em>rank 1</em>) – Weights for the weighted metrics.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> – distance matrix computed with given metric</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (<cite>n1</cite>, <cite>n2</cite>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.emd">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">emd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp.html#emd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.emd" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> matrix in numpy needs to be a C-order
numpy.array in float64 format. It will be converted if not in this
format</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data type
of the provided input with the following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="#references-emd"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Loss matrix (c-order array in numpy with type float64)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost and dual variables.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (ns, nt)</em>) – Optimal transportation matrix for the given
parameters</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – If input log is true, a dictionary containing the
cost and dual variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="go">array([[0.5, 0. ],</span>
<span class="go">       [0. , 0.5]])</span>
</pre></div>
</div>
<p class="rubric" id="references-emd">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W. (2011,
December).  Displacement interpolation using Lagrangian mass transport.
In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p. 158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.emd2">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">emd2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp.html#emd2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.emd2" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan and
transportation loss to the data type of the provided input with the
following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="#references-emd2"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Loss matrix (for numpy c-order array with type float64)</p></li>
<li><p><strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Nb of processes used for multiple emd computation (deprecated)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing dual
variables. Otherwise returns only the optimal transportation cost.</p></li>
<li><p><strong>return_matrix</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns the optimal transportation matrix in the log.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float, array-like</em>) – Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is true, a dictionary containing dual
variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric" id="references-emd2">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.emd2_1d">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">emd2_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#emd2_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.emd2_1d" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p>x_a and x_b are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>When ‘minkowski’ is used as a metric, <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id76"><span class="problematic" id="id7">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>(</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>(</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only strings listed in <a class="reference internal" href="#ot.dist" title="ot.dist"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.dist()</span></code></a> are accepted.
Due to implementation details, this function runs faster when
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite> metrics
are used.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, returns math:<cite>gamma</cite> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy’s <cite>coo_matrix</cite>
format. Only used if log is set to True. Due to implementation details,
this function runs faster when dense is set to False.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the transportation matrix.
Otherwise returns only the loss.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float</em>) – Cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is True, a dictionary containing the Optimal transportation
matrix for the given parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd2_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#id17" title="ot.lp.emd2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.emd_1d" title="ot.lp.emd_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd_1d</span></code></a></dt><dd><p>EMD for 1d distributions (returns the transportation matrix instead of the cost)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.emd_1d">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">emd_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#emd_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.emd_1d" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p>x_a and x_b are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>When ‘minkowski’ is used as a metric, <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id77"><span class="problematic" id="id9">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>(</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>(</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only strings listed in <a class="reference internal" href="#ot.dist" title="ot.dist"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.dist()</span></code></a> are accepted.
Due to implementation details, this function runs faster when
<cite>‘sqeuclidean’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite> metrics are used.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, returns math:<cite>gamma</cite> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy’s <cite>coo_matrix</cite>
format. Due to implementation details, this function runs faster when
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite> metrics
are used.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) ndarray</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is True, a dictionary containing the cost</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.lp.html#ot.lp.emd2_1d" title="ot.lp.emd2_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2_1d</span></code></a></dt><dd><p>EMD for 1d distributions (returns cost instead of the transportation matrix)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.factored_optimal_transport">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">factored_optimal_transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/factored.html#factored_optimal_transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.factored_optimal_transport" title="Link to this definition"></a></dt>
<dd><p>Solves factored OT problem and return OT plans and intermediate distribution</p>
<p>This function solve the following OT problem <a href="#id78"><span class="problematic" id="id11">[40]_</span></a></p>
<div class="math notranslate nohighlight">
\[\mathop{\arg \min}_\mu \quad  W_2^2(\mu_a,\mu)+ W_2^2(\mu,\mu_b)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mu_a\)</span> and <span class="math notranslate nohighlight">\(\mu_b\)</span>  are empirical distributions.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mu\)</span> is an empirical distribution with r samples</p></li>
</ul>
<p>And returns the two OT plans between</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<p>Uses the conditional gradient algorithm to solve the problem proposed in
<a class="reference internal" href="#references-weak"><span class="std std-ref">[39]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xa</strong> (<em>(</em><em>ns</em><em>,</em><em>d</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Source samples</p></li>
<li><p><strong>Xb</strong> (<em>(</em><em>nt</em><em>,</em><em>d</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Target samples</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Target histogram (uniform weight if empty list))</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on the relative variation (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Ga</strong> (<em>array-like, shape (ns, r)</em>) – Optimal transportation matrix between source and the intermediate
distribution</p></li>
<li><p><strong>Gb</strong> (<em>array-like, shape (r, nt)</em>) – Optimal transportation matrix between the intermediate and target
distribution</p></li>
<li><p><strong>X</strong> (<em>array-like, shape (r, d)</em>) – Support of the intermediate distribution</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – If input log is true, a dictionary containing the cost and dual
variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-factored">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></span>
<p>Forrow, A., Hütter, J. C., Nitzan, M., Rigollet, P., Schiebinger,
G., &amp; Weed, J. (2019, April). Statistical optimal transport via factored
couplings. In The 22nd International Conference on Artificial
Intelligence and Statistics (pp. 2454-2465). PMLR.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.fused_gromov_wasserstein">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">fused_gromov_wasserstein</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'square_loss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">armijo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_abs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/gromov/_gw.html#fused_gromov_wasserstein"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.fused_gromov_wasserstein" title="Link to this definition"></a></dt>
<dd><p>Returns the Fused Gromov-Wasserstein transport between <span class="math notranslate nohighlight">\((\mathbf{C_1}, \mathbf{Y_1}, \mathbf{p})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{C_2}, \mathbf{Y_2}, \mathbf{q})\)</span>
with pairwise distance matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> between node feature matrices <span class="math notranslate nohighlight">\(\mathbf{Y_1}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Y_2}\)</span> (see <a class="reference internal" href="gen_modules/ot.gromov.html#references-fused-gromov-wasserstein"><span class="std std-ref">[24]</span></a>).</p>
<p>The function solves the following optimization problem using Conditional Gradient:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{T}^* \in\mathop{\arg\min}_\mathbf{T} \quad (1 - \alpha) \langle \mathbf{T}, \mathbf{M} \rangle_F +
\alpha \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l}\\s.t. \ \mathbf{T} \mathbf{1} &amp;= \mathbf{p}\\     \mathbf{T}^T \mathbf{1} &amp;= \mathbf{q}\\     \mathbf{T} &amp;\geq 0\end{aligned}\end{align} \]</div>
<p>Where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span>: metric cost matrix between features across domains</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{C_1}\)</span>: Metric cost matrix in the source space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{C_2}\)</span>: Metric cost matrix in the target space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{p}\)</span>: distribution in the source space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{q}\)</span>: distribution in the target space</p></li>
<li><p><cite>L</cite>: loss function to account for the misfit between the similarity and feature matrices</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span>: trade-off parameter</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All computations in the conjugate gradient solver are done with
numpy to limit memory overhead.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data
type of the provided input <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>. Casting to an integer
tensor might result in a loss of precision. If this behaviour is
unwanted, please make sure to provide a floating point input.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>, </em><em>nt</em><em>)</em>) – Metric cost matrix between features across domains</p></li>
<li><p><strong>C1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>, </em><em>ns</em><em>)</em>) – Metric cost matrix representative of the structure in the source space</p></li>
<li><p><strong>C2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>, </em><em>nt</em><em>)</em>) – Metric cost matrix representative of the structure in the target space</p></li>
<li><p><strong>p</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Distribution in the source space.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>q</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Distribution in the target space.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>loss_fun</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Loss function used for the solver</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Either C1 and C2 are to be assumed symmetric or not.
If let to its default None value, a symmetry test will be conducted.
Else if set to True (resp. False), C1 and C2 will be assumed symmetric (resp. asymmetric).</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Trade-off parameter (0 &lt; alpha &lt; 1)</p></li>
<li><p><strong>armijo</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the step of the line-search is found via an armijo research. Else closed form is used.
If there are convergence issues use False.</p></li>
<li><p><strong>G0</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em><em>, </em><em>optional</em>) – If None the initial transport plan of the solver is pq^T.
Otherwise G0 must satisfy marginal constraints and will be used as initial transport of the solver.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>tol_rel</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative error (&gt;0)</p></li>
<li><p><strong>tol_abs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on absolute error (&gt;0)</p></li>
<li><p><strong>**kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><em>dict</em></a>) – parameters can be directly passed to the ot.optim.cg solver</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>T</strong> (array-like, shape (<cite>ns</cite>, <cite>nt</cite>)) – Optimal transportation matrix for the given parameters.</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – Log dictionary return only if log==True in parameters.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-fused-gromov-wasserstein">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></span>
<p>Vayer Titouan, Chapel Laetitia, Flamary Rémi, Tavenard Romain
and Courty Nicolas “Optimal Transport for structured data with
application on graphs”, International Conference on Machine Learning
(ICML). 2019.</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>47<span class="fn-bracket">]</span></span>
<p>Chowdhury, S., &amp; Mémoli, F. (2019). The gromov–wasserstein
distance between networks and stable network invariants.
Information and Inference: A Journal of the IMA, 8(4), 757-787.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.fused_gromov_wasserstein2">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">fused_gromov_wasserstein2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'square_loss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">armijo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_abs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/gromov/_gw.html#fused_gromov_wasserstein2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.fused_gromov_wasserstein2" title="Link to this definition"></a></dt>
<dd><p>Returns the Fused Gromov-Wasserstein distance between <span class="math notranslate nohighlight">\((\mathbf{C_1}, \mathbf{Y_1}, \mathbf{p})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{C_2}, \mathbf{Y_2}, \mathbf{q})\)</span>
with pairwise distance matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> between node feature matrices <span class="math notranslate nohighlight">\(\mathbf{Y_1}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Y_2}\)</span> (see <a class="reference internal" href="gen_modules/ot.gromov.html#references-fused-gromov-wasserstein"><span class="std std-ref">[24]</span></a>).</p>
<p>The function solves the following optimization problem using Conditional Gradient:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{FGW} = \mathop{\min}_\mathbf{T} \quad (1 - \alpha) \langle \mathbf{T}, \mathbf{M} \rangle_F +
\alpha \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l}\\s.t. \ \mathbf{T} \mathbf{1} &amp;= \mathbf{p}\\     \mathbf{T}^T \mathbf{1} &amp;= \mathbf{q}\\     \mathbf{T} &amp;\geq 0\end{aligned}\end{align} \]</div>
<p>Where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span>: metric cost matrix between features across domains</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{C_1}\)</span>: Metric cost matrix in the source space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{C_2}\)</span>: Metric cost matrix in the target space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{p}\)</span>: distribution in the source space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{q}\)</span>: distribution in the target space</p></li>
<li><p><cite>L</cite>: loss function to account for the misfit between the similarity and feature matrices</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span>: trade-off parameter</p></li>
</ul>
<p>Note that when using backends, this loss function is differentiable wrt the
matrices (C1, C2, M) and weights (p, q) for quadratic loss using the gradients from <a href="#id79"><span class="problematic" id="id15">[38]_</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All computations in the conjugate gradient solver are done with
numpy to limit memory overhead.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data
type of the provided input <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>. Casting to an integer
tensor might result in a loss of precision. If this behaviour is
unwanted, please make sure to provide a floating point input.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>, </em><em>nt</em><em>)</em>) – Metric cost matrix between features across domains</p></li>
<li><p><strong>C1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>, </em><em>ns</em><em>)</em>) – Metric cost matrix representative of the structure in the source space.</p></li>
<li><p><strong>C2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>, </em><em>nt</em><em>)</em>) – Metric cost matrix representative of the structure in the target space.</p></li>
<li><p><strong>p</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Distribution in the source space.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>q</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Distribution in the target space.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>loss_fun</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Loss function used for the solver.</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Either C1 and C2 are to be assumed symmetric or not.
If let to its default None value, a symmetry test will be conducted.
Else if set to True (resp. False), C1 and C2 will be assumed symmetric (resp. asymmetric).</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Trade-off parameter (0 &lt; alpha &lt; 1)</p></li>
<li><p><strong>armijo</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the step of the line-search is found via an armijo research.
Else closed form is used. If there are convergence issues use False.</p></li>
<li><p><strong>G0</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em><em>, </em><em>optional</em>) – If None the initial transport plan of the solver is pq^T.
Otherwise G0 must satisfy marginal constraints and will be used as initial transport of the solver.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Record log if True.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>tol_rel</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative error (&gt;0)</p></li>
<li><p><strong>tol_abs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on absolute error (&gt;0)</p></li>
<li><p><strong>**kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><em>dict</em></a>) – Parameters can be directly passed to the ot.optim.cg solver.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fgw-distance</strong> (<em>float</em>) – Fused Gromov-Wasserstein distance for the given parameters.</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – Log dictionary return only if log==True in parameters.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-fused-gromov-wasserstein2">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></span>
<p>Vayer Titouan, Chapel Laetitia, Flamary Rémi, Tavenard Romain
and Courty Nicolas
“Optimal Transport for structured data with application on graphs”
International Conference on Machine Learning (ICML). 2019.</p>
</aside>
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>38<span class="fn-bracket">]</span></span>
<p>C. Vincent-Cuaz, T. Vayer, R. Flamary, M. Corneli, N. Courty, Online
Graph Dictionary Learning, International Conference on Machine Learning
(ICML), 2021.</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>47<span class="fn-bracket">]</span></span>
<p>Chowdhury, S., &amp; Mémoli, F. (2019). The gromov–wasserstein
distance between networks and stable network invariants.
Information and Inference: A Journal of the IMA, 8(4), 757-787.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.gromov_barycenters">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">gromov_barycenters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'square_loss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">armijo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_criterion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'barycenter'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstartT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_C</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/gromov/_gw.html#gromov_barycenters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gromov_barycenters" title="Link to this definition"></a></dt>
<dd><p>Returns the Gromov-Wasserstein barycenters of <cite>S</cite> measured similarity matrices <span class="math notranslate nohighlight">\((\mathbf{C}_s)_{1 \leq s \leq S}\)</span></p>
<p>The function solves the following optimization problem with block coordinate descent:</p>
<div class="math notranslate nohighlight">
\[\mathbf{C}^* = \mathop{\arg \min}_{\mathbf{C}\in \mathbb{R}^{N \times N}} \quad \sum_s \lambda_s \mathrm{GW}(\mathbf{C}, \mathbf{C}_s, \mathbf{p}, \mathbf{p}_s)\]</div>
<p>Where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{C}_s\)</span>: metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{p}_s\)</span>: distribution</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – Size of the targeted barycenter</p></li>
<li><p><strong>Cs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em> of </em><em>S array-like</em><em> of </em><em>shape</em><em> (</em><em>ns</em><em>, </em><em>ns</em><em>)</em>) – Metric cost matrices</p></li>
<li><p><strong>ps</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em> of </em><em>S array-like</em><em> of </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Sample weights in the <cite>S</cite> spaces.
If let to its default value None, uniform distributions are taken.</p></li>
<li><p><strong>p</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>N</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Weights in the targeted barycenter.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>lambdas</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – List of the <cite>S</cite> spaces’ weights.
If let to its default value None, uniform weights are taken.</p></li>
<li><p><strong>loss_fun</strong> (<em>callable</em><em>, </em><em>optional</em>) – tensor-matrix multiplication function based on specific loss function</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional.</em>) – Either structures are to be assumed symmetric or not. Default value is True.
Else if set to True (resp. False), C1 and C2 will be assumed symmetric (resp. asymmetric).</p></li>
<li><p><strong>armijo</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the step of the line-search is found via an armijo research.
Else closed form is used. If there are convergence issues use False.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative error (&gt;0)</p></li>
<li><p><strong>stop_criterion</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional. Default is 'barycenter'.</em>) – Stop criterion taking values in [‘barycenter’, ‘loss’]. If set to ‘barycenter’
uses absolute norm variations of estimated barycenters. Else if set to ‘loss’
uses the relative variations of the loss.</p></li>
<li><p><strong>warmstartT</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Either to perform warmstart of transport plans in the successive
fused gromov-wasserstein transport problems.s</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Record log if True.</p></li>
<li><p><strong>init_C</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em> | </em><em>array-like</em><em>, </em><em>shape</em><em>(</em><em>N</em><em>,</em><em>N</em><em>)</em>) – Random initial value for the <span class="math notranslate nohighlight">\(\mathbf{C}\)</span> matrix provided by user.</p></li>
<li><p><strong>random_state</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>RandomState instance</em><em>, </em><em>optional</em>) – Fix the seed for reproducibility</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>C</strong> (array-like, shape (<cite>N</cite>, <cite>N</cite>)) – Similarity matrix in the barycenter space (permutated arbitrarily)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – Only returned when log=True. It contains the keys:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\mathbf{T}\)</span>: list of (<cite>N</cite>, <cite>ns</cite>) transport matrices</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{p}\)</span>: (<cite>N</cite>,) barycenter weights</p></li>
<li><p>values used in convergence evaluation.</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<p>Gabriel Peyré, Marco Cuturi, and Justin Solomon,
“Gromov-Wasserstein averaging of kernel and distance matrices.”
International Conference on Machine Learning (ICML). 2016.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.gromov_wasserstein">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">gromov_wasserstein</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'square_loss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">armijo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_abs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/gromov/_gw.html#gromov_wasserstein"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gromov_wasserstein" title="Link to this definition"></a></dt>
<dd><p>Returns the Gromov-Wasserstein transport between <span class="math notranslate nohighlight">\((\mathbf{C_1}, \mathbf{p})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{C_2}, \mathbf{q})\)</span>.</p>
<p>The function solves the following optimization problem using Conditional Gradient:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{T}^* \in \mathop{\arg \min}_\mathbf{T} \quad \sum_{i,j,k,l}
L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l}\\s.t. \ \mathbf{\gamma} \mathbf{1} &amp;= \mathbf{p}\\     \mathbf{\gamma}^T \mathbf{1} &amp;= \mathbf{q}\\     \mathbf{\gamma} &amp;\geq 0\end{aligned}\end{align} \]</div>
<p>Where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{C_1}\)</span>: Metric cost matrix in the source space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{C_2}\)</span>: Metric cost matrix in the target space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{p}\)</span>: distribution in the source space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{q}\)</span>: distribution in the target space</p></li>
<li><p><cite>L</cite>: loss function to account for the misfit between the similarity matrices</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All computations in the conjugate gradient solver are done with
numpy to limit memory overhead.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data
type of the provided input <span class="math notranslate nohighlight">\(\mathbf{C}_1\)</span>. Casting to an integer
tensor might result in a loss of precision. If this behaviour is
unwanted, please make sure to provide a floating point input.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>, </em><em>ns</em><em>)</em>) – Metric cost matrix in the source space</p></li>
<li><p><strong>C2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>, </em><em>nt</em><em>)</em>) – Metric cost matrix in the target space</p></li>
<li><p><strong>p</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Distribution in the source space.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>q</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Distribution in the target space.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>loss_fun</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – loss function used for the solver either ‘square_loss’ or ‘kl_loss’</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Either C1 and C2 are to be assumed symmetric or not.
If let to its default None value, a symmetry test will be conducted.
Else if set to True (resp. False), C1 and C2 will be assumed symmetric (resp. asymmetric).</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>armijo</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the step of the line-search is found via an armijo research. Else closed form is used.
If there are convergence issues use False.</p></li>
<li><p><strong>G0</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em><em>, </em><em>optional</em>) – If None the initial transport plan of the solver is pq^T.
Otherwise G0 must satisfy marginal constraints and will be used as initial transport of the solver.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>tol_rel</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative error (&gt;0)</p></li>
<li><p><strong>tol_abs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on absolute error (&gt;0)</p></li>
<li><p><strong>**kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><em>dict</em></a>) – parameters can be directly passed to the ot.optim.cg solver</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>T</strong> (array-like, shape (<cite>ns</cite>, <cite>nt</cite>)) –</p>
<p>Coupling between the two spaces that minimizes:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(\sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l}\)</span></p>
</div></blockquote>
</li>
<li><p><strong>log</strong> (<em>dict</em>) – Convergence information and loss.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<p>Gabriel Peyré, Marco Cuturi, and Justin Solomon,
“Gromov-Wasserstein averaging of kernel and distance matrices.”
International Conference on Machine Learning (ICML). 2016.</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></span>
<p>Mémoli, Facundo. Gromov–Wasserstein distances and the
metric approach to object matching. Foundations of computational
mathematics 11.4 (2011): 417-487.</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>47<span class="fn-bracket">]</span></span>
<p>Chowdhury, S., &amp; Mémoli, F. (2019). The gromov–wasserstein
distance between networks and stable network invariants.
Information and Inference: A Journal of the IMA, 8(4), 757-787.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.gromov_wasserstein2">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">gromov_wasserstein2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'square_loss'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">armijo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_abs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/gromov/_gw.html#gromov_wasserstein2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gromov_wasserstein2" title="Link to this definition"></a></dt>
<dd><p>Returns the Gromov-Wasserstein loss <span class="math notranslate nohighlight">\(\mathbf{GW}\)</span> between <span class="math notranslate nohighlight">\((\mathbf{C_1}, \mathbf{p})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{C_2}, \mathbf{q})\)</span>.
To recover the Gromov-Wasserstein distance as defined in [13] compute <span class="math notranslate nohighlight">\(d_{GW} = \frac{1}{2} \sqrt{\mathbf{GW}}\)</span>.</p>
<p>The function solves the following optimization problem using Conditional Gradient:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{GW} = \min_\mathbf{T} \quad \sum_{i,j,k,l}
L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l}\\s.t. \ \mathbf{\gamma} \mathbf{1} &amp;= \mathbf{p}\\     \mathbf{\gamma}^T \mathbf{1} &amp;= \mathbf{q}\\     \mathbf{\gamma} &amp;\geq 0\end{aligned}\end{align} \]</div>
<p>Where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{C_1}\)</span>: Metric cost matrix in the source space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{C_2}\)</span>: Metric cost matrix in the target space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{p}\)</span>: distribution in the source space</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{q}\)</span>: distribution in the target space</p></li>
<li><p><cite>L</cite>: loss function to account for the misfit between the similarity
matrices</p></li>
</ul>
<p>Note that when using backends, this loss function is differentiable wrt the
matrices (C1, C2) and weights (p, q) for quadratic loss using the gradients from <a href="#id80"><span class="problematic" id="id23">[38]_</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All computations in the conjugate gradient solver are done with
numpy to limit memory overhead.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data
type of the provided input <span class="math notranslate nohighlight">\(\mathbf{C}_1\)</span>. Casting to an integer
tensor might result in a loss of precision. If this behaviour is
unwanted, please make sure to provide a floating point input.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>, </em><em>ns</em><em>)</em>) – Metric cost matrix in the source space</p></li>
<li><p><strong>C2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>, </em><em>nt</em><em>)</em>) – Metric cost matrix in the target space</p></li>
<li><p><strong>p</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Distribution in the source space.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>q</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Distribution in the target space.
If let to its default value None, uniform distribution is taken.</p></li>
<li><p><strong>loss_fun</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – loss function used for the solver either ‘square_loss’ or ‘kl_loss’</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Either C1 and C2 are to be assumed symmetric or not.
If let to its default None value, a symmetry test will be conducted.
Else if set to True (resp. False), C1 and C2 will be assumed symmetric (resp. asymmetric).</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>armijo</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the step of the line-search is found via an armijo research. Else closed form is used.
If there are convergence issues use False.</p></li>
<li><p><strong>G0</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em><em>, </em><em>optional</em>) – If None the initial transport plan of the solver is pq^T.
Otherwise G0 must satisfy marginal constraints and will be used as initial transport of the solver.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>tol_rel</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative error (&gt;0)</p></li>
<li><p><strong>tol_abs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on absolute error (&gt;0)</p></li>
<li><p><strong>**kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><em>dict</em></a>) – parameters can be directly passed to the ot.optim.cg solver</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gw_dist</strong> (<em>float</em>) – Gromov-Wasserstein distance</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – convergence information and Coupling matrix</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<p>Gabriel Peyré, Marco Cuturi, and Justin Solomon,
“Gromov-Wasserstein averaging of kernel and distance matrices.”
International Conference on Machine Learning (ICML). 2016.</p>
</aside>
<aside class="footnote brackets" id="id25" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></span>
<p>Mémoli, Facundo. Gromov–Wasserstein distances and the
metric approach to object matching. Foundations of computational
mathematics 11.4 (2011): 417-487.</p>
</aside>
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>38<span class="fn-bracket">]</span></span>
<p>C. Vincent-Cuaz, T. Vayer, R. Flamary, M. Corneli, N. Courty, Online
Graph Dictionary Learning, International Conference on Machine Learning
(ICML), 2021.</p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>47<span class="fn-bracket">]</span></span>
<p>Chowdhury, S., &amp; Mémoli, F. (2019). The gromov–wasserstein
distance between networks and stable network invariants.
Information and Inference: A Journal of the IMA, 8(4), 757-787.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lowrank_sinkhorn">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">lowrank_sinkhorn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lowrank.html#lowrank_sinkhorn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lowrank_sinkhorn" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem under low-nonnegative rank constraints.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[\mathop{\inf_{(Q,R,g) \in \mathcal{C(a,b,r)}}} \langle C, Q\mathrm{diag}(1/g)R^T \rangle -
    \mathrm{reg} \cdot H((Q,R,g))\]</div>
<p>where :
- <span class="math notranslate nohighlight">\(C\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix
- <span class="math notranslate nohighlight">\(H((Q,R,g))\)</span> is the values of the three respective entropies evaluated for each term.
- :math: <cite>Q</cite> and <cite>R</cite> are the low-rank matrix decomposition of the OT plan
- :math: <cite>g</cite> is the weight vector for the low-rank decomposition of the OT plan
- <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (histograms, both sum to 1)
- :math: <cite>r</cite> is the rank of the OT plan
- :math: <cite>mathcal{C(a,b,r)}</cite> are the low-rank couplings of the OT problem</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_s</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>, </em><em>dim</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>X_t</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>, </em><em>dim</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term &gt;0</p></li>
<li><p><strong>rank</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional. Default is None.</em><em> (</em><em>&gt;0</em><em>)</em>) – Nonnegative rank of the OT plan. If None, min(ns, nt) is considered.</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional. Default is None.</em><em> (</em><em>&gt;0 and &lt;1/r</em><em>)</em>) – Lower bound for the weight vector g. If None, 1e-10 is considered</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>warn</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, raises a warning if the algorithm doesn’t convergence.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>lazy_plan</strong> (<em>LazyTensor()</em>) – OT plan in a LazyTensor object of shape (shape_plan)
See <a class="reference internal" href="gen_modules/ot.utils.html#id15" title="ot.utils.LazyTensor"><code class="xref any py py-class docutils literal notranslate"><span class="pre">LazyTensor</span></code></a> for more information.</p></li>
<li><p><strong>value</strong> (<em>float</em>) – Optimal value of the optimization problem</p></li>
<li><p><strong>value_linear</strong> (<em>float</em>) – Linear OT loss with the optimal OT</p></li>
<li><p><strong>Q</strong> (<em>array-like, shape (n_samples_a, r)</em>) – First low-rank matrix decomposition of the OT plan</p></li>
<li><p><strong>R</strong> (<em>array-like, shape (n_samples_b, r)</em>) – Second low-rank matrix decomposition of the OT plan</p></li>
<li><p><strong>g</strong> (<em>array-like, shape (r, )</em>) – Weight vector for the low-rank decomposition of the OT plan</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id28" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>65<span class="fn-bracket">]</span></span>
<p>Scetbon, M., Cuturi, M., &amp; Peyré, G (2021).
“Low-Rank Sinkhorn Factorization” arXiv preprint arXiv:2103.04737.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.max_sliced_wasserstein_distance">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">max_sliced_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/sliced.html#max_sliced_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.max_sliced_wasserstein_distance" title="Link to this definition"></a></dt>
<dd><p>Computes a Monte-Carlo approximation of the max p-Sliced Wasserstein distance</p>
<div class="math notranslate nohighlight">
\[\mathcal{Max-SWD}_p(\mu, \nu) = \underset{\theta _in
\mathcal{U}(\mathbb{S}^{d-1})}{\max} [\mathcal{W}_p^p(\theta_\#
\mu, \theta_\# \nu)]^{\frac{1}{p}}\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\theta_\# \mu\)</span> stands for the pushforwards of the projection <span class="math notranslate nohighlight">\(\mathbb{R}^d \ni X \mapsto \langle \theta, X \rangle\)</span></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_s</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>, </em><em>dim</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>X_t</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>, </em><em>dim</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>a</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>n_projections</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Number of projections used for the Monte-Carlo approximation</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional =</em>) – Power p used for computing the sliced Wasserstein</p></li>
<li><p><strong>projections</strong> (<em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_projections</em><em>)</em><em>, </em><em>optional</em>) – Projection matrix (n_projections and seed are not used in this case)</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>RandomState</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Seed used for random number generator</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, sliced_wasserstein_distance returns the projections used and their associated EMD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cost</strong> (<em>float</em>) – Sliced Wasserstein Cost</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_samples_a</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">n_samples_a</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliced_wasserstein_distance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>35<span class="fn-bracket">]</span></span>
<p>Deshpande, I., Hu, Y. T., Sun, R., Pyrros, A., Siddiqui, N., Koyejo, S., … &amp; Schwing, A. G. (2019). Max-sliced wasserstein distance and its use for gans. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 10648-10656).</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.semidiscrete_wasserstein2_unif_circle">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">semidiscrete_wasserstein2_unif_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#semidiscrete_wasserstein2_unif_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.semidiscrete_wasserstein2_unif_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the closed-form for the 2-Wasserstein distance between samples and a uniform distribution on <span class="math notranslate nohighlight">\(S^1\)</span>
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<div class="math notranslate nohighlight">
\[W_2^2(\mu_n, \nu) = \sum_{i=1}^n \alpha_i x_i^2 - \left(\sum_{i=1}^n \alpha_i x_i\right)^2 + \sum_{i=1}^n \alpha_i x_i \left(1-\alpha_i-2\sum_{k=1}^{i-1}\alpha_k\right) + \frac{1}{12}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\nu=\mathrm{Unif}(S^1)\)</span> and <span class="math notranslate nohighlight">\(\mu_n  = \sum_{i=1}^n \alpha_i \delta_{x_i}\)</span></p></li>
</ul>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi},\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – Samples</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Cost associated to the optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">semidiscrete_wasserstein2_unif_circle</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="go">array([0.02111111])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></span>
<p>Bonet, C., Berg, P., Courty, N., Septier, F., Drumetz, L., &amp; Pham, M. T. (2023). Spherical sliced-wasserstein. International Conference on Learning Representations.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/bregman/_sinkhorn.html#sinkhorn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem and return the OT matrix</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg}\cdot\Omega(\gamma)\\s.t. \ \gamma \mathbf{1} &amp;= \mathbf{a}\\     \gamma^T \mathbf{1} &amp;= \mathbf{b}\\     \gamma &amp;\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization term
<span class="math notranslate nohighlight">\(\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target
weights (histograms, both sum to 1)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends.</p>
</div>
<p>The algorithm used for solving the problem is the Sinkhorn-Knopp matrix
scaling algorithm as proposed in <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[2]</span></a></p>
<p><strong>Choosing a Sinkhorn solver</strong></p>
<p>By default and when using a regularization parameter that is not too small
the default sinkhorn solver should be enough. If you need to use a small
regularization to get sharper OT matrices, you should use the
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_stabilized" title="ot.bregman.sinkhorn_stabilized"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_stabilized()</span></code></a> solver that will avoid numerical
errors. This last solver can be very slow in practice and might not even
converge to a reasonable OT matrix in a finite time. This is why
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_epsilon_scaling" title="ot.bregman.sinkhorn_epsilon_scaling"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_epsilon_scaling()</span></code></a> that relies on iterating the value
of the regularization (and using warm start) sometimes leads to better
solutions. Note that the greedy version of the sinkhorn
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.greenkhorn" title="ot.bregman.greenkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.greenkhorn()</span></code></a> can also lead to a speedup and the screening
version of the sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.screenkhorn" title="ot.bregman.screenkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.screenkhorn()</span></code></a> aim at providing  a
fast approximation of the Sinkhorn problem. For use of GPU and gradient
computation with small number of iterations we strongly recommend the
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_log" title="ot.bregman.sinkhorn_log"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_log()</span></code></a> solver that will no need to check for
numerical problems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) – samples in the target domain, compute sinkhorn with multiple targets
and fixed <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is a matrix
(return OT loss + dual variables in log)</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Regularization term &gt;0</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’,’sinkhorn_log’,
‘greenkhorn’, ‘sinkhorn_stabilized’ or ‘sinkhorn_epsilon_scaling’, see
those function for specific parameters</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>warn</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, raises a warning if the algorithm doesn’t convergence.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the u,v sinkhorn scaling vectors)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (dim_a, dim_b)</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">sinkhorn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0.36552929, 0.13447071],</span>
<span class="go">       [0.13447071, 0.36552929]])</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id31" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation
of Optimal Transport, Advances in Neural Information Processing
Systems (NIPS) 26, 2013</p>
</aside>
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms
for Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</aside>
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems.
arXiv preprint arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id34" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></span>
<p>Feydy, J., Séjourné, T., Vialard, F. X., Amari, S. I., Trouvé,
A., &amp; Peyré, G. (2019, April). Interpolating between optimal transport
and MMD using Sinkhorn divergences. In The 22nd International Conference
on Artificial Intelligence and Statistics (pp. 2681-2690). PMLR.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_knopp" title="ot.bregman.sinkhorn_knopp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_knopp</span></code></a></dt><dd><p>Classic Sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[2]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_stabilized" title="ot.bregman.sinkhorn_stabilized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_stabilized</span></code></a></dt><dd><p>Stabilized sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[9]</span></a> <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[10]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_epsilon_scaling" title="ot.bregman.sinkhorn_epsilon_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_epsilon_scaling</span></code></a></dt><dd><p>Sinkhorn with epsilon scaling <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[9]</span></a> <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn"><span class="std std-ref">[10]</span></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn2">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/bregman/_sinkhorn.html#sinkhorn2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn2" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem and return the loss</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg}\cdot\Omega(\gamma)\\s.t. \ \gamma \mathbf{1} &amp;= \mathbf{a}\\     \gamma^T \mathbf{1} &amp;= \mathbf{b}\\     \gamma &amp;\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization term
<span class="math notranslate nohighlight">\(\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target
weights (histograms, both sum to 1)</p></li>
</ul>
<p>and returns <span class="math notranslate nohighlight">\(\langle \gamma^*, \mathbf{M} \rangle_F\)</span> (without
the entropic contribution).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends.</p>
</div>
<p>The algorithm used for solving the problem is the Sinkhorn-Knopp matrix
scaling algorithm as proposed in <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[2]</span></a></p>
<p><strong>Choosing a Sinkhorn solver</strong></p>
<p>By default and when using a regularization parameter that is not too small
the default sinkhorn solver should be enough. If you need to use a small
regularization to get sharper OT matrices, you should use the
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_log" title="ot.bregman.sinkhorn_log"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_log()</span></code></a> solver that will avoid numerical
errors. This last solver can be very slow in practice and might not even
converge to a reasonable OT matrix in a finite time. This is why
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_epsilon_scaling" title="ot.bregman.sinkhorn_epsilon_scaling"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_epsilon_scaling()</span></code></a> that relies on iterating the value
of the regularization (and using warm start) sometimes leads to better
solutions. Note that the greedy version of the sinkhorn
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.greenkhorn" title="ot.bregman.greenkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.greenkhorn()</span></code></a> can also lead to a speedup and the screening
version of the sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.screenkhorn" title="ot.bregman.screenkhorn"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.screenkhorn()</span></code></a> aim a providing  a
fast approximation of the Sinkhorn problem. For use of GPU and gradient
computation with small number of iterations we strongly recommend the
<a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_log" title="ot.bregman.sinkhorn_log"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_log()</span></code></a> solver that will no need to check for
numerical problems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) – samples in the target domain, compute sinkhorn with multiple targets
and fixed <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is a matrix
(return OT loss + dual variables in log)</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Regularization term &gt;0</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’,’sinkhorn_log’,
‘sinkhorn_stabilized’, see those function for specific parameters</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>warn</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, raises a warning if the algorithm doesn’t convergence.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the u,v sinkhorn scaling vectors)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>(n_hists) float/array-like</em>) – Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">sinkhorn2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0.26894142136999516</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn2">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id35" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of
Optimal Transport, Advances in Neural Information
Processing Systems (NIPS) 26, 2013</p>
</aside>
<aside class="footnote brackets" id="id36" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms
for Entropy Regularized Transport Problems.
arXiv preprint arXiv:1610.06519.</p>
</aside>
<aside class="footnote brackets" id="id37" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems.
arXiv preprint arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id38" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></span>
<p>Altschuler J., Weed J., Rigollet P. : Near-linear time approximation
algorithms for optimal transport via Sinkhorn iteration,
Advances in Neural Information Processing Systems (NIPS) 31, 2017</p>
</aside>
<aside class="footnote brackets" id="id39" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></span>
<p>Feydy, J., Séjourné, T., Vialard, F. X., Amari, S. I.,
Trouvé, A., &amp; Peyré, G. (2019, April).
Interpolating between optimal transport and MMD using Sinkhorn
divergences. In The 22nd International Conference on Artificial
Intelligence and Statistics (pp. 2681-2690). PMLR.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_knopp" title="ot.bregman.sinkhorn_knopp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_knopp</span></code></a></dt><dd><p>Classic Sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[2]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.greenkhorn" title="ot.bregman.greenkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.greenkhorn</span></code></a></dt><dd><p>Greenkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[21]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn_stabilized" title="ot.bregman.sinkhorn_stabilized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn_stabilized</span></code></a></dt><dd><p>Stabilized sinkhorn <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[9]</span></a> <a class="reference internal" href="gen_modules/ot.bregman.html#references-sinkhorn2"><span class="std std-ref">[10]</span></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn_lpl1_mm">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_lpl1_mm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/da.html#sinkhorn_lpl1_mm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn_lpl1_mm" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with non-convex
group lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega_e
(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso  regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^{1/2}_1\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class <cite>c</cite>
in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <a class="reference internal" href="#references-sinkhorn-lpl1-mm"><span class="std std-ref">[5, 7]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-sinkhorn-lpl1-mm">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id40" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id41" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'entropy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/unbalanced.html#sinkhorn_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn_unbalanced" title="Link to this definition"></a></dt>
<dd><p>Solve the unbalanced entropic regularization optimal transport problem
and return the OT plan</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \min_\gamma \ \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega(\gamma) +
\mathrm{reg_{m1}} \cdot \mathrm{KL}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{KL}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization term, can be either KL divergence or negative entropy</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-sinkhorn-unbalanced"><span class="std std-ref">[10, 25]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite></p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>array-like</em><em> (</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) – One or multiple unnormalized histograms of dimension <cite>dim_b</cite>.
If many, compute all the OT distances <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}_i)_i\)</span></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term.
If reg_m is a scalar or an indexable object of length 1,
then the same reg_m is applied to both marginal relaxations.
The entropic balanced OT can be recovered using <cite>reg_m=float(“inf”)</cite>.
For semi-relaxed case, use either
<cite>reg_m=(float(“inf”), scalar)</cite> or <cite>reg_m=(scalar, float(“inf”))</cite>.
If reg_m is an array, it must have the same backend as input arrays (a, b, M).</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’, ‘sinkhorn_stabilized’ or
‘sinkhorn_reg_scaling’, see those function for specific parameters</p></li>
<li><p><strong>reg_type</strong> (<em>string</em><em>, </em><em>optional</em>) – Regularizer term. Can take two values:
‘entropy’ (negative entropy)
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \sum_{i,j} \gamma_{i,j} \log(\gamma_{i,j}) - \sum_{i,j} \gamma_{i,j}\)</span>, or
‘kl’ (Kullback-Leibler)
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, \mathbf{a} \mathbf{b}^T)\)</span>.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the u,v sinkhorn scaling vectors).</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>if n_hists == 1</em> –</p>
<ul>
<li><dl class="simple">
<dt>gamma<span class="classifier">(dim_a, dim_b) array-like</span></dt><dd><p>Optimal transportation matrix for the given parameters</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><em>else</em> –</p>
<ul>
<li><dl class="simple">
<dt>ot_distance<span class="classifier">(n_hists,) array-like</span></dt><dd><p>the OT distance between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and each of the histograms <span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">sinkhorn_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0.51122814, 0.18807032],</span>
<span class="go">       [0.18807032, 0.51122814]])</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn-unbalanced">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id42" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems
(NIPS) 26, 2013</p>
</aside>
<aside class="footnote brackets" id="id43" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms for
Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</aside>
<aside class="footnote brackets" id="id44" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id45" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></span>
<p>Frogner C., Zhang C., Mobahi H., Araya-Polo M., Poggio T. :
Learning with a Wasserstein Loss,  Advances in Neural Information
Processing Systems (NIPS) 2015</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.unbalanced.html#id40" title="ot.unbalanced.sinkhorn_knopp_unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_knopp_unbalanced</span></code></a></dt><dd><p>Unbalanced Classic Sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced"><span class="std std-ref">[10]</span></a></p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.unbalanced.html#id44" title="ot.unbalanced.sinkhorn_stabilized_unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_stabilized_unbalanced</span></code></a></dt><dd><p>Unbalanced Stabilized sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced"><span class="std std-ref">[9, 10]</span></a></p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_reg_scaling_unbalanced</span></code></dt><dd><p>Unbalanced Sinkhorn with epsilon scaling <a class="reference internal" href="#references-sinkhorn-unbalanced"><span class="std std-ref">[9, 10]</span></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sinkhorn_unbalanced2">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_unbalanced2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'entropy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/unbalanced.html#sinkhorn_unbalanced2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sinkhorn_unbalanced2" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization unbalanced optimal transport problem and
return the loss</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega(\gamma) +
\mathrm{reg_{m1}} \cdot \mathrm{KL}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{KL}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization term, can be either KL divergence or negative entropy</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[10, 25]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite></p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>array-like</em><em> (</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) – One or multiple unnormalized histograms of dimension <cite>dim_b</cite>.
If many, compute all the OT distances <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}_i)_i\)</span></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term.
If reg_m is a scalar or an indexable object of length 1,
then the same reg_m is applied to both marginal relaxations.
The entropic balanced OT can be recovered using <cite>reg_m=float(“inf”)</cite>.
For semi-relaxed case, use either
<cite>reg_m=(float(“inf”), scalar)</cite> or <cite>reg_m=(scalar, float(“inf”))</cite>.
If reg_m is an array, it must have the same backend as input arrays (a, b, M).</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’, ‘sinkhorn_stabilized’ or
‘sinkhorn_reg_scaling’, see those function for specific parameterss</p></li>
<li><p><strong>reg_type</strong> (<em>string</em><em>, </em><em>optional</em>) – Regularizer term. Can take two values:
‘entropy’ (negative entropy)
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \sum_{i,j} \gamma_{i,j} \log(\gamma_{i,j}) - \sum_{i,j} \gamma_{i,j}\)</span>, or
‘kl’ (Kullback-Leibler)
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, \mathbf{a} \mathbf{b}^T)\)</span>.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the u,v sinkhorn scaling vectors).</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ot_distance</strong> (<em>(n_hists,) array-like</em>) – the OT distance between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and each of the histograms <span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span></p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary returned only if <cite>log</cite> is <cite>True</cite></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">sinkhorn_unbalanced2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">0.31912858</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn-unbalanced2">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id46" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems
(NIPS) 26, 2013</p>
</aside>
<aside class="footnote brackets" id="id47" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms for
Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</aside>
<aside class="footnote brackets" id="id48" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id49" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></span>
<p>Frogner C., Zhang C., Mobahi H., Araya-Polo M., Poggio T. :
Learning with a Wasserstein Loss,  Advances in Neural Information
Processing Systems (NIPS) 2015</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_knopp</span></code></dt><dd><p>Unbalanced Classic Sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[10]</span></a></p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_stabilized</span></code></dt><dd><p>Unbalanced Stabilized sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[9, 10]</span></a></p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_reg_scaling</span></code></dt><dd><p>Unbalanced Sinkhorn with epsilon scaling <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[9, 10]</span></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sliced_wasserstein_distance">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sliced_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/sliced.html#sliced_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sliced_wasserstein_distance" title="Link to this definition"></a></dt>
<dd><p>Computes a Monte-Carlo approximation of the p-Sliced Wasserstein distance</p>
<div class="math notranslate nohighlight">
\[\mathcal{SWD}_p(\mu, \nu) = \underset{\theta \sim \mathcal{U}(\mathbb{S}^{d-1})}{\mathbb{E}}\left(\mathcal{W}_p^p(\theta_\# \mu, \theta_\# \nu)\right)^{\frac{1}{p}}\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\theta_\# \mu\)</span> stands for the pushforwards of the projection <span class="math notranslate nohighlight">\(X \in \mathbb{R}^d \mapsto \langle \theta, X \rangle\)</span></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_s</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>, </em><em>dim</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>X_t</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>, </em><em>dim</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>a</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>n_projections</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Number of projections used for the Monte-Carlo approximation</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional =</em>) – Power p used for computing the sliced Wasserstein</p></li>
<li><p><strong>projections</strong> (<em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_projections</em><em>)</em><em>, </em><em>optional</em>) – Projection matrix (n_projections and seed are not used in this case)</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>RandomState</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Seed used for random number generator</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, sliced_wasserstein_distance returns the projections used and their associated EMD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cost</strong> (<em>float</em>) – Sliced Wasserstein Cost</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_samples_a</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">n_samples_a</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliced_wasserstein_distance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id50" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></span>
<p>Bonneel, Nicolas, et al. “Sliced and radon wasserstein barycenters of measures.” Journal of Mathematical Imaging and Vision 51.1 (2015): 22-45</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sliced_wasserstein_sphere">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sliced_wasserstein_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/sliced.html#sliced_wasserstein_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sliced_wasserstein_sphere" title="Link to this definition"></a></dt>
<dd><p>Compute the spherical sliced-Wasserstein discrepancy.</p>
<div class="math notranslate nohighlight">
\[SSW_p(\mu,\nu) = \left(\int_{\mathbb{V}_{d,2}} W_p^p(P^U_\#\mu, P^U_\#\nu)\ \mathrm{d}\sigma(U)\right)^{\frac{1}{p}}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(P^U_\# \mu\)</span> stands for the pushforwards of the projection <span class="math notranslate nohighlight">\(\forall x\in S^{d-1},\ P^U(x) = \frac{U^Tx}{\|U^Tx\|_2}\)</span></p></li>
</ul>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_s</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>, </em><em>dim</em><em>)</em>) – Samples in the source domain</p></li>
<li><p><strong>X_t</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>, </em><em>dim</em><em>)</em>) – Samples in the target domain</p></li>
<li><p><strong>a</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>n_projections</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Number of projections used for the Monte-Carlo approximation</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=2</em><em>)</em>) – Power p used for computing the spherical sliced Wasserstein</p></li>
<li><p><strong>projections</strong> (<em>shape</em><em> (</em><em>n_projections</em><em>, </em><em>dim</em><em>, </em><em>2</em><em>)</em><em>, </em><em>optional</em>) – Projection matrix (n_projections and seed are not used in this case)</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>RandomState</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Seed used for random number generator</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, sliced_wasserstein_sphere returns the projections used and their associated EMD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cost</strong> (<em>float</em>) – Spherical Sliced Wasserstein Cost</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_samples_a</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">n_samples_a</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliced_wasserstein_sphere</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id51" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></span>
<p>Bonet, C., Berg, P., Courty, N., Septier, F., Drumetz, L., &amp; Pham, M. T. (2023). Spherical sliced-wasserstein. International Conference on Learning Representations.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.sliced_wasserstein_sphere_unif">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">sliced_wasserstein_sphere_unif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/sliced.html#sliced_wasserstein_sphere_unif"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.sliced_wasserstein_sphere_unif" title="Link to this definition"></a></dt>
<dd><p>Compute the 2-spherical sliced wasserstein w.r.t. a uniform distribution.</p>
<div class="math notranslate nohighlight">
\[SSW_2(\mu_n, \nu)\]</div>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mu_n=\sum_{i=1}^n \alpha_i \delta_{x_i}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\nu=\mathrm{Unif}(S^1)\)</span></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_s</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>, </em><em>dim</em><em>)</em>) – Samples in the source domain</p></li>
<li><p><strong>a</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>n_projections</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Number of projections used for the Monte-Carlo approximation</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>RandomState</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Seed used for random number generator</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, sliced_wasserstein_distance returns the projections used and their associated EMD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cost</strong> (<em>float</em>) – Spherical Sliced Wasserstein Cost</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x0</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssw</span> <span class="o">=</span> <span class="n">sliced_wasserstein_sphere_unif</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sliced_wasserstein_sphere_unif</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">),</span> <span class="mf">0.01734</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<section id="references">
<h3>References:<a class="headerlink" href="#references" title="Link to this heading"></a></h3>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id52" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></span>
<p>Bonet, C., Berg, P., Courty, N., Septier, F., Drumetz, L., &amp; Pham, M. T. (2023). Spherical sliced-wasserstein. International Conference on Learning Representations.</p>
</aside>
</aside>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.solve">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'KL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalanced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalanced_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'KL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plan_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentials_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/solvers.html#solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.solve" title="Link to this definition"></a></dt>
<dd><p>Solve the discrete optimal transport problem and return <a class="reference internal" href="gen_modules/ot.utils.html#id16" title="ot.utils.OTResult"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OTResult</span></code></a> object</p>
<p>The function solves the following general optimal transport problem</p>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{T}\geq 0} \quad \sum_{i,j} T_{i,j}M_{i,j} + \lambda_r R(\mathbf{T}) +
\lambda_u U(\mathbf{T}\mathbf{1},\mathbf{a}) +
\lambda_u U(\mathbf{T}^T\mathbf{1},\mathbf{b})\]</div>
<p>The regularization is selected with <cite>reg</cite> (<span class="math notranslate nohighlight">\(\lambda_r\)</span>) and <cite>reg_type</cite>. By
default <code class="docutils literal notranslate"><span class="pre">reg=None</span></code> and there is no regularization. The unbalanced marginal
penalization can be selected with <cite>unbalanced</cite> (<span class="math notranslate nohighlight">\(\lambda_u\)</span>) and
<cite>unbalanced_type</cite>. By default <code class="docutils literal notranslate"><span class="pre">unbalanced=None</span></code> and the function
solves the exact optimal transport problem (respecting the marginals).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – Loss matrix</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Samples weights in the source domain (default is uniform)</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Samples weights in the source domain (default is uniform)</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization weight <span class="math notranslate nohighlight">\(\lambda_r\)</span>, by default None (no reg., exact
OT)</p></li>
<li><p><strong>reg_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Type of regularization <span class="math notranslate nohighlight">\(R\)</span>  either “KL”, “L2”, “entropy”, by default “KL”</p></li>
<li><p><strong>unbalanced</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Unbalanced penalization weight <span class="math notranslate nohighlight">\(\lambda_u\)</span>, by default None
(balanced OT)</p></li>
<li><p><strong>unbalanced_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Type of unbalanced penalization function <span class="math notranslate nohighlight">\(U\)</span>  either “KL”, “L2”,
“TV”, by default “KL”</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Method for solving the problem when multiple algorithms are available,
default None for automatic selection.</p></li>
<li><p><strong>n_threads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Number of OMP threads for exact OT solver, by default 1</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Maximum number of iterations, by default None (default values in each solvers)</p></li>
<li><p><strong>plan_init</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of the OT plan for iterative methods, by default None</p></li>
<li><p><strong>potentials_init</strong> (<em>(</em><em>array_like</em><em>(</em><em>dim_a</em><em>,</em><em>)</em><em>,</em><em>array_like</em><em>(</em><em>dim_b</em><em>,</em><em>)</em><em>)</em><em>, </em><em>optional</em>) – Initialization of the OT dual potentials for iterative methods, by default None</p></li>
<li><p><strong>tol</strong> (<em>_type_</em><em>, </em><em>optional</em>) – Tolerance for solution precision, by default None (default values in each solvers)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information in the solver, by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>res</strong> – Result of the optimization problem. The information can be obtained as follows:</p>
<ul class="simple">
<li><p>res.plan : OT plan <span class="math notranslate nohighlight">\(\mathbf{T}\)</span></p></li>
<li><p>res.potentials : OT dual potentials</p></li>
<li><p>res.value : Optimal value of the optimization problem</p></li>
<li><p>res.value_linear : Linear OT loss with the optimal OT plan</p></li>
</ul>
<p>See <a class="reference internal" href="gen_modules/ot.utils.html#id16" title="ot.utils.OTResult"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OTResult</span></code></a> for more information.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="gen_modules/ot.utils.html#id16" title="ot.utils.OTResult">OTResult</a>()</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The following methods are available for solving the OT problems:</p>
<ul class="simple">
<li><p><strong>Classical exact OT problem [1]</strong> (default parameters) :</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\mathbf{T} \quad \langle \mathbf{T}, \mathbf{M} \rangle_F\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Entropic regularized OT [2]</strong> (when <code class="docutils literal notranslate"><span class="pre">reg!=None</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\mathbf{T} \quad \langle \mathbf{T}, \mathbf{M} \rangle_F + \lambda R(\mathbf{T})\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># default is ``&quot;KL&quot;`` regularization (``reg_type=&quot;KL&quot;``)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="c1"># or for original Sinkhorn paper formulation [2]</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;entropy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Quadratic regularized OT [17]</strong> (when <code class="docutils literal notranslate"><span class="pre">reg!=None</span></code> and <code class="docutils literal notranslate"><span class="pre">reg_type=&quot;L2&quot;</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\mathbf{T} \quad \langle \mathbf{T}, \mathbf{M} \rangle_F + \lambda R(\mathbf{T})\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Unbalanced OT [41]</strong> (when <code class="docutils literal notranslate"><span class="pre">unbalanced!=None</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{T}\geq 0} \quad \sum_{i,j} T_{i,j}M_{i,j} + \lambda_u U(\mathbf{T}\mathbf{1},\mathbf{a}) + \lambda_u U(\mathbf{T}^T\mathbf{1},\mathbf{b})\]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># default is ``&quot;KL&quot;``</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="c1"># quadratic unbalanced OT</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
<span class="c1"># TV = partial OT</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;TV&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Regularized unbalanced regularized OT [34]</strong> (when <code class="docutils literal notranslate"><span class="pre">unbalanced!=None</span></code> and <code class="docutils literal notranslate"><span class="pre">reg!=None</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{T}\geq 0} \quad \sum_{i,j} T_{i,j}M_{i,j} + \lambda_r R(\mathbf{T}) + \lambda_u U(\mathbf{T}\mathbf{1},\mathbf{a}) + \lambda_u U(\mathbf{T}^T\mathbf{1},\mathbf{b})\]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># default is ``&quot;KL&quot;`` for both</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="c1"># quadratic unbalanced OT with KL regularization</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
<span class="c1"># both quadratic</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">,</span><span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric" id="references-solve">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id53" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</aside>
<aside class="footnote brackets" id="id54" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation
of Optimal Transport, Advances in Neural Information Processing
Systems (NIPS) 26, 2013</p>
</aside>
<aside class="footnote brackets" id="id55" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems.
arXiv preprint arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id56" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></span>
<p>Blondel, M., Seguy, V., &amp; Rolet, A. (2018). Smooth and Sparse
Optimal Transport. Proceedings of the Twenty-First International
Conference on Artificial Intelligence and Statistics (AISTATS).</p>
</aside>
<aside class="footnote brackets" id="id57" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></span>
<p>Feydy, J., Séjourné, T., Vialard, F. X., Amari, S. I., Trouvé,
A., &amp; Peyré, G. (2019, April). Interpolating between optimal transport
and MMD using Sinkhorn divergences. In The 22nd International Conference
on Artificial Intelligence and Statistics (pp. 2681-2690). PMLR.</p>
</aside>
<aside class="footnote brackets" id="id58" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></span>
<p>Chapel, L., Flamary, R., Wu, H., Févotte, C., and Gasso, G. (2021).
Unbalanced optimal transport through non-negative penalized
linear regression. NeurIPS.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.solve_gromov">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">solve_gromov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ca</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'entropy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalanced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalanced_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'KL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plan_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/solvers.html#solve_gromov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.solve_gromov" title="Link to this definition"></a></dt>
<dd><p>Solve the discrete (Fused) Gromov-Wasserstein and return <a class="reference internal" href="gen_modules/ot.utils.html#id16" title="ot.utils.OTResult"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OTResult</span></code></a> object</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{T}\geq 0} \quad (1 - \alpha) \langle \mathbf{T}, \mathbf{M} \rangle_F +
\alpha \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} + \lambda_r R(\mathbf{T}) + \lambda_u U(\mathbf{T}\mathbf{1},\mathbf{a}) + \lambda_u U(\mathbf{T}^T\mathbf{1},\mathbf{b})\]</div>
<p>The regularization is selected with <cite>reg</cite> (<span class="math notranslate nohighlight">\(\lambda_r\)</span>) and
<cite>reg_type</cite>. By default <code class="docutils literal notranslate"><span class="pre">reg=None</span></code> and there is no regularization. The
unbalanced marginal penalization can be selected with <cite>unbalanced</cite>
(<span class="math notranslate nohighlight">\(\lambda_u\)</span>) and <cite>unbalanced_type</cite>. By default <code class="docutils literal notranslate"><span class="pre">unbalanced=None</span></code>
and the function solves the exact optimal transport problem (respecting the
marginals).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Ca</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_a</em><em>)</em>) – Cost matrix in the source domain</p></li>
<li><p><strong>Cb</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>, </em><em>dim_b</em><em>)</em>) – Cost matrix in the target domain</p></li>
<li><p><strong>M</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Linear cost matrix for Fused Gromov-Wasserstein (default is None).</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Samples weights in the source domain (default is uniform)</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Samples weights in the source domain (default is uniform)</p></li>
<li><p><strong>loss</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Type of loss function, either <code class="docutils literal notranslate"><span class="pre">&quot;L2&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;KL&quot;</span></code>, by default <code class="docutils literal notranslate"><span class="pre">&quot;L2&quot;</span></code></p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Use symmetric version of the Gromov-Wasserstein problem, by default None
tests whether the matrices are symmetric or True/False to avoid the test.</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization weight <span class="math notranslate nohighlight">\(\lambda_r\)</span>, by default None (no reg., exact
OT)</p></li>
<li><p><strong>reg_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Type of regularization <span class="math notranslate nohighlight">\(R\)</span>, by default “entropy” (only used when
<code class="docutils literal notranslate"><span class="pre">reg!=None</span></code>)</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Weight the quadratic term (alpha*Gromov) and the linear term
((1-alpha)*Wass) in the Fused Gromov-Wasserstein problem. Not used for
Gromov problem (when M is not provided). By default <code class="docutils literal notranslate"><span class="pre">alpha=None</span></code>
corresponds to <code class="docutils literal notranslate"><span class="pre">alpha=1</span></code> for Gromov problem (<code class="docutils literal notranslate"><span class="pre">M==None</span></code>) and
<code class="docutils literal notranslate"><span class="pre">alpha=0.5</span></code> for Fused Gromov-Wasserstein problem (<code class="docutils literal notranslate"><span class="pre">M!=None</span></code>)</p></li>
<li><p><strong>unbalanced</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Unbalanced penalization weight <span class="math notranslate nohighlight">\(\lambda_u\)</span>, by default None
(balanced OT), Not implemented yet</p></li>
<li><p><strong>unbalanced_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Type of unbalanced penalization function <span class="math notranslate nohighlight">\(U\)</span> either “KL”, “semirelaxed”,
“partial”, by default “KL” but note that it is not implemented yet.</p></li>
<li><p><strong>n_threads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Number of OMP threads for exact OT solver, by default 1</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Method for solving the problem when multiple algorithms are available,
default None for automatic selection.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Maximum number of iterations, by default None (default values in each
solvers)</p></li>
<li><p><strong>plan_init</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of the OT plan for iterative methods, by default None</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Tolerance for solution precision, by default None (default values in
each solvers)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information in the solver, by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>res</strong> – Result of the optimization problem. The information can be obtained as follows:</p>
<ul class="simple">
<li><p>res.plan : OT plan <span class="math notranslate nohighlight">\(\mathbf{T}\)</span></p></li>
<li><p>res.potentials : OT dual potentials</p></li>
<li><p>res.value : Optimal value of the optimization problem</p></li>
<li><p>res.value_linear : Linear OT loss with the optimal OT plan</p></li>
<li><p>res.value_quad : Quadratic (GW) part of the OT loss with the optimal OT plan</p></li>
</ul>
<p>See <a class="reference internal" href="gen_modules/ot.utils.html#id16" title="ot.utils.OTResult"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OTResult</span></code></a> for more information.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="gen_modules/ot.utils.html#id16" title="ot.utils.OTResult">OTResult</a>()</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The following methods are available for solving the Gromov-Wasserstein
problem:</p>
<ul class="simple">
<li><p><strong>Classical Gromov-Wasserstein (GW) problem [3]</strong> (default parameters):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\mathbf{T}\geq 0} \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j}\mathbf{T}_{k,l}\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">)</span> <span class="c1"># uniform weights</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span> <span class="c1"># given weights</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;KL&#39;</span><span class="p">)</span> <span class="c1"># KL loss</span>

<span class="n">plan</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plan</span> <span class="c1"># GW plan</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value</span> <span class="c1"># GW value</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Fused Gromov-Wasserstein (FGW) problem [24]</strong> (when <code class="docutils literal notranslate"><span class="pre">M!=None</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\mathbf{T}\geq 0} \quad (1 - \alpha) \langle \mathbf{T}, \mathbf{M} \rangle_F +
\alpha \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j}\mathbf{T}_{k,l}\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span> <span class="c1"># uniform weights, alpha=0.5 (default)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1"># given weights and alpha</span>

<span class="n">plan</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plan</span> <span class="c1"># FGW plan</span>
<span class="n">loss_linear_term</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value_linear</span> <span class="c1"># Wasserstein part of the loss</span>
<span class="n">loss_quad_term</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value_quad</span> <span class="c1"># Gromov part of the loss</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value</span> <span class="c1"># FGW value</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Regularized (Fused) Gromov-Wasserstein (GW) problem [12]</strong> (when  <code class="docutils literal notranslate"><span class="pre">reg!=None</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\mathbf{T}\geq 0} \quad (1 - \alpha) \langle \mathbf{T}, \mathbf{M} \rangle_F +
\alpha \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j}\mathbf{T}_{k,l} + \lambda_r R(\mathbf{T})\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># GW entropy regularization (default)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1"># FGW with entropy</span>

<span class="n">plan</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plan</span> <span class="c1"># FGW plan</span>
<span class="n">loss_linear_term</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value_linear</span> <span class="c1"># Wasserstein part of the loss</span>
<span class="n">loss_quad_term</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value_quad</span> <span class="c1"># Gromov part of the loss</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value</span> <span class="c1"># FGW value (including regularization)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Semi-relaxed (Fused) Gromov-Wasserstein (GW) [48]</strong> (when  <code class="docutils literal notranslate"><span class="pre">unbalanced='semirelaxed'</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\mathbf{T}\geq 0} \quad (1 - \alpha) \langle \mathbf{T}, \mathbf{M} \rangle_F +
\alpha \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j}\mathbf{T}_{k,l}\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T} \geq 0\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="s1">&#39;semirelaxed&#39;</span><span class="p">)</span> <span class="c1"># semirelaxed GW</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="s1">&#39;semirelaxed&#39;</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># entropic semirelaxed GW</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="s1">&#39;semirelaxed&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1"># semirelaxed FGW</span>

<span class="n">plan</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plan</span> <span class="c1"># FGW plan</span>
<span class="n">right_marginal</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">marginal_b</span> <span class="c1"># right marginal of the plan</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Partial (Fused) Gromov-Wasserstein (GW) problem [29]</strong> (when  <code class="docutils literal notranslate"><span class="pre">unbalanced='partial'</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\mathbf{T}\geq 0} \quad (1 - \alpha) \langle \mathbf{T}, \mathbf{M} \rangle_F +
\alpha \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j}\mathbf{T}_{k,l}\\s.t. \ \mathbf{T} \mathbf{1} \leq \mathbf{a}\\        \mathbf{T}^T \mathbf{1} \leq \mathbf{b}\\        \mathbf{T} \geq 0\\        \mathbf{1}^T\mathbf{T}\mathbf{1} = m\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_gromov</span><span class="p">(</span><span class="n">Ca</span><span class="p">,</span> <span class="n">Cb</span><span class="p">,</span> <span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;partial&#39;</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span> <span class="c1"># partial GW with m=0.8</span>
</pre></div>
</div>
<p class="rubric" id="references-solve-gromov">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id59" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Mémoli, F. (2011). Gromov–Wasserstein distances and the metric
approach to object matching. Foundations of computational mathematics,
11(4), 417-487.</p>
</aside>
<aside class="footnote brackets" id="id60" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<p>Gabriel Peyré, Marco Cuturi, and Justin Solomon (2016),
Gromov-Wasserstein averaging of kernel and distance matrices
International Conference on Machine Learning (ICML).</p>
</aside>
<aside class="footnote brackets" id="id61" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></span>
<p>Vayer, T., Chapel, L., Flamary, R., Tavenard, R. and Courty, N.
(2019). Optimal Transport for structured data with application on graphs
Proceedings of the 36th International Conference on Machine Learning
(ICML).</p>
</aside>
<aside class="footnote brackets" id="id62" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>48<span class="fn-bracket">]</span></span>
<p>Cédric Vincent-Cuaz, Rémi Flamary, Marco Corneli, Titouan Vayer,
Nicolas Courty (2022). Semi-relaxed Gromov-Wasserstein divergence and
applications on graphs. International Conference on Learning
Representations (ICLR), 2022.</p>
</aside>
<aside class="footnote brackets" id="id63" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>29<span class="fn-bracket">]</span></span>
<p>Chapel, L., Alaya, M., Gasso, G. (2020). Partial Optimal Transport
with Applications on Positive-Unlabeled Learning, Advances in Neural
Information Processing Systems (NeurIPS), 2020.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.solve_sample">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">solve_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'KL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalanced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unbalanced_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'KL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plan_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentials_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/solvers.html#solve_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.solve_sample" title="Link to this definition"></a></dt>
<dd><p>Solve the discrete optimal transport problem using the samples in the source and target domains.</p>
<p>The function solves the following general optimal transport problem</p>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{T}\geq 0} \quad \sum_{i,j} T_{i,j}M_{i,j} + \lambda_r R(\mathbf{T}) +
\lambda_u U(\mathbf{T}\mathbf{1},\mathbf{a}) +
\lambda_u U(\mathbf{T}^T\mathbf{1},\mathbf{b})\]</div>
<p>where the cost matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is computed from the samples in the
source and target domains such that <span class="math notranslate nohighlight">\(M_{i,j} = d(x_i,y_j)\)</span> where
<span class="math notranslate nohighlight">\(d\)</span> is a metric (by default the squared Euclidean distance).</p>
<p>The regularization is selected with <cite>reg</cite> (<span class="math notranslate nohighlight">\(\lambda_r\)</span>) and <cite>reg_type</cite>. By
default <code class="docutils literal notranslate"><span class="pre">reg=None</span></code> and there is no regularization. The unbalanced marginal
penalization can be selected with <cite>unbalanced</cite> (<span class="math notranslate nohighlight">\(\lambda_u\)</span>) and
<cite>unbalanced_type</cite>. By default <code class="docutils literal notranslate"><span class="pre">unbalanced=None</span></code> and the function
solves the exact optimal transport problem (respecting the marginals).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_s</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples_a</em><em>, </em><em>dim</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>X_t</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples_b</em><em>, </em><em>dim</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Samples weights in the source domain (default is uniform)</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Samples weights in the source domain (default is uniform)</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization weight <span class="math notranslate nohighlight">\(\lambda_r\)</span>, by default None (no reg., exact
OT)</p></li>
<li><p><strong>reg_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Type of regularization <span class="math notranslate nohighlight">\(R\)</span>  either “KL”, “L2”, “entropy”, by default “KL”</p></li>
<li><p><strong>unbalanced</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Unbalanced penalization weight <span class="math notranslate nohighlight">\(\lambda_u\)</span>, by default None
(balanced OT)</p></li>
<li><p><strong>unbalanced_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Type of unbalanced penalization function <span class="math notranslate nohighlight">\(U\)</span>  either “KL”, “L2”, “TV”, by default “KL”</p></li>
<li><p><strong>lazy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Return <code class="xref any docutils literal notranslate"><span class="pre">OTResultlazy</span></code> object to reduce memory cost when True, by
default False</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Batch size for lazy solver, by default None (default values in each
solvers)</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>optional</em>) – Method for solving the problem, this can be used to select the solver
for unbalanced problems (see <a class="reference internal" href="#ot.solve" title="ot.solve"><code class="xref any py py-func docutils literal notranslate"><span class="pre">ot.solve</span></code></a>), or to select a specific
large scale solver.</p></li>
<li><p><strong>n_threads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Number of OMP threads for exact OT solver, by default 1</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Maximum number of iteration, by default None (default values in each solvers)</p></li>
<li><p><strong>plan_init</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of the OT plan for iterative methods, by default None</p></li>
<li><p><strong>rank</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Rank of the OT matrix for lazy solers (method=’factored’), by default 100</p></li>
<li><p><strong>scaling</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Scaling factor for the epsilon scaling lazy solvers (method=’geomloss’), by default 0.95</p></li>
<li><p><strong>potentials_init</strong> (<em>(</em><em>array_like</em><em>(</em><em>dim_a</em><em>,</em><em>)</em><em>,</em><em>array_like</em><em>(</em><em>dim_b</em><em>,</em><em>)</em><em>)</em><em>, </em><em>optional</em>) – Initialization of the OT dual potentials for iterative methods, by default None</p></li>
<li><p><strong>tol</strong> (<em>_type_</em><em>, </em><em>optional</em>) – Tolerance for solution precision, by default None (default values in each solvers)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information in the solver, by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>res</strong> – Result of the optimization problem. The information can be obtained as follows:</p>
<ul class="simple">
<li><p>res.plan : OT plan <span class="math notranslate nohighlight">\(\mathbf{T}\)</span></p></li>
<li><p>res.potentials : OT dual potentials</p></li>
<li><p>res.value : Optimal value of the optimization problem</p></li>
<li><p>res.value_linear : Linear OT loss with the optimal OT plan</p></li>
<li><p>res.lazy_plan : Lazy OT plan (when <code class="docutils literal notranslate"><span class="pre">lazy=True</span></code> or lazy method)</p></li>
</ul>
<p>See <a class="reference internal" href="gen_modules/ot.utils.html#id16" title="ot.utils.OTResult"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OTResult</span></code></a> for more information.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="gen_modules/ot.utils.html#id16" title="ot.utils.OTResult">OTResult</a>()</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The following methods are available for solving the OT problems:</p>
<ul class="simple">
<li><p><strong>Classical exact OT problem [1]</strong> (default parameters) :</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\mathbf{T} \quad \langle \mathbf{T}, \mathbf{M} \rangle_F\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0,  M_{i,j} = d(x_i,y_j)\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># for uniform weights</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Entropic regularized OT [2]</strong> (when <code class="docutils literal notranslate"><span class="pre">reg!=None</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\mathbf{T} \quad \langle \mathbf{T}, \mathbf{M} \rangle_F + \lambda R(\mathbf{T})\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0,  M_{i,j} = d(x_i,y_j)\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># default is ``&quot;KL&quot;`` regularization (``reg_type=&quot;KL&quot;``)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="c1"># or for original Sinkhorn paper formulation [2]</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;entropy&#39;</span><span class="p">)</span>

<span class="c1"># lazy solver of memory complexity O(n)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="c1"># lazy OT plan</span>
<span class="n">lazy_plan</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">lazy_plan</span>
</pre></div>
</div>
<p>We also have a very efficient solver with compiled CPU/CUDA code using
geomloss/PyKeOps that can be used with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># automatic solver</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;geomloss&#39;</span><span class="p">)</span>

<span class="c1"># force O(n) memory efficient solver</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;geomloss_online&#39;</span><span class="p">)</span>

<span class="c1"># force pre-computed cost matrix</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;geomloss_tensorized&#39;</span><span class="p">)</span>

<span class="c1"># use multiscale solver</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;geomloss_multiscale&#39;</span><span class="p">)</span>

<span class="c1"># One can play with speed (small scaling factor) and precision (scaling close to 1)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;geomloss&#39;</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Quadratic regularized OT [17]</strong> (when <code class="docutils literal notranslate"><span class="pre">reg!=None</span></code> and <code class="docutils literal notranslate"><span class="pre">reg_type=&quot;L2&quot;</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\mathbf{T} \quad \langle \mathbf{T}, \mathbf{M} \rangle_F + \lambda R(\mathbf{T})\\s.t. \ \mathbf{T} \mathbf{1} = \mathbf{a}\\     \mathbf{T}^T \mathbf{1} = \mathbf{b}\\     \mathbf{T} \geq 0,  M_{i,j} = d(x_i,y_j)\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Unbalanced OT [41]</strong> (when <code class="docutils literal notranslate"><span class="pre">unbalanced!=None</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\mathbf{T}\geq 0} \quad \sum_{i,j} T_{i,j}M_{i,j} + \lambda_u U(\mathbf{T}\mathbf{1},\mathbf{a}) + \lambda_u U(\mathbf{T}^T\mathbf{1},\mathbf{b})\\with  M_{i,j} = d(x_i,y_j)\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># default is ``&quot;KL&quot;``</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="c1"># quadratic unbalanced OT</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
<span class="c1"># TV = partial OT</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;TV&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Regularized unbalanced regularized OT [34]</strong> (when <code class="docutils literal notranslate"><span class="pre">unbalanced!=None</span></code> and <code class="docutils literal notranslate"><span class="pre">reg!=None</span></code>):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\mathbf{T}\geq 0} \quad \sum_{i,j} T_{i,j}M_{i,j} + \lambda_r R(\mathbf{T}) + \lambda_u U(\mathbf{T}\mathbf{1},\mathbf{a}) + \lambda_u U(\mathbf{T}^T\mathbf{1},\mathbf{b})\\with  M_{i,j} = d(x_i,y_j)\end{aligned}\end{align} \]</div>
<p>can be solved with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># default is ``&quot;KL&quot;`` for both</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="c1"># quadratic unbalanced OT with KL regularization</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
<span class="c1"># both quadratic</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">,</span>
<span class="n">unbalanced</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unbalanced_type</span><span class="o">=</span><span class="s1">&#39;L2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Factored OT [2]</strong> (when <code class="docutils literal notranslate"><span class="pre">method='factored'</span></code>):</p></li>
</ul>
<p>This method solve the following OT problem <a href="#id81"><span class="problematic" id="id64">[40]_</span></a></p>
<div class="math notranslate nohighlight">
\[\mathop{\arg \min}_\mu \quad  W_2^2(\mu_a,\mu)+ W_2^2(\mu,\mu_b)\]</div>
<p>where $mu$ is a uniform weighted empirical distribution of  <span class="math notranslate nohighlight">\(\mu_a\)</span> and <span class="math notranslate nohighlight">\(\mu_b\)</span> are the empirical measures associated
to the samples in the source and target domains, and <span class="math notranslate nohighlight">\(W_2\)</span> is the
Wasserstein distance. This problem is solved using exact OT solvers for
<cite>reg=None</cite> and the Sinkhorn solver for <cite>reg!=None</cite>. The solution provides
two transport plans that can be used to recover a low rank OT plan between
the two distributions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;factored&#39;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># recover the lazy low rank plan</span>
<span class="n">factored_solution_lazy</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">lazy_plan</span>

<span class="c1"># recover the full low rank plan</span>
<span class="n">factored_solution</span> <span class="o">=</span> <span class="n">factored_solution_lazy</span><span class="p">[:]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Gaussian Bures-Wasserstein [2]</strong> (when <code class="docutils literal notranslate"><span class="pre">method='gaussian'</span></code>):</p></li>
</ul>
<p>This method computes the Gaussian Bures-Wasserstein distance between two
Gaussian distributions estimated from teh empirical distributions</p>
<div class="math notranslate nohighlight">
\[\mathcal{W}(\mu_s, \mu_t)_2^2= \left\lVert \mathbf{m}_s - \mathbf{m}_t \right\rVert^2 + \mathcal{B}(\Sigma_s, \Sigma_t)^{2}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}(\Sigma_s, \Sigma_t)^{2} = \text{Tr}\left(\Sigma_s + \Sigma_t - 2 \sqrt{\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2}} \right)\]</div>
<p>The covariances and means are estimated from the data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>

<span class="c1"># recover the squared Gaussian Bures-Wasserstein distance</span>
<span class="n">BW_dist</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Wasserstein 1d [1]</strong> (when <code class="docutils literal notranslate"><span class="pre">method='1D'</span></code>):</p></li>
</ul>
<p>This method computes the Wasserstein distance between two 1d distributions
estimated from the empirical distributions. For multivariate data the
distances are computed independently for each dimension.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">solve_sample</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;1D&#39;</span><span class="p">)</span>

<span class="c1"># recover the squared Wasserstein distances</span>
<span class="n">W_dists</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p class="rubric" id="references-solve-sample">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id65" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</aside>
<aside class="footnote brackets" id="id66" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation
of Optimal Transport, Advances in Neural Information Processing
Systems (NIPS) 26, 2013</p>
</aside>
<aside class="footnote brackets" id="id67" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems.
arXiv preprint arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id68" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></span>
<p>Blondel, M., Seguy, V., &amp; Rolet, A. (2018). Smooth and Sparse
Optimal Transport. Proceedings of the Twenty-First International
Conference on Artificial Intelligence and Statistics (AISTATS).</p>
</aside>
<aside class="footnote brackets" id="id69" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></span>
<p>Feydy, J., Séjourné, T., Vialard, F. X., Amari, S. I., Trouvé,
A., &amp; Peyré, G. (2019, April). Interpolating between optimal transport
and MMD using Sinkhorn divergences. In The 22nd International Conference
on Artificial Intelligence and Statistics (pp. 2681-2690). PMLR.</p>
</aside>
<aside class="footnote brackets" id="id70" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>40<span class="fn-bracket">]</span></span>
<p>Forrow, A., Hütter, J. C., Nitzan, M., Rigollet, P., Schiebinger,
G., &amp; Weed, J. (2019, April). Statistical optimal transport via factored
couplings. In The 22nd International Conference on Artificial
Intelligence and Statistics (pp. 2454-2465). PMLR.</p>
</aside>
<aside class="footnote brackets" id="id71" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></span>
<p>Chapel, L., Flamary, R., Wu, H., Févotte, C., and Gasso, G. (2021).
Unbalanced optimal transport through non-negative penalized
linear regression. NeurIPS.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.tic">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">tic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#tic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.tic" title="Link to this definition"></a></dt>
<dd><p>Python implementation of Matlab tic() function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.toc">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">toc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Elapsed</span> <span class="pre">time</span> <span class="pre">:</span> <span class="pre">{}</span> <span class="pre">s'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#toc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.toc" title="Link to this definition"></a></dt>
<dd><p>Python implementation of Matlab toc() function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.toq">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">toq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#toq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.toq" title="Link to this definition"></a></dt>
<dd><p>Python implementation of Julia toc() function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unif">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">unif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_as</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/utils.html#unif"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unif" title="Link to this definition"></a></dt>
<dd><p>Return a uniform histogram of length <cite>n</cite> (simplex).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – number of bins in the histogram</p></li>
<li><p><strong>type_as</strong> (<em>array_like</em>) – array of the same type of the expected output (numpy/pytorch/jax)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>h</strong> – histogram of length <cite>n</cite> such that <span class="math notranslate nohighlight">\(\forall i, \mathbf{h}_i = \frac{1}{n}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array_like (<cite>n</cite>,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.wasserstein_1d">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">wasserstein_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#wasserstein_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.wasserstein_1d" title="Link to this definition"></a></dt>
<dd><p>Computes the 1 dimensional OT loss [15] between two (batched) empirical
distributions</p>
<p>It is formally the p-Wasserstein distance raised to the power p.
We do so in a vectorized way by first building the individual quantile functions then integrating them.</p>
<p>This function should be preferred to <cite>emd_1d</cite> whenever the backend is
different to numpy, and when gradients over
either sample positions or weights are required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – locations of the first empirical distribution</p></li>
<li><p><strong>v_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em>) – locations of the second empirical distribution</p></li>
<li><p><strong>u_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – weights of the first empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>v_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – weights of the second empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – order of the ground metric used, should be at least 1 (see [2, Chap. 2], default is 1</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – sort the distributions atoms locations, if False we will consider they have been sorted prior to being passed to
the function, default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>cost</strong> – the batched EMD</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float/array-like, shape (…)</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id72" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2018). Computational Optimal Transport.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.wasserstein_circle">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">wasserstein_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/lp/solver_1d.html#wasserstein_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.wasserstein_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the Wasserstein distance on the circle using either [45] for p=1 or
the binary search algorithm proposed in [44] otherwise.
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it requires to first find the coordinates
using e.g. the atan2 function.</p>
<p>General loss returned:</p>
<div class="math notranslate nohighlight">
\[OT_{loss} = \inf_{\theta\in\mathbb{R}}\int_0^1 |cdf_u^{-1}(q)  - (cdf_v-\theta)^{-1}(q)|^p\ \mathrm{d}q\]</div>
<p>For p=1, [45]</p>
<div class="math notranslate nohighlight">
\[W_1(u,v) = \int_0^1 |F_u(t)-F_v(t)-LevMed(F_u-F_v)|\ \mathrm{d}t\]</div>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the target domain (coordinates on [0,1[)</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Power p used for computing the Wasserstein distance</p></li>
<li><p><strong>Lm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Lower bound dC. For p&gt;1.</p></li>
<li><p><strong>Lp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Upper bound dC. For p&gt;1.</p></li>
<li><p><strong>tm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Lower bound theta. For p&gt;1.</p></li>
<li><p><strong>tp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Upper bound theta. For p&gt;1.</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stopping condition. For p&gt;1.</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, sort the values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Cost associated to the optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wasserstein_circle</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([0.1])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id73" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<p>Hundrieser, Shayan, Marcel Klatt, and Axel Munk. “The statistics of circular optimal transport.” Directional Statistics for Innovative Applications: A Bicentennial Tribute to Florence Nightingale. Singapore: Springer Nature Singapore, 2022. 57-82.</p>
</aside>
<aside class="footnote brackets" id="id74" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></span>
<p>Delon, Julie, Julien Salomon, and Andrei Sobolevski. “Fast transport optimization for Monge costs on the circle.” SIAM Journal on Applied Mathematics 70.7 (2010): 2239-2258.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.weak_optimal_transport">
<span class="sig-prename descclassname"><span class="pre">ot.</span></span><span class="sig-name descname"><span class="pre">weak_optimal_transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ot/weak.html#weak_optimal_transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.weak_optimal_transport" title="Link to this definition"></a></dt>
<dd><p>Solves the weak optimal transport problem between two empirical distributions</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \sum_i \mathbf{a}_i \left(\mathbf{X^a}_i - \frac{1}{\mathbf{a}_i} \sum_j \gamma_{ij} \mathbf{X^b}_j \right)^2\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(X^a\)</span> and  <span class="math notranslate nohighlight">\(X^b\)</span>  are the sample matrices.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<p>Uses the conditional gradient algorithm to solve the problem proposed
in <a class="reference internal" href="#references-weak"><span class="std std-ref">[39]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xa</strong> (<em>(</em><em>ns</em><em>,</em><em>d</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Source samples</p></li>
<li><p><strong>Xb</strong> (<em>(</em><em>nt</em><em>,</em><em>d</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Target samples</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Target histogram (uniform weight if empty list))</p></li>
<li><p><strong>G0</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – initial guess (default is indep joint density)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numItermaxEmd</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations for emd</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on the relative variation (&gt;0)</p></li>
<li><p><strong>stopThr2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on the absolute variation (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (ns, nt)</em>) – Optimal transportation matrix for the given
parameters</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – If input log is true, a dictionary containing the
cost and dual variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-weak">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id75" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>39<span class="fn-bracket">]</span></span>
<p>Gozlan, N., Roberto, C., Samson, P. M., &amp; Tetali, P. (2017).
Kantorovich duality for general transport costs and applications.
Journal of Functional Analysis, 273(11), 3327-3405.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="gen_modules/ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="gen_modules/ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="quickstart.html" class="btn btn-neutral float-left" title="Quick start guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="gen_modules/ot.backend.html" class="btn btn-neutral float-right" title="ot.backend" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Rémi Flamary, Nicolas Courty.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span>
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>