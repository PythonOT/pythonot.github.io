<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.da &mdash; POT Python Optimal Transport 0.9.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.datasets" href="ot.datasets.html" />
    <link rel="prev" title="ot.coot" href="ot.coot.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quick start guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.coot.html">ot.coot</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.da</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.distribution_estimation_uniform"><code class="docutils literal notranslate"><span class="pre">distribution_estimation_uniform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.emd_laplace"><code class="docutils literal notranslate"><span class="pre">emd_laplace()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.joint_OT_mapping_kernel"><code class="docutils literal notranslate"><span class="pre">joint_OT_mapping_kernel()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.joint_OT_mapping_linear"><code class="docutils literal notranslate"><span class="pre">joint_OT_mapping_linear()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.sinkhorn_l1l2_gl"><code class="docutils literal notranslate"><span class="pre">sinkhorn_l1l2_gl()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.sinkhorn_lpl1_mm"><code class="docutils literal notranslate"><span class="pre">sinkhorn_lpl1_mm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.BaseTransport"><code class="docutils literal notranslate"><span class="pre">BaseTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-basetransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.BaseTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-emdlaplacetransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDLaplaceTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-emdtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-jcpottransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.JCPOTTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-lineargwtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearGWTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-lineartransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-mappingtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.MappingTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhornl1l2transport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornL1l2Transport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhornlpl1transport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornLpl1Transport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhorntransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornTransport</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gaussian.html">ot.gaussian</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../all.html">API and modules</a></li>
      <li class="breadcrumb-item active">ot.da</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.da.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.da">
<span id="ot-da"></span><h1>ot.da<a class="headerlink" href="#module-ot.da" title="Permalink to this heading"></a></h1>
<p>Domain adaptation with optimal transport</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ot.da.distribution_estimation_uniform">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">distribution_estimation_uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#distribution_estimation_uniform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.distribution_estimation_uniform" title="Permalink to this definition"></a></dt>
<dd><p>estimates a uniform distribution from an array of samples <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The array of samples</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mu</strong> – The uniform distribution estimated from <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.emd_laplace">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">emd_laplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#emd_laplace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.emd_laplace" title="Permalink to this definition"></a></dt>
<dd><p>Solve the optimal transport problem (OT) with Laplacian regularization</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\eta \cdot \Omega_\alpha(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{x_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x_t}\)</span> are source and target samples</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_\alpha\)</span> is the Laplacian regularization term</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\Omega_\alpha = \frac{1 - \alpha}{n_s^2} \sum_{i,j}
\mathbf{S^s}_{i,j} \|T(\mathbf{x}^s_i) - T(\mathbf{x}^s_j) \|^2 +
\frac{\alpha}{n_t^2} \sum_{i,j}
\mathbf{S^t}_{i,j} \|T(\mathbf{x}^t_i) - T(\mathbf{x}^t_j) \|^2\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathbf{S^s}_{i,j}, \mathbf{S^t}_{i,j}\)</span> denoting source and target similarity
matrices and <span class="math notranslate nohighlight">\(T(\cdot)\)</span> being a barycentric mapping.</p>
<p>The algorithm used for solving the problem is the conditional gradient algorithm as proposed in
<span class="xref std std-ref">[5]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>sim</strong> (<em>string</em><em>, </em><em>optional</em>) – Type of similarity (‘knn’ or ‘gauss’) used to construct the Laplacian.</p></li>
<li><p><strong>sim_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Parameter (number of the nearest neighbors for sim=’knn’
or bandwidth for sim=’gauss’) used to compute the Laplacian.</p></li>
<li><p><strong>reg</strong> (<em>string</em>) – Type of Laplacian regularization</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term for Laplacian regularization</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term  for source domain’s importance in regularization</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner emd solver) (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-emd-laplace">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="note">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id2" role="note">
<span class="label"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></span>
<p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.joint_OT_mapping_kernel">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">joint_OT_mapping_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kerneltype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#joint_OT_mapping_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.joint_OT_mapping_kernel" title="Permalink to this definition"></a></dt>
<dd><p>Joint OT and nonlinear mapping estimation with kernels as proposed in
<span class="xref std std-ref">[8]</span>.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\gamma, L\in\mathcal{H}}\quad \|L(\mathbf{X_s}) -
n_s\gamma \mathbf{X_t}\|^2_F + \mu \langle \gamma, \mathbf{M} \rangle_F +
\eta \|L\|^2_\mathcal{H}\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) squared euclidean cost matrix between samples in
<span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> (scaled by <span class="math notranslate nohighlight">\(n_s\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a <span class="math notranslate nohighlight">\(n_s \times d\)</span> linear operator on a kernel matrix that
approximates the barycentric mapping</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are uniform source and target weights</p></li>
</ul>
<p>The problem consist in solving jointly an optimal transport matrix
<span class="math notranslate nohighlight">\(\gamma\)</span> and the nonlinear mapping that fits the barycentric mapping
<span class="math notranslate nohighlight">\(n_s\gamma \mathbf{X_t}\)</span>.</p>
<p>One can also estimate a mapping with constant bias (see supplementary
material of <span class="xref std std-ref">[8]</span>) using the bias optional argument.</p>
<p>The algorithm used for solving the problem is the block coordinate
descent that alternates between updates of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> (using conditional gradient)
and the update of <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> using a classical kernel least square solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>,</em><em>optional</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for the linear mapping L (&gt;0)</p></li>
<li><p><strong>kerneltype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>,</em><em>optional</em>) – kernel used by calling function <a class="reference internal" href="ot.utils.html#id14" title="ot.utils.kernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.utils.kernel()</span></code></a> (gaussian by default)</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Gaussian kernel bandwidth.</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>,</em><em>optional</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of BCD iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>L</strong> (<em>(ns, d) array-like</em>) – Nonlinear mapping matrix ((<span class="math notranslate nohighlight">\(n_s+1\)</span>, <cite>d</cite>) if bias)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-joint-ot-mapping-kernel">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="note">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.joint_OT_mapping_linear">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">joint_OT_mapping_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#joint_OT_mapping_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.joint_OT_mapping_linear" title="Permalink to this definition"></a></dt>
<dd><p>Joint OT and linear mapping estimation as proposed in
<span class="xref std std-ref">[8]</span>.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\gamma,L}\quad \|L(\mathbf{X_s}) - n_s\gamma \mathbf{X_t} \|^2_F +
  \mu \langle \gamma, \mathbf{M} \rangle_F + \eta \|L - \mathbf{I}\|^2_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) squared euclidean cost matrix between samples in
<span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> (scaled by <span class="math notranslate nohighlight">\(n_s\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a <span class="math notranslate nohighlight">\(d\times d\)</span> linear operator that approximates the barycentric
mapping</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{I}\)</span> is the identity matrix (neutral linear mapping)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are uniform source and target weights</p></li>
</ul>
<p>The problem consist in solving jointly an optimal transport matrix
<span class="math notranslate nohighlight">\(\gamma\)</span> and a linear mapping that fits the barycentric mapping
<span class="math notranslate nohighlight">\(n_s\gamma \mathbf{X_t}\)</span>.</p>
<p>One can also estimate a mapping with constant bias (see supplementary
material of <span class="xref std std-ref">[8]</span>) using the bias optional argument.</p>
<p>The algorithm used for solving the problem is the block coordinate
descent that alternates between updates of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> (using conditional gradient)
and the update of <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> using a classical least square solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>,</em><em>optional</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for the linear mapping L (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>,</em><em>optional</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of BCD iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>L</strong> (<em>(d, d) array-like</em>) – Linear mapping matrix ((<span class="math notranslate nohighlight">\(d+1\)</span>, <cite>d</cite>) if bias)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-joint-ot-mapping-linear">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="note">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.sinkhorn_l1l2_gl">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_l1l2_gl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_l1l2_gl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.sinkhorn_l1l2_gl" title="Permalink to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with group
lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term
<span class="math notranslate nohighlight">\(\Omega_e(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^2\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class
<cite>c</cite> in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <span class="xref std std-ref">[5, 7]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-sinkhorn-l1l2-gl">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence and
applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.optim.html#id13" title="ot.optim.gcg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.gcg</span></code></a></dt><dd><p>Generalized conditional gradient for OT problems</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.sinkhorn_lpl1_mm">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_lpl1_mm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_lpl1_mm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.sinkhorn_lpl1_mm" title="Permalink to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with non-convex
group lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega_e
(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso  regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^{1/2}_1\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class <cite>c</cite>
in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <a class="reference internal" href="../all.html#references-sinkhorn-lpl1-mm"><span class="std std-ref">[5, 7]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-sinkhorn-lpl1-mm">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.bregman.html#id87" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div></section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ot.da.BaseTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">BaseTransport</span></span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport" title="Permalink to this definition"></a></dt>
<dd><p>Base class for OTDA objects</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All estimators should specify all the parameters that can be set
at the class level in their <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as explicit keyword
arguments (no <code class="docutils literal notranslate"><span class="pre">*args</span></code> or <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>).</p>
</div>
<p>The fit method should:</p>
<ul class="simple">
<li><p>estimate a cost matrix and store it in a <cite>cost_</cite> attribute</p></li>
<li><p>estimate a coupling matrix and store it in a <cite>coupling_</cite> attribute</p></li>
<li><p>estimate distributions from source and target data and store them in
<cite>mu_s</cite> and <cite>mu_t</cite> attributes</p></li>
<li><p>store <cite>Xs</cite> and <cite>Xt</cite> in attributes to be used later on in <cite>transform</cite> and
<cite>inverse_transform</cite> methods</p></li>
</ul>
<p><cite>transform</cite> method should always get as input a <cite>Xs</cite> parameter</p>
<p><cite>inverse_transform</cite> method should always get as input a <cite>Xt</cite> parameter</p>
<p><cite>transform_labels</cite> method should always get as input a <cite>ys</cite> parameter</p>
<p><cite>inverse_transform_labels</cite> method should always get as input a <cite>yt</cite> parameter</p>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The training class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.fit_transform" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span>
and transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for training samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The source samples samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.inverse_transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The target class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.inverse_transform_labels">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.inverse_transform_labels" title="Permalink to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft source labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.transform_labels">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.transform_labels" title="Permalink to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain estimated target labels as in
<span class="xref std std-ref">[27]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="references-basetransport-transform-labels">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="note">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</aside>
</aside>
</dd></dl>

</dd></dl>

<section id="examples-using-ot-da-basetransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.BaseTransport</span></code><a class="headerlink" href="#examples-using-ot-da-basetransport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><img alt="" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT with Laplacian regularization for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><img alt="" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation with mapping estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a semi supervised domain adaptation in a 2D setting. It explicits the p..."><img alt="" src="../_images/sphx_glr_plot_otda_semi_supervised_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_semi_supervised.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-semi-supervised-py"><span class="std std-ref">OTDA unsupervised vs semi-supervised setting</span></a></p>
  <div class="sphx-glr-thumbnail-title">OTDA unsupervised vs semi-supervised setting</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><img alt="" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Linear OT mapping estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><img alt="" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation on empirical distributions</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><img alt="" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for multi-source target shift</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDLaplaceTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_type='pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_lap=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_src=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity='knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_param=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDLaplaceTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance with Laplacian regularization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_type</strong> (<em>string optional</em><em> (</em><em>default='pos'</em><em>)</em>) – Type of the regularization term: ‘pos’ and ‘disp’ for
regularization term defined in <span class="xref std std-ref">[2]</span> and
<span class="xref std std-ref">[6]</span>, respectively.</p></li>
<li><p><strong>reg_lap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Laplacian regularization parameter</p></li>
<li><p><strong>reg_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – Source relative importance in regularization</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>similarity</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;knn&quot;</em><em>)</em>) – The similarity to use either knn or gaussian</p></li>
<li><p><strong>similarity_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Parameter for the similarity: number of nearest neighbors or bandwidth
if similarity=”knn” or “gaussian”, respectively. If None is provided,
it is set to 3 or the average pairwise squared Euclidean distance, respectively.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.EMDLaplaceTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-emdlaplacetransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id11" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</aside>
<aside class="footnote brackets" id="id12" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDLaplaceTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-emdlaplacetransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDLaplaceTransport</span></code><a class="headerlink" href="#examples-using-ot-da-emdlaplacetransport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><img alt="" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT with Laplacian regularization for domain adaptation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.EMDTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.EMDTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.EMDTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-emdtransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id13" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id14" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.EMDTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-emdtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDTransport</span></code><a class="headerlink" href="#examples-using-ot-da-emdtransport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><img alt="" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT with Laplacian regularization for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><img alt="" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation with mapping estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><img alt="" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation on empirical distributions</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">JCPOTTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method for multi-source target shift based on Wasserstein barycenter algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>A set of optimal couplings between each source domain and the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)">list</a> of array-like objects, shape K x (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.proportions_">
<span class="sig-name descname"><span class="pre">proportions_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.proportions_" title="Permalink to this definition"></a></dt>
<dd><p>Estimated class proportions in the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_classes,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-jcpottransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id15" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS),
vol. 89, p.849-858, 2019.</p>
</aside>
<aside class="footnote brackets" id="id16" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Building coupling matrices from a list of source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.inverse_transform_labels">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.inverse_transform_labels" title="Permalink to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – The target class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – A list of estimated soft source labels</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)">list</a> of K array-like objects, shape K x (nk_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.transform_labels">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.transform_labels" title="Permalink to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain target labels as in
<span class="xref std std-ref">[27]</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>yt</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="references-jcpottransport-transform-labels">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id17" role="note">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</aside>
</aside>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-jcpottransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.JCPOTTransport</span></code><a class="headerlink" href="#examples-using-ot-da-jcpottransport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><img alt="" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for multi-source target shift</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.LinearGWTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearGWTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_eigs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearGWTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearGWTransport" title="Permalink to this definition"></a></dt>
<dd><p>OT Gaussian Gromov-Wasserstein linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions optimally wrt the Gromov-Wasserstein distance. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[57]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and the vector <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are
defined in <span class="xref std std-ref">[57]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sign_eigs</strong> (<em>array-like</em><em> (</em><em>n_features</em><em>)</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em>) – sign of the eigenvalues of the mapping matrix, by default all signs will
be positive. If ‘skewness’ is provided, the sign of the eigenvalues is
selected as the product of the sign of the skewness of the projected data.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="references-lineargwtransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id18" role="note">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022). Gromov–Wasserstein</p>
</aside>
</aside>
<p>distances between Gaussian distributions. Journal of Applied Probability,
59(4), 1178-1198.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearGWTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearGWTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearGWTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-lineargwtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearGWTransport</span></code><a class="headerlink" href="#examples-using-ot-da-lineargwtransport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><img alt="" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Linear OT mapping estimation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.LinearTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport" title="Permalink to this definition"></a></dt>
<dd><p>OT linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[14]</span> and discussed in remark 2.29 in
<span class="xref std std-ref">[15]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the daigonals of covariances (&gt;0)</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="references-lineartransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="note">
<span class="label"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></span>
<p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</aside>
<aside class="footnote brackets" id="id20" role="note">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.inverse_transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-lineartransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearTransport</span></code><a class="headerlink" href="#examples-using-ot-da-lineartransport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><img alt="" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Linear OT mapping estimation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.MappingTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">MappingTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport" title="Permalink to this definition"></a></dt>
<dd><p>MappingTransport: DA methods that aims at jointly estimating a optimal
transport coupling and the associated mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.001</em><em>)</em>) – Regularization term for the linear mapping <cite>L</cite> (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>kernel</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;linear&quot;</em><em>)</em>) – The kernel to use either linear or gaussian</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – The gaussian kernel parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – record log if True</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.MappingTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.mapping_">
<span class="sig-name descname"><span class="pre">mapping_</span></span><a class="headerlink" href="#ot.da.MappingTransport.mapping_" title="Permalink to this definition"></a></dt>
<dd><p>The associated mapping</p>
<ul class="simple">
<li><p>array-like, shape (<cite>n_features</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == linear</p></li>
<li><p>array-like, shape (<cite>n_source_samples</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == gaussian</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.MappingTransport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id21" role="note">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.MappingTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Builds an optimal coupling and estimates the associated mapping
from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.MappingTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-mappingtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.MappingTransport</span></code><a class="headerlink" href="#examples-using-ot-da-mappingtransport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example presents how to use MappingTransport to estimate at the same time both the couplin..."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-py"><span class="std std-ref">OT mapping estimation for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT mapping estimation for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation with mapping estimation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornL1l2Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornL1l2Transport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
L1L2 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhornl1l2transport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id22" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id23" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
<aside class="footnote brackets" id="id24" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhornl1l2transport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornL1l2Transport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhornl1l2transport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornLpl1Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornLpl1Transport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
LpL1 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.infty</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit a cost defined by
limit_max.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornLpl1Transport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhornlpl1transport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id25" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id26" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
<aside class="footnote brackets" id="id27" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornLpl1Transport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhornlpl1transport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornLpl1Transport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhornlpl1transport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><img alt="" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation on empirical distributions</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Sinkhorn Algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1000</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – The precision required to stop the optimization algorithm.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.infty</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an cost defined
by this variable</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.SinkhornTransport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhorntransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id28" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id29" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems (NIPS)
26, 2013</p>
</aside>
<aside class="footnote brackets" id="id30" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhorntransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornTransport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhorntransport" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><img alt="" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT with Laplacian regularization for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><img alt="" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation with mapping estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a semi supervised domain adaptation in a 2D setting. It explicits the p..."><img alt="" src="../_images/sphx_glr_plot_otda_semi_supervised_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_semi_supervised.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-semi-supervised-py"><span class="std std-ref">OTDA unsupervised vs semi-supervised setting</span></a></p>
  <div class="sphx-glr-thumbnail-title">OTDA unsupervised vs semi-supervised setting</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><img alt="" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation on empirical distributions</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><img alt="" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for multi-source target shift</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">UnbalancedSinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation unbalanced OT method based on sinkhorn algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Mass regularization parameter</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’,  ‘sinkhorn_stabilized’ or
‘sinkhorn_epsilon_scaling’, see those function for specific parameters</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-unbalancedsinkhorntransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id31" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id32" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">BaseTransport</span></span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd><p>Base class for OTDA objects</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All estimators should specify all the parameters that can be set
at the class level in their <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as explicit keyword
arguments (no <code class="docutils literal notranslate"><span class="pre">*args</span></code> or <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>).</p>
</div>
<p>The fit method should:</p>
<ul class="simple">
<li><p>estimate a cost matrix and store it in a <cite>cost_</cite> attribute</p></li>
<li><p>estimate a coupling matrix and store it in a <cite>coupling_</cite> attribute</p></li>
<li><p>estimate distributions from source and target data and store them in
<cite>mu_s</cite> and <cite>mu_t</cite> attributes</p></li>
<li><p>store <cite>Xs</cite> and <cite>Xt</cite> in attributes to be used later on in <cite>transform</cite> and
<cite>inverse_transform</cite> methods</p></li>
</ul>
<p><cite>transform</cite> method should always get as input a <cite>Xs</cite> parameter</p>
<p><cite>inverse_transform</cite> method should always get as input a <cite>Xt</cite> parameter</p>
<p><cite>transform_labels</cite> method should always get as input a <cite>ys</cite> parameter</p>
<p><cite>inverse_transform_labels</cite> method should always get as input a <cite>yt</cite> parameter</p>
<dl class="py method">
<dt class="sig sig-object py" id="id33">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id33" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The training class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id34">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id34" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span>
and transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for training samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The source samples samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id35">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id35" title="Permalink to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The target class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id36">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id36" title="Permalink to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft source labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id37">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id37" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id38">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id38" title="Permalink to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain estimated target labels as in
<span class="xref std std-ref">[27]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="id39">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id40" role="note">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</aside>
</aside>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id41">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDLaplaceTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_type='pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_lap=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_src=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity='knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_param=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id41" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance with Laplacian regularization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_type</strong> (<em>string optional</em><em> (</em><em>default='pos'</em><em>)</em>) – Type of the regularization term: ‘pos’ and ‘disp’ for
regularization term defined in <span class="xref std std-ref">[2]</span> and
<span class="xref std std-ref">[6]</span>, respectively.</p></li>
<li><p><strong>reg_lap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Laplacian regularization parameter</p></li>
<li><p><strong>reg_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – Source relative importance in regularization</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>similarity</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;knn&quot;</em><em>)</em>) – The similarity to use either knn or gaussian</p></li>
<li><p><strong>similarity_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Parameter for the similarity: number of nearest neighbors or bandwidth
if similarity=”knn” or “gaussian”, respectively. If None is provided,
it is set to 3 or the average pairwise squared Euclidean distance, respectively.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id42">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id42" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id43">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id44" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id45" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</aside>
<aside class="footnote brackets" id="id46" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id47">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id47" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id48">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id48" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id49">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id49" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id50">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id51" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id52" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id53">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id53" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id54">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">JCPOTTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id54" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method for multi-source target shift based on Wasserstein barycenter algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id55">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id55" title="Permalink to this definition"></a></dt>
<dd><p>A set of optimal couplings between each source domain and the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)">list</a> of array-like objects, shape K x (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id56">
<span class="sig-name descname"><span class="pre">proportions_</span></span><a class="headerlink" href="#id56" title="Permalink to this definition"></a></dt>
<dd><p>Estimated class proportions in the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_classes,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id57">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id57" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id58">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id59" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS),
vol. 89, p.849-858, 2019.</p>
</aside>
<aside class="footnote brackets" id="id60" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id61">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id61" title="Permalink to this definition"></a></dt>
<dd><p>Building coupling matrices from a list of source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id62">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id62" title="Permalink to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – The target class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – A list of estimated soft source labels</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)">list</a> of K array-like objects, shape K x (nk_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id63">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id63" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id64">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id64" title="Permalink to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain target labels as in
<span class="xref std std-ref">[27]</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>yt</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="id65">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id66" role="note">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</aside>
</aside>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id67">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearGWTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_eigs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearGWTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id67" title="Permalink to this definition"></a></dt>
<dd><p>OT Gaussian Gromov-Wasserstein linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions optimally wrt the Gromov-Wasserstein distance. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[57]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and the vector <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are
defined in <span class="xref std std-ref">[57]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sign_eigs</strong> (<em>array-like</em><em> (</em><em>n_features</em><em>)</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em>) – sign of the eigenvalues of the mapping matrix, by default all signs will
be positive. If ‘skewness’ is provided, the sign of the eigenvalues is
selected as the product of the sign of the skewness of the projected data.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="id68">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id69" role="note">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022). Gromov–Wasserstein</p>
</aside>
</aside>
<p>distances between Gaussian distributions. Journal of Applied Probability,
59(4), 1178-1198.</p>
<dl class="py method">
<dt class="sig sig-object py" id="id70">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearGWTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id70" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id71">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id71" title="Permalink to this definition"></a></dt>
<dd><p>OT linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[14]</span> and discussed in remark 2.29 in
<span class="xref std std-ref">[15]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the daigonals of covariances (&gt;0)</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="id72">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id73" role="note">
<span class="label"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></span>
<p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</aside>
<aside class="footnote brackets" id="id74" role="note">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id75">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id75" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id76">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id76" title="Permalink to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id77">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id77" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id78">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">MappingTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id78" title="Permalink to this definition"></a></dt>
<dd><p>MappingTransport: DA methods that aims at jointly estimating a optimal
transport coupling and the associated mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.001</em><em>)</em>) – Regularization term for the linear mapping <cite>L</cite> (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>kernel</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;linear&quot;</em><em>)</em>) – The kernel to use either linear or gaussian</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – The gaussian kernel parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – record log if True</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id79">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id79" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id80">
<span class="sig-name descname"><span class="pre">mapping_</span></span><a class="headerlink" href="#id80" title="Permalink to this definition"></a></dt>
<dd><p>The associated mapping</p>
<ul class="simple">
<li><p>array-like, shape (<cite>n_features</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == linear</p></li>
<li><p>array-like, shape (<cite>n_source_samples</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == gaussian</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id81">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id81" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id82" role="note">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id83">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id83" title="Permalink to this definition"></a></dt>
<dd><p>Builds an optimal coupling and estimates the associated mapping
from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id84">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id84" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id85">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornL1l2Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id85" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
L1L2 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id86">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id86" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id87">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id87" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id88">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id89" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id90" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
<aside class="footnote brackets" id="id91" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id92">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id92" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id93">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornLpl1Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id93" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
LpL1 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.infty</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit a cost defined by
limit_max.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id94">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id94" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id95">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id96" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id97" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
<aside class="footnote brackets" id="id98" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id99">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id99" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id100">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id100" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Sinkhorn Algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1000</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – The precision required to stop the optimization algorithm.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.infty</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an cost defined
by this variable</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id101">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id101" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id102">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id102" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id103">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id104" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id105" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems (NIPS)
26, 2013</p>
</aside>
<aside class="footnote brackets" id="id106" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id107">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id107" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id108">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">UnbalancedSinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id108" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation unbalanced OT method based on sinkhorn algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Mass regularization parameter</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’,  ‘sinkhorn_stabilized’ or
‘sinkhorn_epsilon_scaling’, see those function for specific parameters</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id109">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id109" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id110">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id110" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id111">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id112" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id113" role="note">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id114">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id114" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id115">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">distribution_estimation_uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#distribution_estimation_uniform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id115" title="Permalink to this definition"></a></dt>
<dd><p>estimates a uniform distribution from an array of samples <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The array of samples</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mu</strong> – The uniform distribution estimated from <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id116">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">emd_laplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#emd_laplace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id116" title="Permalink to this definition"></a></dt>
<dd><p>Solve the optimal transport problem (OT) with Laplacian regularization</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\eta \cdot \Omega_\alpha(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{x_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x_t}\)</span> are source and target samples</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_\alpha\)</span> is the Laplacian regularization term</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\Omega_\alpha = \frac{1 - \alpha}{n_s^2} \sum_{i,j}
\mathbf{S^s}_{i,j} \|T(\mathbf{x}^s_i) - T(\mathbf{x}^s_j) \|^2 +
\frac{\alpha}{n_t^2} \sum_{i,j}
\mathbf{S^t}_{i,j} \|T(\mathbf{x}^t_i) - T(\mathbf{x}^t_j) \|^2\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathbf{S^s}_{i,j}, \mathbf{S^t}_{i,j}\)</span> denoting source and target similarity
matrices and <span class="math notranslate nohighlight">\(T(\cdot)\)</span> being a barycentric mapping.</p>
<p>The algorithm used for solving the problem is the conditional gradient algorithm as proposed in
<span class="xref std std-ref">[5]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>sim</strong> (<em>string</em><em>, </em><em>optional</em>) – Type of similarity (‘knn’ or ‘gauss’) used to construct the Laplacian.</p></li>
<li><p><strong>sim_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Parameter (number of the nearest neighbors for sim=’knn’
or bandwidth for sim=’gauss’) used to compute the Laplacian.</p></li>
<li><p><strong>reg</strong> (<em>string</em>) – Type of Laplacian regularization</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term for Laplacian regularization</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term  for source domain’s importance in regularization</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner emd solver) (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id117">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id118" role="note">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id119" role="note">
<span class="label"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></span>
<p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id120">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">joint_OT_mapping_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kerneltype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#joint_OT_mapping_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id120" title="Permalink to this definition"></a></dt>
<dd><p>Joint OT and nonlinear mapping estimation with kernels as proposed in
<span class="xref std std-ref">[8]</span>.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\gamma, L\in\mathcal{H}}\quad \|L(\mathbf{X_s}) -
n_s\gamma \mathbf{X_t}\|^2_F + \mu \langle \gamma, \mathbf{M} \rangle_F +
\eta \|L\|^2_\mathcal{H}\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) squared euclidean cost matrix between samples in
<span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> (scaled by <span class="math notranslate nohighlight">\(n_s\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a <span class="math notranslate nohighlight">\(n_s \times d\)</span> linear operator on a kernel matrix that
approximates the barycentric mapping</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are uniform source and target weights</p></li>
</ul>
<p>The problem consist in solving jointly an optimal transport matrix
<span class="math notranslate nohighlight">\(\gamma\)</span> and the nonlinear mapping that fits the barycentric mapping
<span class="math notranslate nohighlight">\(n_s\gamma \mathbf{X_t}\)</span>.</p>
<p>One can also estimate a mapping with constant bias (see supplementary
material of <span class="xref std std-ref">[8]</span>) using the bias optional argument.</p>
<p>The algorithm used for solving the problem is the block coordinate
descent that alternates between updates of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> (using conditional gradient)
and the update of <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> using a classical kernel least square solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>,</em><em>optional</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for the linear mapping L (&gt;0)</p></li>
<li><p><strong>kerneltype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>,</em><em>optional</em>) – kernel used by calling function <a class="reference internal" href="ot.utils.html#id14" title="ot.utils.kernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.utils.kernel()</span></code></a> (gaussian by default)</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Gaussian kernel bandwidth.</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>,</em><em>optional</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of BCD iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>L</strong> (<em>(ns, d) array-like</em>) – Nonlinear mapping matrix ((<span class="math notranslate nohighlight">\(n_s+1\)</span>, <cite>d</cite>) if bias)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id121">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id122" role="note">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id123">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">joint_OT_mapping_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#joint_OT_mapping_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id123" title="Permalink to this definition"></a></dt>
<dd><p>Joint OT and linear mapping estimation as proposed in
<span class="xref std std-ref">[8]</span>.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\gamma,L}\quad \|L(\mathbf{X_s}) - n_s\gamma \mathbf{X_t} \|^2_F +
  \mu \langle \gamma, \mathbf{M} \rangle_F + \eta \|L - \mathbf{I}\|^2_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) squared euclidean cost matrix between samples in
<span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> (scaled by <span class="math notranslate nohighlight">\(n_s\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a <span class="math notranslate nohighlight">\(d\times d\)</span> linear operator that approximates the barycentric
mapping</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{I}\)</span> is the identity matrix (neutral linear mapping)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are uniform source and target weights</p></li>
</ul>
<p>The problem consist in solving jointly an optimal transport matrix
<span class="math notranslate nohighlight">\(\gamma\)</span> and a linear mapping that fits the barycentric mapping
<span class="math notranslate nohighlight">\(n_s\gamma \mathbf{X_t}\)</span>.</p>
<p>One can also estimate a mapping with constant bias (see supplementary
material of <span class="xref std std-ref">[8]</span>) using the bias optional argument.</p>
<p>The algorithm used for solving the problem is the block coordinate
descent that alternates between updates of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> (using conditional gradient)
and the update of <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> using a classical least square solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>,</em><em>optional</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for the linear mapping L (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>,</em><em>optional</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of BCD iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>L</strong> (<em>(d, d) array-like</em>) – Linear mapping matrix ((<span class="math notranslate nohighlight">\(d+1\)</span>, <cite>d</cite>) if bias)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id124">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id125" role="note">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id126">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_l1l2_gl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_l1l2_gl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id126" title="Permalink to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with group
lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term
<span class="math notranslate nohighlight">\(\Omega_e(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^2\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class
<cite>c</cite> in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <span class="xref std std-ref">[5, 7]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id127">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id128" role="note">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id129" role="note">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence and
applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.optim.html#id13" title="ot.optim.gcg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.gcg</span></code></a></dt><dd><p>Generalized conditional gradient for OT problems</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id130">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_lpl1_mm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_lpl1_mm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id130" title="Permalink to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with non-convex
group lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega_e
(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso  regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^{1/2}_1\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class <cite>c</cite>
in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <a class="reference internal" href="../all.html#references-sinkhorn-lpl1-mm"><span class="std std-ref">[5, 7]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id131">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id132" role="note">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id133" role="note">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.bregman.html#id87" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.coot.html" class="btn btn-neutral float-left" title="ot.coot" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.datasets.html" class="btn btn-neutral float-right" title="ot.datasets" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Rémi Flamary, Nicolas Courty.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span>
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>