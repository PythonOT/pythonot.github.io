<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.da &mdash; POT Python Optimal Transport 0.8.2 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.dr" href="ot.dr.html" />
    <link rel="prev" title="ot.optim" href="ot.optim.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> POT Python Optimal Transport
            <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.8.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quick start guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.da</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-ot-mapping-linear">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.OT_mapping_linear</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-basetransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.BaseTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-emdlaplacetransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDLaplaceTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-emdtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-jcpottransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.JCPOTTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-lineartransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-mappingtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.MappingTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhornl1l2transport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornL1l2Transport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhornlpl1transport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornLpl1Transport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhorntransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornTransport</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../.github/CONTRIBUTING.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../.github/CODE_OF_CONDUCT.html">Code of Conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../all.html">API and modules</a> &raquo;</li>
      <li>ot.da</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.da.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.da">
<span id="ot-da"></span><h1>ot.da<a class="headerlink" href="#module-ot.da" title="Permalink to this headline"></a></h1>
<p>Domain adaptation with optimal transport</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ot.da.OT_mapping_linear">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">OT_mapping_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#OT_mapping_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.OT_mapping_linear" title="Permalink to this definition"></a></dt>
<dd><p>Return OT linear operator between samples.</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<a class="reference internal" href="#references-ot-mapping-linear"><span class="std std-ref">[14]</span></a> and discussed in remark 2.29 in
<a class="reference internal" href="#references-ot-mapping-linear"><span class="std std-ref">[15]</span></a>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the diagonals of covariances (&gt;0)</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(d, d) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, d) array-like</em>) – bias</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-ot-mapping-linear">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">14</span></dt>
<dd><p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</dd>
<dt class="label" id="id2"><span class="brackets">15</span></dt>
<dd><p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</dd>
</dl>
</dd></dl>

<section id="examples-using-ot-da-ot-mapping-linear">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.OT_mapping_linear</span></code><a class="headerlink" href="#examples-using-ot-da-ot-mapping-linear" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><figure class="align-default" id="id34">
<img alt="Linear OT mapping estimation" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></span><a class="headerlink" href="#id34" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.distribution_estimation_uniform">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">distribution_estimation_uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#distribution_estimation_uniform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.distribution_estimation_uniform" title="Permalink to this definition"></a></dt>
<dd><p>estimates a uniform distribution from an array of samples <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The array of samples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mu</strong> – The uniform distribution estimated from <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.emd_laplace">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">emd_laplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#emd_laplace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.emd_laplace" title="Permalink to this definition"></a></dt>
<dd><p>Solve the optimal transport problem (OT) with Laplacian regularization</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\eta \cdot \Omega_\alpha(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{x_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x_t}\)</span> are source and target samples</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_\alpha\)</span> is the Laplacian regularization term</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\Omega_\alpha = \frac{1 - \alpha}{n_s^2} \sum_{i,j}
\mathbf{S^s}_{i,j} \|T(\mathbf{x}^s_i) - T(\mathbf{x}^s_j) \|^2 +
\frac{\alpha}{n_t^2} \sum_{i,j}
\mathbf{S^t}_{i,j} \|T(\mathbf{x}^t_i) - T(\mathbf{x}^t_j) \|^2\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathbf{S^s}_{i,j}, \mathbf{S^t}_{i,j}\)</span> denoting source and target similarity
matrices and <span class="math notranslate nohighlight">\(T(\cdot)\)</span> being a barycentric mapping.</p>
<p>The algorithm used for solving the problem is the conditional gradient algorithm as proposed in
<a class="reference internal" href="#references-emd-laplace"><span class="std std-ref">[5]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>sim</strong> (<em>string</em><em>, </em><em>optional</em>) – Type of similarity (‘knn’ or ‘gauss’) used to construct the Laplacian.</p></li>
<li><p><strong>sim_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Parameter (number of the nearest neighbors for sim=’knn’
or bandwidth for sim=’gauss’) used to compute the Laplacian.</p></li>
<li><p><strong>reg</strong> (<em>string</em>) – Type of Laplacian regularization</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) – Regularization term for Laplacian regularization</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) – Regularization term  for source domain’s importance in regularization</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner emd solver) (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-emd-laplace">References</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">5</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id4"><span class="brackets">30</span></dt>
<dd><p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.joint_OT_mapping_kernel">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">joint_OT_mapping_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kerneltype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#joint_OT_mapping_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.joint_OT_mapping_kernel" title="Permalink to this definition"></a></dt>
<dd><p>Joint OT and nonlinear mapping estimation with kernels as proposed in
<a class="reference internal" href="#references-joint-ot-mapping-kernel"><span class="std std-ref">[8]</span></a>.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\gamma, L\in\mathcal{H}}\quad \|L(\mathbf{X_s}) -
n_s\gamma \mathbf{X_t}\|^2_F + \mu \langle \gamma, \mathbf{M} \rangle_F +
\eta \|L\|^2_\mathcal{H}\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) squared euclidean cost matrix between samples in
<span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> (scaled by <span class="math notranslate nohighlight">\(n_s\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a <span class="math notranslate nohighlight">\(n_s \times d\)</span> linear operator on a kernel matrix that
approximates the barycentric mapping</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are uniform source and target weights</p></li>
</ul>
<p>The problem consist in solving jointly an optimal transport matrix
<span class="math notranslate nohighlight">\(\gamma\)</span> and the nonlinear mapping that fits the barycentric mapping
<span class="math notranslate nohighlight">\(n_s\gamma \mathbf{X_t}\)</span>.</p>
<p>One can also estimate a mapping with constant bias (see supplementary
material of <a class="reference internal" href="#references-joint-ot-mapping-kernel"><span class="std std-ref">[8]</span></a>) using the bias optional argument.</p>
<p>The algorithm used for solving the problem is the block coordinate
descent that alternates between updates of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> (using conditionnal gradient)
and the update of <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> using a classical kernel least square solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>,</em><em>optional</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for the linear mapping L (&gt;0)</p></li>
<li><p><strong>kerneltype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a><em>,</em><em>optional</em>) – kernel used by calling function <a class="reference internal" href="ot.utils.html#ot.utils.kernel" title="ot.utils.kernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.utils.kernel()</span></code></a> (gaussian by default)</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Gaussian kernel bandwidth.</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>,</em><em>optional</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of BCD iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>L</strong> (<em>(ns, d) array-like</em>) – Nonlinear mapping matrix ((<span class="math notranslate nohighlight">\(n_s+1\)</span>, <cite>d</cite>) if bias)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-joint-ot-mapping-kernel">References</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets">8</span></dt>
<dd><p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.joint_OT_mapping_linear">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">joint_OT_mapping_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#joint_OT_mapping_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.joint_OT_mapping_linear" title="Permalink to this definition"></a></dt>
<dd><p>Joint OT and linear mapping estimation as proposed in
<a class="reference internal" href="#references-joint-ot-mapping-linear"><span class="std std-ref">[8]</span></a>.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\gamma,L}\quad \|L(\mathbf{X_s}) - n_s\gamma \mathbf{X_t} \|^2_F +
  \mu \langle \gamma, \mathbf{M} \rangle_F + \eta \|L - \mathbf{I}\|^2_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) squared euclidean cost matrix between samples in
<span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> (scaled by <span class="math notranslate nohighlight">\(n_s\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a <span class="math notranslate nohighlight">\(d\times d\)</span> linear operator that approximates the barycentric
mapping</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{I}\)</span> is the identity matrix (neutral linear mapping)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are uniform source and target weights</p></li>
</ul>
<p>The problem consist in solving jointly an optimal transport matrix
<span class="math notranslate nohighlight">\(\gamma\)</span> and a linear mapping that fits the barycentric mapping
<span class="math notranslate nohighlight">\(n_s\gamma \mathbf{X_t}\)</span>.</p>
<p>One can also estimate a mapping with constant bias (see supplementary
material of <a class="reference internal" href="#references-joint-ot-mapping-linear"><span class="std std-ref">[8]</span></a>) using the bias optional argument.</p>
<p>The algorithm used for solving the problem is the block coordinate
descent that alternates between updates of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> (using conditionnal gradient)
and the update of <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> using a classical least square solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>,</em><em>optional</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for the linear mapping L (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>,</em><em>optional</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of BCD iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>L</strong> (<em>(d, d) array-like</em>) – Linear mapping matrix ((<span class="math notranslate nohighlight">\(d+1\)</span>, <cite>d</cite>) if bias)</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-joint-ot-mapping-linear">References</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets">8</span></dt>
<dd><p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.sinkhorn_l1l2_gl">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_l1l2_gl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_l1l2_gl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.sinkhorn_l1l2_gl" title="Permalink to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with group
lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term
<span class="math notranslate nohighlight">\(\Omega_e(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso regulaization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^2\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class
<cite>c</cite> in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalised conditional
gradient as proposed in <a class="reference internal" href="#references-sinkhorn-l1l2-gl"><span class="std std-ref">[5, 7]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-sinkhorn-l1l2-gl">References</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets">5</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id8"><span class="brackets">7</span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence and
applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.optim.html#ot.optim.gcg" title="ot.optim.gcg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.gcg</span></code></a></dt><dd><p>Generalized conditional gradient for OT problems</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.sinkhorn_lpl1_mm">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_lpl1_mm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_lpl1_mm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.sinkhorn_lpl1_mm" title="Permalink to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with nonconvex
group lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega_e
(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso  regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^{1/2}_1\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class <cite>c</cite>
in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <a class="reference internal" href="#references-sinkhorn-lpl1-mm"><span class="std std-ref">[5, 7]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-sinkhorn-lpl1-mm">References</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">5</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id10"><span class="brackets">7</span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#ot.optim.cg" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div></section>
</section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ot.da.BaseTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">BaseTransport</span></span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport" title="Permalink to this definition"></a></dt>
<dd><p>Base class for OTDA objects</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All estimators should specify all the parameters that can be set
at the class level in their <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as explicit keyword
arguments (no <code class="docutils literal notranslate"><span class="pre">*args</span></code> or <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>).</p>
</div>
<p>The fit method should:</p>
<ul class="simple">
<li><p>estimate a cost matrix and store it in a <cite>cost_</cite> attribute</p></li>
<li><p>estimate a coupling matrix and store it in a <cite>coupling_</cite> attribute</p></li>
<li><p>estimate distributions from source and target data and store them in
<cite>mu_s</cite> and <cite>mu_t</cite> attributes</p></li>
<li><p>store <cite>Xs</cite> and <cite>Xt</cite> in attributes to be used later on in <cite>transform</cite> and
<cite>inverse_transform</cite> methods</p></li>
</ul>
<p><cite>transform</cite> method should always get as input a <cite>Xs</cite> parameter</p>
<p><cite>inverse_transform</cite> method should always get as input a <cite>Xt</cite> parameter</p>
<p><cite>transform_labels</cite> method should always get as input a <cite>ys</cite> parameter</p>
<p><cite>inverse_transform_labels</cite> method should always get as input a <cite>yt</cite> parameter</p>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The training class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.fit_transform" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span>
and transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for training samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The source samples samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.inverse_transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The target class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.inverse_transform_labels">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.inverse_transform_labels" title="Permalink to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft source labels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.transform_labels">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.transform_labels" title="Permalink to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain estimated target labels as in
<a class="reference internal" href="#references-basetransport-transform-labels"><span class="std std-ref">[27]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="references-basetransport-transform-labels">References</p>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets">27</span></dt>
<dd><p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<section id="examples-using-ot-da-basetransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.BaseTransport</span></code><a class="headerlink" href="#examples-using-ot-da-basetransport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><figure class="align-default" id="id35">
<img alt="Linear OT mapping estimation" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></span><a class="headerlink" href="#id35" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><figure class="align-default" id="id36">
<img alt="OT with Laplacian regularization for domain adaptation" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></span><a class="headerlink" href="#id36" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><figure class="align-default" id="id37">
<img alt="OT for image color adaptation" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></span><a class="headerlink" href="#id37" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><figure class="align-default" id="id38">
<img alt="OT for image color adaptation with mapping estimation" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></span><a class="headerlink" href="#id38" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a semi supervised domain adaptation in a 2D setting. It explicits the p..."><figure class="align-default" id="id39">
<img alt="OTDA unsupervised vs semi-supervised setting" src="../_images/sphx_glr_plot_otda_semi_supervised_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_semi_supervised.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-semi-supervised-py"><span class="std std-ref">OTDA unsupervised vs semi-supervised setting</span></a></span><a class="headerlink" href="#id39" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><figure class="align-default" id="id40">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id40" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><figure class="align-default" id="id41">
<img alt="OT for domain adaptation on empirical distributions" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></span><a class="headerlink" href="#id41" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><figure class="align-default" id="id42">
<img alt="OT for multi-source target shift" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></span><a class="headerlink" href="#id42" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDLaplaceTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_type='pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_lap=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_src=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity='knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_param=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDLaplaceTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance with Laplacian regularization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_type</strong> (<em>string optional</em><em> (</em><em>default='pos'</em><em>)</em>) – Type of the regularization term: ‘pos’ and ‘disp’ for
regularization term defined in <a class="reference internal" href="#references-emdlaplacetransport"><span class="std std-ref">[2]</span></a> and
<a class="reference internal" href="#references-emdlaplacetransport"><span class="std std-ref">[6]</span></a>, respectively.</p></li>
<li><p><strong>reg_lap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Laplacian regularization parameter</p></li>
<li><p><strong>reg_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – Source relative importance in regularization</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>similarity</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;knn&quot;</em><em>)</em>) – The similarity to use either knn or gaussian</p></li>
<li><p><strong>similarity_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Parameter for the similarity: number of nearest neighbors or bandwidth
if similarity=”knn” or “gaussian”, respectively. If None is provided,
it is set to 3 or the average pairwise squared Euclidean distance, respectively.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <a class="reference internal" href="#references-emdlaplacetransport"><span class="std std-ref">[6]</span></a>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.EMDLaplaceTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-emdlaplacetransport">References</p>
<dl class="footnote brackets">
<dt class="label" id="id12"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id13"><span class="brackets">2</span></dt>
<dd><p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</dd>
<dt class="label" id="id14"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDLaplaceTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-emdlaplacetransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDLaplaceTransport</span></code><a class="headerlink" href="#examples-using-ot-da-emdlaplacetransport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><figure class="align-default" id="id43">
<img alt="OT with Laplacian regularization for domain adaptation" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></span><a class="headerlink" href="#id43" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.EMDTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <a class="reference internal" href="#references-emdtransport"><span class="std std-ref">[6]</span></a>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.EMDTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.EMDTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-emdtransport">References</p>
<dl class="footnote brackets">
<dt class="label" id="id15"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id16"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.EMDTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-emdtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDTransport</span></code><a class="headerlink" href="#examples-using-ot-da-emdtransport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><figure class="align-default" id="id44">
<img alt="OT with Laplacian regularization for domain adaptation" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></span><a class="headerlink" href="#id44" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><figure class="align-default" id="id45">
<img alt="OT for image color adaptation" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></span><a class="headerlink" href="#id45" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><figure class="align-default" id="id46">
<img alt="OT for image color adaptation with mapping estimation" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></span><a class="headerlink" href="#id46" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><figure class="align-default" id="id47">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id47" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><figure class="align-default" id="id48">
<img alt="OT for domain adaptation on empirical distributions" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></span><a class="headerlink" href="#id48" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">JCPOTTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method for multi-source target shift based on Wasserstein barycenter algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <a class="reference internal" href="#references-jcpottransport"><span class="std std-ref">[6]</span></a>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>A set of optimal couplings between each source domain and the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of array-like objects, shape K x (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.proportions_">
<span class="sig-name descname"><span class="pre">proportions_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.proportions_" title="Permalink to this definition"></a></dt>
<dd><p>Estimated class proportions in the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_classes,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-jcpottransport">References</p>
<dl class="footnote brackets">
<dt class="label" id="id17"><span class="brackets">1</span></dt>
<dd><p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS),
vol. 89, p.849-858, 2019.</p>
</dd>
<dt class="label" id="id18"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Building coupling matrices from a list of source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.inverse_transform_labels">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.inverse_transform_labels" title="Permalink to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – The target class labels</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_ys</strong> – A list of estimated soft source labels</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of K array-like objects, shape K x (nk_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.transform_labels">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.transform_labels" title="Permalink to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain target labels as in
<a class="reference internal" href="#references-jcpottransport-transform-labels"><span class="std std-ref">[27]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ys</strong> (<em>list of K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>yt</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="references-jcpottransport-transform-labels">References</p>
<dl class="footnote brackets">
<dt class="label" id="id19"><span class="brackets">27</span></dt>
<dd><p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-jcpottransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.JCPOTTransport</span></code><a class="headerlink" href="#examples-using-ot-da-jcpottransport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><figure class="align-default" id="id49">
<img alt="OT for multi-source target shift" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></span><a class="headerlink" href="#id49" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.LinearTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport" title="Permalink to this definition"></a></dt>
<dd><p>OT linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<a class="reference internal" href="#references-lineartransport"><span class="std std-ref">[14]</span></a> and discussed in remark 2.29 in
<a class="reference internal" href="#references-lineartransport"><span class="std std-ref">[15]</span></a>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the daigonals of covariances (&gt;0)</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="references-lineartransport">References</p>
<dl class="footnote brackets">
<dt class="label" id="id20"><span class="brackets">14</span></dt>
<dd><p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</dd>
<dt class="label" id="id21"><span class="brackets">15</span></dt>
<dd><p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.inverse_transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-lineartransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearTransport</span></code><a class="headerlink" href="#examples-using-ot-da-lineartransport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><figure class="align-default" id="id50">
<img alt="Linear OT mapping estimation" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></span><a class="headerlink" href="#id50" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.MappingTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">MappingTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport" title="Permalink to this definition"></a></dt>
<dd><p>MappingTransport: DA methods that aims at jointly estimating a optimal
transport coupling and the associated mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.001</em><em>)</em>) – Regularization term for the linear mapping <cite>L</cite> (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>kernel</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;linear&quot;</em><em>)</em>) – The kernel to use either linear or gaussian</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – The gaussian kernel parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – record log if True</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.MappingTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.mapping_">
<span class="sig-name descname"><span class="pre">mapping_</span></span><a class="headerlink" href="#ot.da.MappingTransport.mapping_" title="Permalink to this definition"></a></dt>
<dd><p>The associated mapping</p>
<ul class="simple">
<li><p>array-like, shape (<cite>n_features</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == linear</p></li>
<li><p>array-like, shape (<cite>n_source_samples</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == gaussian</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.MappingTransport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id22"><span class="brackets">8</span></dt>
<dd><p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.MappingTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Builds an optimal coupling and estimates the associated mapping
from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.MappingTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-mappingtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.MappingTransport</span></code><a class="headerlink" href="#examples-using-ot-da-mappingtransport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example presents how to use MappingTransport to estimate at the same time both the couplin..."><figure class="align-default" id="id51">
<img alt="OT mapping estimation for domain adaptation" src="../_images/sphx_glr_plot_otda_mapping_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-py"><span class="std std-ref">OT mapping estimation for domain adaptation</span></a></span><a class="headerlink" href="#id51" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><figure class="align-default" id="id52">
<img alt="OT for image color adaptation with mapping estimation" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></span><a class="headerlink" href="#id52" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornL1l2Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornL1l2Transport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
L1L2 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <a class="reference internal" href="#references-sinkhornl1l2transport"><span class="std std-ref">[6]</span></a>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhornl1l2transport">References</p>
<dl class="footnote brackets">
<dt class="label" id="id23"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id24"><span class="brackets">2</span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
<dt class="label" id="id25"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhornl1l2transport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornL1l2Transport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhornl1l2transport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><figure class="align-default" id="id53">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id53" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornLpl1Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornLpl1Transport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
LpL1 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <a class="reference internal" href="#references-sinkhornlpl1transport"><span class="std std-ref">[6]</span></a>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.infty</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit a cost defined by
limit_max.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornLpl1Transport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhornlpl1transport">References</p>
<dl class="footnote brackets">
<dt class="label" id="id26"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id27"><span class="brackets">2</span></dt>
<dd><p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</dd>
<dt class="label" id="id28"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornLpl1Transport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhornlpl1transport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornLpl1Transport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhornlpl1transport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><figure class="align-default" id="id54">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id54" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><figure class="align-default" id="id55">
<img alt="OT for domain adaptation on empirical distributions" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></span><a class="headerlink" href="#id55" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Sinkhorn Algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1000</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – The precision required to stop the optimization algorithm.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <a class="reference internal" href="#references-sinkhorntransport"><span class="std std-ref">[6]</span></a>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.infty</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an cost defined
by this variable</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.SinkhornTransport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhorntransport">References</p>
<dl class="footnote brackets">
<dt class="label" id="id29"><span class="brackets">1</span></dt>
<dd><p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</dd>
<dt class="label" id="id30"><span class="brackets">2</span></dt>
<dd><p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems (NIPS)
26, 2013</p>
</dd>
<dt class="label" id="id31"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhorntransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornTransport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhorntransport" title="Permalink to this headline"></a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian re..."><figure class="align-default" id="id56">
<img alt="OT with Laplacian regularization for domain adaptation" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></span><a class="headerlink" href="#id56" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as..."><figure class="align-default" id="id57">
<img alt="OT for image color adaptation" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></span><a class="headerlink" href="#id57" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><figure class="align-default" id="id58">
<img alt="OT for image color adaptation with mapping estimation" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></span><a class="headerlink" href="#id58" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a semi supervised domain adaptation in a 2D setting. It explicits the p..."><figure class="align-default" id="id59">
<img alt="OTDA unsupervised vs semi-supervised setting" src="../_images/sphx_glr_plot_otda_semi_supervised_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_semi_supervised.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-semi-supervised-py"><span class="std std-ref">OTDA unsupervised vs semi-supervised setting</span></a></span><a class="headerlink" href="#id59" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently..."><figure class="align-default" id="id60">
<img alt="OT for domain adaptation" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></span><a class="headerlink" href="#id60" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicits the problem of domain..."><figure class="align-default" id="id61">
<img alt="OT for domain adaptation on empirical distributions" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></span><a class="headerlink" href="#id61" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><figure class="align-default" id="id62">
<img alt="OT for multi-source target shift" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></span><a class="headerlink" href="#id62" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">UnbalancedSinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport" title="Permalink to this definition"></a></dt>
<dd><p>Domain Adaptation unbalanced OT method based on sinkhorn algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Mass regularization parameter</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’,  ‘sinkhorn_stabilized’ or
‘sinkhorn_epsilon_scaling’, see those function for specific parameters</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <a class="reference internal" href="#references-unbalancedsinkhorntransport"><span class="std std-ref">[6]</span></a>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.coupling_" title="Permalink to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.log_" title="Permalink to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-unbalancedsinkhorntransport">References</p>
<dl class="footnote brackets">
<dt class="label" id="id32"><span class="brackets">1</span></dt>
<dd><p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</dd>
<dt class="label" id="id33"><span class="brackets">6</span></dt>
<dd><p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.fit" title="Permalink to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="sphx-glr-clear"></div></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.optim.html" class="btn btn-neutral float-left" title="ot.optim" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.dr.html" class="btn btn-neutral float-right" title="ot.dr" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Rémi Flamary, Nicolas Courty.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing -->
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Python Optimal Transport</span>
      versions
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions"><!-- Inserted RTD Footer -->

<div class="injected">

      
      
      <dl>
        <dt>Versions</dt>

        <dd><a href="https://pythonot.github.io/">Release</a></dd>
        
        <dd><a href="https://pythonot.github.io/master">Development</a></dd>
       
        
        
      </dl>
      

    
      
      <dl>
        <dt>On GitHub</dt>
        <dd>
          <a href="https://github.com/PythonOT/POT">Code on Github</a>
        </dd>
        
      </dl>
      
    
      
      

      <hr>
      


</div>
</div>
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>