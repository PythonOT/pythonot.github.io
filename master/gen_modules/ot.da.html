

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.da &mdash; POT Python Optimal Transport 0.9.6.post1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=98b74656"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.datasets" href="ot.datasets.html" />
    <link rel="prev" title="ot.coot" href="ot.coot.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/plot_quickstart_guide.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.batch.html">ot.batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.coot.html">ot.coot</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.da</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.distribution_estimation_uniform"><code class="docutils literal notranslate"><span class="pre">distribution_estimation_uniform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.emd_laplace"><code class="docutils literal notranslate"><span class="pre">emd_laplace()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.sinkhorn_l1l2_gl"><code class="docutils literal notranslate"><span class="pre">sinkhorn_l1l2_gl()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.sinkhorn_lpl1_mm"><code class="docutils literal notranslate"><span class="pre">sinkhorn_lpl1_mm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ot.da.BaseTransport"><code class="docutils literal notranslate"><span class="pre">BaseTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-basetransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.BaseTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-emdlaplacetransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDLaplaceTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-emdtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-jcpottransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.JCPOTTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-lineargwtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearGWTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-lineartransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-mappingtransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.MappingTransport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhornl1l2transport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornL1l2Transport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhornlpl1transport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornLpl1Transport</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-da-sinkhorntransport">Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornTransport</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gaussian.html">ot.gaussian</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gmm.html">ot.gmm</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lowrank.html">ot.lowrank</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.mapping.html">ot.mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../all.html">API and modules</a></li>
      <li class="breadcrumb-item active">ot.da</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.da.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.da">
<span id="ot-da"></span><h1>ot.da<a class="headerlink" href="#module-ot.da" title="Link to this heading"></a></h1>
<p>Domain adaptation with optimal transport</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ot.da.distribution_estimation_uniform">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">distribution_estimation_uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#distribution_estimation_uniform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.distribution_estimation_uniform" title="Link to this definition"></a></dt>
<dd><p>estimates a uniform distribution from an array of samples <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The array of samples</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mu</strong> – The uniform distribution estimated from <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.emd_laplace">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">emd_laplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#emd_laplace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.emd_laplace" title="Link to this definition"></a></dt>
<dd><p>Solve the optimal transport problem (OT) with Laplacian regularization</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\eta \cdot \Omega_\alpha(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{x_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x_t}\)</span> are source and target samples</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_\alpha\)</span> is the Laplacian regularization term</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\Omega_\alpha = \frac{1 - \alpha}{n_s^2} \sum_{i,j}
\mathbf{S^s}_{i,j} \|T(\mathbf{x}^s_i) - T(\mathbf{x}^s_j) \|^2 +
\frac{\alpha}{n_t^2} \sum_{i,j}
\mathbf{S^t}_{i,j} \|T(\mathbf{x}^t_i) - T(\mathbf{x}^t_j) \|^2\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathbf{S^s}_{i,j}, \mathbf{S^t}_{i,j}\)</span> denoting source and target similarity
matrices and <span class="math notranslate nohighlight">\(T(\cdot)\)</span> being a barycentric mapping.</p>
<p>The algorithm used for solving the problem is the conditional gradient algorithm as proposed in
<span class="xref std std-ref">[5]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>sim</strong> (<em>string</em><em>, </em><em>optional</em>) – Type of similarity (‘knn’ or ‘gauss’) used to construct the Laplacian.</p></li>
<li><p><strong>sim_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Parameter (number of the nearest neighbors for sim=’knn’
or bandwidth for sim=’gauss’) used to compute the Laplacian.</p></li>
<li><p><strong>reg</strong> (<em>string</em>) – Type of Laplacian regularization</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term for Laplacian regularization</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term  for source domain’s importance in regularization</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner emd solver) (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-emd-laplace">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></span>
<p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.sinkhorn_l1l2_gl">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_l1l2_gl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_l1l2_gl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.sinkhorn_l1l2_gl" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with group
lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term
<span class="math notranslate nohighlight">\(\Omega_e(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^2\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class
<cite>c</cite> in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <span class="xref std std-ref">[5, 7]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-12</em><em>)</em>) – Small value to avoid division by zero</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-sinkhorn-l1l2-gl">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence and
applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.optim.html#id22" title="ot.optim.gcg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.gcg</span></code></a></dt><dd><p>Generalized conditional gradient for OT problems</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.da.sinkhorn_lpl1_mm">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_lpl1_mm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_lpl1_mm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.sinkhorn_lpl1_mm" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with non-convex
group lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega_e
(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso  regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^{1/2}_1\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class <cite>c</cite>
in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <a class="reference internal" href="../all.html#references-sinkhorn-lpl1-mm"><span class="std std-ref">[5, 7]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-sinkhorn-lpl1-mm">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div></section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ot.da.BaseTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">BaseTransport</span></span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport" title="Link to this definition"></a></dt>
<dd><p>Base class for OTDA objects</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All estimators should specify all the parameters that can be set
at the class level in their <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as explicit keyword
arguments (no <code class="docutils literal notranslate"><span class="pre">*args</span></code> or <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>).</p>
</div>
<p>The fit method should:</p>
<ul class="simple">
<li><p>estimate a cost matrix and store it in a <cite>cost_</cite> attribute</p></li>
<li><p>estimate a coupling matrix and store it in a <cite>coupling_</cite> attribute</p></li>
<li><p>estimate distributions from source and target data and store them in
<cite>mu_s</cite> and <cite>mu_t</cite> attributes</p></li>
<li><p>store <cite>Xs</cite> and <cite>Xt</cite> in attributes to be used later on in <cite>transform</cite> and
<cite>inverse_transform</cite> methods</p></li>
</ul>
<p><cite>transform</cite> method should always get as input a <cite>Xs</cite> parameter</p>
<p><cite>inverse_transform</cite> method should always get as input a <cite>Xt</cite> parameter</p>
<p><cite>transform_labels</cite> method should always get as input a <cite>ys</cite> parameter</p>
<p><cite>inverse_transform_labels</cite> method should always get as input a <cite>yt</cite> parameter</p>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The training class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.fit_transform" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span>
and transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for training samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The source samples samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.inverse_transform" title="Link to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The target class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.inverse_transform_labels">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.inverse_transform_labels" title="Link to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft source labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.transform" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.BaseTransport.transform_labels">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.BaseTransport.transform_labels" title="Link to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain estimated target labels as in
<span class="xref std std-ref">[27]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="references-basetransport-transform-labels">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</aside>
</aside>
</dd></dl>

</dd></dl>

<section id="examples-using-ot-da-basetransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.BaseTransport</span></code><a class="headerlink" href="#examples-using-ot-da-basetransport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian regularization."><img alt="" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT with Laplacian regularization for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as introduced in [6]"><img alt="" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation with mapping estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><img alt="" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Linear OT mapping estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a semi supervised domain adaptation in a 2D setting. It explicit the problem of semi supervised domain adaptation and introduces some optimal transport approaches to solve it."><img alt="" src="../_images/sphx_glr_plot_otda_semi_supervised_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_semi_supervised.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-semi-supervised-py"><span class="std std-ref">OTDA unsupervised vs semi-supervised setting</span></a></p>
  <div class="sphx-glr-thumbnail-title">OTDA unsupervised vs semi-supervised setting</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently supported in POT."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicit the problem of domain adaptation and introduces some optimal transport approaches to solve it."><img alt="" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation on empirical distributions</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><img alt="" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for multi-source target shift</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDLaplaceTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_type='pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_lap=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_src=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity='knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_param=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDLaplaceTransport" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance with Laplacian regularization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_type</strong> (<em>string optional</em><em> (</em><em>default='pos'</em><em>)</em>) – Type of the regularization term: ‘pos’ and ‘disp’ for
regularization term defined in <span class="xref std std-ref">[2]</span> and
<span class="xref std std-ref">[6]</span>, respectively.</p></li>
<li><p><strong>reg_lap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Laplacian regularization parameter</p></li>
<li><p><strong>reg_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – Source relative importance in regularization</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>similarity</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;knn&quot;</em><em>)</em>) – The similarity to use either knn or gaussian</p></li>
<li><p><strong>similarity_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Parameter for the similarity: number of nearest neighbors or bandwidth
if similarity=”knn” or “gaussian”, respectively. If None is provided,
it is set to 3 or the average pairwise squared Euclidean distance, respectively.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.EMDLaplaceTransport.coupling_" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-emdlaplacetransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.EMDLaplaceTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDLaplaceTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-emdlaplacetransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDLaplaceTransport</span></code><a class="headerlink" href="#examples-using-ot-da-emdlaplacetransport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian regularization."><img alt="" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT with Laplacian regularization for domain adaptation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.EMDTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDTransport" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.EMDTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.EMDTransport.coupling_" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-emdtransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.EMDTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.EMDTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-emdtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.EMDTransport</span></code><a class="headerlink" href="#examples-using-ot-da-emdtransport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian regularization."><img alt="" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT with Laplacian regularization for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as introduced in [6]"><img alt="" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation with mapping estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently supported in POT."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicit the problem of domain adaptation and introduces some optimal transport approaches to solve it."><img alt="" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation on empirical distributions</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">JCPOTTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method for multi-source target shift based on Wasserstein barycenter algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.coupling_" title="Link to this definition"></a></dt>
<dd><p>A set of optimal couplings between each source domain and the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)">list</a> of array-like objects, shape K x (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.proportions_">
<span class="sig-name descname"><span class="pre">proportions_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.proportions_" title="Link to this definition"></a></dt>
<dd><p>Estimated class proportions in the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_classes,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.JCPOTTransport.log_" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-jcpottransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS),
vol. 89, p.849-858, 2019.</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Building coupling matrices from a list of source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.inverse_transform_labels">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.inverse_transform_labels" title="Link to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – The target class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – A list of estimated soft source labels</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)">list</a> of K array-like objects, shape K x (nk_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.transform" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.JCPOTTransport.transform_labels">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.JCPOTTransport.transform_labels" title="Link to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain target labels as in
<span class="xref std std-ref">[27]</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>yt</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="references-jcpottransport-transform-labels">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id15" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</aside>
</aside>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-jcpottransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.JCPOTTransport</span></code><a class="headerlink" href="#examples-using-ot-da-jcpottransport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><img alt="" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for multi-source target shift</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.LinearGWTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearGWTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_eigs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearGWTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearGWTransport" title="Link to this definition"></a></dt>
<dd><p>OT Gaussian Gromov-Wasserstein linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions optimally wrt the Gromov-Wasserstein distance. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[57]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and the vector <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are
defined in <span class="xref std std-ref">[57]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sign_eigs</strong> (<em>array-like</em><em> (</em><em>n_features</em><em>)</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) – sign of the eigenvalues of the mapping matrix, by default all signs will
be positive. If ‘skewness’ is provided, the sign of the eigenvalues is
selected as the product of the sign of the skewness of the projected data.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="references-lineargwtransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022). Gromov–Wasserstein
distances between Gaussian distributions. Journal of Applied Probability,
59(4), 1178-1198.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearGWTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearGWTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearGWTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-lineargwtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearGWTransport</span></code><a class="headerlink" href="#examples-using-ot-da-lineargwtransport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><img alt="" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Linear OT mapping estimation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.LinearTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport" title="Link to this definition"></a></dt>
<dd><p>OT linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[14]</span> and discussed in remark 2.29 in
<span class="xref std std-ref">[15]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the daigonals of covariances (&gt;0)</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="references-lineartransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></span>
<p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.inverse_transform" title="Link to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.LinearTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.LinearTransport.transform" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-lineartransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.LinearTransport</span></code><a class="headerlink" href="#examples-using-ot-da-lineartransport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><img alt="" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Linear OT mapping estimation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.MappingTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">MappingTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport" title="Link to this definition"></a></dt>
<dd><p>MappingTransport: DA methods that aims at jointly estimating a optimal
transport coupling and the associated mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.001</em><em>)</em>) – Regularization term for the linear mapping <cite>L</cite> (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>kernel</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;linear&quot;</em><em>)</em>) – The kernel to use either linear or gaussian</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – The gaussian kernel parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – record log if True</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.MappingTransport.coupling_" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.mapping_">
<span class="sig-name descname"><span class="pre">mapping_</span></span><a class="headerlink" href="#ot.da.MappingTransport.mapping_" title="Link to this definition"></a></dt>
<dd><p>The associated mapping</p>
<ul class="simple">
<li><p>array-like, shape (<cite>n_features</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == linear</p></li>
<li><p>array-like, shape (<cite>n_source_samples</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == gaussian</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.MappingTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.MappingTransport.log_" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.MappingTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Builds an optimal coupling and estimates the associated mapping
from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.MappingTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.MappingTransport.transform" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-mappingtransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.MappingTransport</span></code><a class="headerlink" href="#examples-using-ot-da-mappingtransport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example presents how to use MappingTransport to estimate at the same time both the coupling transport and approximate the transport map with either a linear or a kernelized mapping as introduced in [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-py"><span class="std std-ref">OT mapping estimation for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT mapping estimation for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation with mapping estimation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.NearestBrenierPotential">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">NearestBrenierPotential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strongly_convex_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_lipschitz_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">its</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#NearestBrenierPotential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.NearestBrenierPotential" title="Link to this definition"></a></dt>
<dd><p>Smooth Strongly Convex Nearest Brenier Potentials (SSNB) is a method from <span class="xref std std-ref">[58]</span> that computes
an l-strongly convex potential <span class="math notranslate nohighlight">\(\varphi\)</span> with an L-Lipschitz gradient such that
<span class="math notranslate nohighlight">\(\nabla \varphi \# \mu \approx \nu\)</span>. This regularity can be enforced only on the components of a partition
of the ambient space (encoded by point classes), which is a relaxation compared to imposing global regularity.</p>
<p>SSNBs approach the target measure by solving the optimisation problem:</p>
<div class="math notranslate nohighlight">
\begin{gather*}
\varphi \in \text{argmin}_{\varphi \in \mathcal{F}}\ \text{W}_2(\nabla \varphi \#\mu_s, \mu_t),
\end{gather*}</div><p>where <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> is the space functions that are on every set <span class="math notranslate nohighlight">\(E_k\)</span> l-strongly convex
with an L-Lipschitz gradient, given <span class="math notranslate nohighlight">\((E_k)_{k \in [K]}\)</span> a partition of the ambient source space.</p>
<p>The problem is solved on “fitting” source and target data via a convex Quadratically Constrained Quadratic Program,
yielding the values <code class="code docutils literal notranslate"><span class="pre">phi</span></code> and the gradients <code class="code docutils literal notranslate"><span class="pre">G</span></code> at at the source points.
The images of “new” source samples are then found by solving a (simpler) Quadratically Constrained Linear Program
at each point, using the fitting “parameters” <code class="code docutils literal notranslate"><span class="pre">phi</span></code> and <code class="code docutils literal notranslate"><span class="pre">G</span></code>. We provide two possible images, which
correspond to “lower” and “upper potentials” (<span class="xref std std-ref">[59]</span>, Theorem 3.14). Each of these two images are optimal
solutions of the SSNB problem, and can be used in practice.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function requires the CVXPY library</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Accepts any backend but will convert to Numpy then back to the backend.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strongly_convex_constant</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – constant for the strong convexity of the input potential phi, defaults to 0.6</p></li>
<li><p><strong>gradient_lipschitz_constant</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – constant for the Lipschitz property of the input gradient G, defaults to 1.4</p></li>
<li><p><strong>its</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iterations, defaults to 100</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if true</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>RandomState</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Seed used for random number generator (for the initialisation in <code class="code docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<p>François-Pierre Paty, Alexandre d’Aspremont, and Marco Cuturi. Regularity as regularization:
Smooth and strongly convex brenier potentials in optimal transport. In International Conference
on Artificial Intelligence and Statistics, pages 1222–1232. PMLR, 2020.</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></span>
<p>Adrien B Taylor. Convex interpolation and performance estimation of first-order methods for
convex optimization. PhD thesis, Catholic University of Louvain, Louvain-la-Neuve, Belgium,
2017.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.mapping.html#id11" title="ot.mapping.nearest_brenier_potential_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_fit</span></code></a></dt><dd><p>Fitting the SSNB on source and target data</p>
</dd>
<dt><a class="reference internal" href="ot.mapping.html#id13" title="ot.mapping.nearest_brenier_potential_predict_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_predict_bounds</span></code></a></dt><dd><p>Predicting SSNB images on new source data</p>
</dd>
</dl>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.NearestBrenierPotential.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#NearestBrenierPotential.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.NearestBrenierPotential.fit" title="Link to this definition"></a></dt>
<dd><p>Fits the Smooth Strongly Convex Nearest Brenier Potential [58] to the source data <code class="code docutils literal notranslate"><span class="pre">Xs</span></code> to the target data
<code class="code docutils literal notranslate"><span class="pre">Xt</span></code>, with the partition given by the (optional) labels <code class="code docutils literal notranslate"><span class="pre">ys</span></code>.</p>
<p>Wrapper for <code class="code docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_fit</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function requires the CVXPY library</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Accepts any backend but will convert to Numpy then back to the backend.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em> (</em><em>n</em><em>, </em><em>d</em><em>)</em>) – source points used to compute the optimal values phi and G</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em> (</em><em>n</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – classes of the reference points, defaults to a single class</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em> (</em><em>n</em><em>, </em><em>d</em><em>)</em>) – values of the gradients at the reference points X</p></li>
<li><p><strong>yt</strong> (<em>optional</em>) – ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<p>François-Pierre Paty, Alexandre d’Aspremont, and Marco Cuturi. Regularity as regularization:
Smooth and strongly convex brenier potentials in optimal transport. In International Conference
on Artificial Intelligence and Statistics, pages 1222–1232. PMLR, 2020.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.mapping.html#id11" title="ot.mapping.nearest_brenier_potential_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_fit</span></code></a></dt><dd><p>Fitting the SSNB on source and target data</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.NearestBrenierPotential.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#NearestBrenierPotential.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.NearestBrenierPotential.transform" title="Link to this definition"></a></dt>
<dd><p>Computes the images of the new source samples <code class="code docutils literal notranslate"><span class="pre">Xs</span></code> of classes <code class="code docutils literal notranslate"><span class="pre">ys</span></code> by the fitted
Smooth Strongly Convex Nearest Brenier Potentials (SSNB) <span class="xref std std-ref">[58]</span>. The output is the images of two SSNB optimal
maps, called ‘lower’ and ‘upper’ potentials (from <span class="xref std std-ref">[59]</span>, Theorem 3.14).</p>
<p>Wrapper for <code class="code docutils literal notranslate"><span class="pre">nearest_brenier_potential_predict_bounds</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function requires the CVXPY library</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Accepts any backend but will convert to Numpy then back to the backend.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em> (</em><em>m</em><em>, </em><em>d</em><em>)</em>) – input source points</p></li>
<li><p><strong>ys</strong> (<em>: array_like</em><em> (</em><em>m</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – classes of the input source points, defaults to a single class</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G_lu</strong> – gradients of the lower and upper bounding potentials at Y (images of the source inputs)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like (2, m, d)</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<p>François-Pierre Paty, Alexandre d’Aspremont, and Marco Cuturi. Regularity as regularization:
Smooth and strongly convex brenier potentials in optimal transport. In International Conference
on Artificial Intelligence and Statistics, pages 1222–1232. PMLR, 2020.</p>
</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></span>
<p>Adrien B Taylor. Convex interpolation and performance estimation of first-order methods for
convex optimization. PhD thesis, Catholic University of Louvain, Louvain-la-Neuve, Belgium,
2017.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.mapping.html#id13" title="ot.mapping.nearest_brenier_potential_predict_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_predict_bounds</span></code></a></dt><dd><p>Predicting SSNB images on new source data</p>
</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornL1l2Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornL1l2Transport" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
L1L2 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.coupling_" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.log_" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhornl1l2transport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id25" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornL1l2Transport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornL1l2Transport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhornl1l2transport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornL1l2Transport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhornl1l2transport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently supported in POT."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornLpl1Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornLpl1Transport" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
LpL1 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.inf</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit a cost defined by
limit_max.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornLpl1Transport.coupling_" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhornlpl1transport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id28" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornLpl1Transport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornLpl1Transport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhornlpl1transport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornLpl1Transport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhornlpl1transport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently supported in POT."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicit the problem of domain adaptation and introduces some optimal transport approaches to solve it."><img alt="" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation on empirical distributions</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn_log'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='continuous'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornTransport" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Sinkhorn Algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1000</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – The precision required to stop the optimization algorithm.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values. Accepted values are  ‘median’,
‘max’, ‘log’ and ‘loglog’.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;continuous&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the nearest neighbor method proposed in <span class="xref std std-ref">[6]</span> while “continuous” use the out of sample
method from <span class="xref std std-ref">[66]</span> and <span class="xref std std-ref">[19]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.inf</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an cost defined
by this variable</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.SinkhornTransport.coupling_" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.SinkhornTransport.log_" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-sinkhorntransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id31" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems (NIPS)
26, 2013</p>
</aside>
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
<aside class="footnote brackets" id="id34" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></span>
<p>Seguy, V., Bhushan Damodaran, B., Flamary, R., Courty, N., Rolet, A.
&amp; Blondel, M. Large-scale Optimal Transport and Mapping Estimation.
International Conference on Learning Representation (2018)</p>
</aside>
<aside class="footnote brackets" id="id35" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></span>
<p>Pooladian, Aram-Alexandre, and Jonathan Niles-Weed. “Entropic
estimation of optimal transport maps.” arXiv preprint
arXiv:2109.12004 (2021).</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornTransport.inverse_transform" title="Link to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transport target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ot.da.SinkhornTransport.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.SinkhornTransport.transform" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="examples-using-ot-da-sinkhorntransport">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.da.SinkhornTransport</span></code><a class="headerlink" href="#examples-using-ot-da-sinkhorntransport" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and OTDA approach with Laplacian regularization."><img alt="" src="../_images/sphx_glr_plot_otda_laplacian_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_laplacian.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-laplacian-py"><span class="std std-ref">OT with Laplacian regularization for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT with Laplacian regularization for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example presents a way of transferring colors between two images with Optimal Transport as introduced in [6]"><img alt="" src="../_images/sphx_glr_plot_otda_color_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_color_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-color-images-py"><span class="std std-ref">OT for image color adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="OT for domain adaptation with image color adaptation [6] with mapping estimation [8]."><img alt="" src="../_images/sphx_glr_plot_otda_mapping_colors_images_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_mapping_colors_images.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-mapping-colors-images-py"><span class="std std-ref">OT for image color adaptation with mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for image color adaptation with mapping estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a semi supervised domain adaptation in a 2D setting. It explicit the problem of semi supervised domain adaptation and introduces some optimal transport approaches to solve it."><img alt="" src="../_images/sphx_glr_plot_otda_semi_supervised_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_semi_supervised.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-semi-supervised-py"><span class="std std-ref">OTDA unsupervised vs semi-supervised setting</span></a></p>
  <div class="sphx-glr-thumbnail-title">OTDA unsupervised vs semi-supervised setting</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting and the 4 OTDA approaches currently supported in POT."><img alt="" src="../_images/sphx_glr_plot_otda_classes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_classes.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-classes-py"><span class="std std-ref">OT for domain adaptation</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a domain adaptation in a 2D setting. It explicit the problem of domain adaptation and introduces some optimal transport approaches to solve it."><img alt="" src="../_images/sphx_glr_plot_otda_d2_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_d2.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-d2-py"><span class="std std-ref">OT for domain adaptation on empirical distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for domain adaptation on empirical distributions</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example introduces a target shift problem with two 2D source and 1 target domain."><img alt="" src="../_images/sphx_glr_plot_otda_jcpot_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_jcpot.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-jcpot-py"><span class="std std-ref">OT for multi-source target shift</span></a></p>
  <div class="sphx-glr-thumbnail-title">OT for multi-source target shift</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">UnbalancedSinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation unbalanced OT method based on sinkhorn algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Mass regularization parameter</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’,  ‘sinkhorn_stabilized’ or
‘sinkhorn_epsilon_scaling’, see those function for specific parameters</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.coupling_">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.coupling_" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.log_">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.log_" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="references-unbalancedsinkhorntransport">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id36" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id37" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="ot.da.UnbalancedSinkhornTransport.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.da.UnbalancedSinkhornTransport.fit" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py class">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">BaseTransport</span></span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Link to this definition"></a></dt>
<dd><p>Base class for OTDA objects</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All estimators should specify all the parameters that can be set
at the class level in their <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as explicit keyword
arguments (no <code class="docutils literal notranslate"><span class="pre">*args</span></code> or <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>).</p>
</div>
<p>The fit method should:</p>
<ul class="simple">
<li><p>estimate a cost matrix and store it in a <cite>cost_</cite> attribute</p></li>
<li><p>estimate a coupling matrix and store it in a <cite>coupling_</cite> attribute</p></li>
<li><p>estimate distributions from source and target data and store them in
<cite>mu_s</cite> and <cite>mu_t</cite> attributes</p></li>
<li><p>store <cite>Xs</cite> and <cite>Xt</cite> in attributes to be used later on in <cite>transform</cite> and
<cite>inverse_transform</cite> methods</p></li>
</ul>
<p><cite>transform</cite> method should always get as input a <cite>Xs</cite> parameter</p>
<p><cite>inverse_transform</cite> method should always get as input a <cite>Xt</cite> parameter</p>
<p><cite>transform_labels</cite> method should always get as input a <cite>ys</cite> parameter</p>
<p><cite>inverse_transform_labels</cite> method should always get as input a <cite>yt</cite> parameter</p>
<dl class="py method">
<dt class="sig sig-object py" id="id38">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id38" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The training class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id39">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.fit_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id39" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span>
and transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for training samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The source samples samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id40">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id40" title="Link to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The target class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id41">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id41" title="Link to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft source labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id42">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id42" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id43">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#BaseTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id43" title="Link to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain estimated target labels as in
<span class="xref std std-ref">[27]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The source class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="id44">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id45" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</aside>
</aside>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id46">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDLaplaceTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_type='pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_lap=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_src=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity='knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_param=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id46" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance with Laplacian regularization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_type</strong> (<em>string optional</em><em> (</em><em>default='pos'</em><em>)</em>) – Type of the regularization term: ‘pos’ and ‘disp’ for
regularization term defined in <span class="xref std std-ref">[2]</span> and
<span class="xref std std-ref">[6]</span>, respectively.</p></li>
<li><p><strong>reg_lap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Laplacian regularization parameter</p></li>
<li><p><strong>reg_src</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – Source relative importance in regularization</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>similarity</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;knn&quot;</em><em>)</em>) – The similarity to use either knn or gaussian</p></li>
<li><p><strong>similarity_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Parameter for the similarity: number of nearest neighbors or bandwidth
if similarity=”knn” or “gaussian”, respectively. If None is provided,
it is set to 3 or the average pairwise squared Euclidean distance, respectively.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id47">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id47" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id48">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id49" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id50" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</aside>
<aside class="footnote brackets" id="id51" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id52">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDLaplaceTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id52" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id53">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">EMDTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id53" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Earth Mover’s Distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id54">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id54" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id55">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id56" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id57" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id58">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#EMDTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id58" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id59">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">JCPOTTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ferradans'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id59" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method for multi-source target shift based on Wasserstein barycenter algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id60">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id60" title="Link to this definition"></a></dt>
<dd><p>A set of optimal couplings between each source domain and the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)">list</a> of array-like objects, shape K x (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id61">
<span class="sig-name descname"><span class="pre">proportions_</span></span><a class="headerlink" href="#id61" title="Link to this definition"></a></dt>
<dd><p>Estimated class proportions in the target domain</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_classes,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id62">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id62" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id63">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id64" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS),
vol. 89, p.849-858, 2019.</p>
</aside>
<aside class="footnote brackets" id="id65" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id66">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id66" title="Link to this definition"></a></dt>
<dd><p>Building coupling matrices from a list of source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id67">
<span class="sig-name descname"><span class="pre">inverse_transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.inverse_transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id67" title="Link to this definition"></a></dt>
<dd><p>Propagate target labels <span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span> to obtain estimated source labels
<span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – The target class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_ys</strong> – A list of estimated soft source labels</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)">list</a> of K array-like objects, shape K x (nk_source_samples, nb_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id68">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id68" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – A list of the training input samples.</p></li>
<li><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id69">
<span class="sig-name descname"><span class="pre">transform_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#JCPOTTransport.transform_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id69" title="Link to this definition"></a></dt>
<dd><p>Propagate source labels <span class="math notranslate nohighlight">\(\mathbf{y_s}\)</span> to obtain target labels as in
<span class="xref std std-ref">[27]</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ys</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>K array-like objects</em><em>, </em><em>shape K x</em><em> (</em><em>nk_source_samples</em><em>,</em><em>)</em>) – A list of the class labels</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>yt</strong> – Estimated soft target labels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_target_samples, nb_classes)</p>
</dd>
</dl>
<p class="rubric" id="id70">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id71" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<p>Ievgen Redko, Nicolas Courty, Rémi Flamary, Devis Tuia
“Optimal transport for multi-source domain adaptation under target shift”,
International Conference on Artificial Intelligence and Statistics (AISTATS), 2019.</p>
</aside>
</aside>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id72">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearGWTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_eigs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearGWTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id72" title="Link to this definition"></a></dt>
<dd><p>OT Gaussian Gromov-Wasserstein linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions optimally wrt the Gromov-Wasserstein distance. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[57]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and the vector <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are
defined in <span class="xref std std-ref">[57]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sign_eigs</strong> (<em>array-like</em><em> (</em><em>n_features</em><em>)</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) – sign of the eigenvalues of the mapping matrix, by default all signs will
be positive. If ‘skewness’ is provided, the sign of the eigenvalues is
selected as the product of the sign of the skewness of the projected data.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="id73">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id74" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022). Gromov–Wasserstein
distances between Gaussian distributions. Journal of Applied Probability,
59(4), 1178-1198.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id75">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearGWTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id75" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id76">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">LinearTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id76" title="Link to this definition"></a></dt>
<dd><p>OT linear operator between empirical distributions</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[14]</span> and discussed in remark 2.29 in
<span class="xref std std-ref">[15]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the daigonals of covariances (&gt;0)</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
</dl>
<p class="rubric" id="id77">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id78" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></span>
<p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</aside>
<aside class="footnote brackets" id="id79" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id80">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id80" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id81">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id81" title="Link to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transported target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id82">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#LinearTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id82" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id83">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">MappingTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id83" title="Link to this definition"></a></dt>
<dd><p>MappingTransport: DA methods that aims at jointly estimating a optimal
transport coupling and the associated mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Weight for the linear OT loss (&gt;0)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.001</em><em>)</em>) – Regularization term for the linear mapping <cite>L</cite> (&gt;0)</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Estimate linear mapping with constant bias</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>kernel</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;linear&quot;</em><em>)</em>) – The kernel to use either linear or gaussian</p></li>
<li><p><strong>sigma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – The gaussian kernel parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – Max number of BCD iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – Stop threshold on relative loss decrease (&gt;0)</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>inner_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-6</em><em>)</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – record log if True</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
<li><p><strong>verbose2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Print information along iterations</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id84">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id84" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id85">
<span class="sig-name descname"><span class="pre">mapping_</span></span><a class="headerlink" href="#id85" title="Link to this definition"></a></dt>
<dd><p>The associated mapping</p>
<ul class="simple">
<li><p>array-like, shape (<cite>n_features</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == linear</p></li>
<li><p>array-like, shape (<cite>n_source_samples</cite> (+ 1), <cite>n_features</cite>),
(if bias) for kernel == gaussian</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id86">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id86" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id87" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<p>M. Perrot, N. Courty, R. Flamary, A. Habrard,
“Mapping estimation for discrete optimal transport”,
Neural Information Processing Systems (NIPS), 2016.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id88">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id88" title="Link to this definition"></a></dt>
<dd><p>Builds an optimal coupling and estimates the associated mapping
from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id89">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#MappingTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id89" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id90">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">NearestBrenierPotential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strongly_convex_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_lipschitz_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">its</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#NearestBrenierPotential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id90" title="Link to this definition"></a></dt>
<dd><p>Smooth Strongly Convex Nearest Brenier Potentials (SSNB) is a method from <span class="xref std std-ref">[58]</span> that computes
an l-strongly convex potential <span class="math notranslate nohighlight">\(\varphi\)</span> with an L-Lipschitz gradient such that
<span class="math notranslate nohighlight">\(\nabla \varphi \# \mu \approx \nu\)</span>. This regularity can be enforced only on the components of a partition
of the ambient space (encoded by point classes), which is a relaxation compared to imposing global regularity.</p>
<p>SSNBs approach the target measure by solving the optimisation problem:</p>
<div class="math notranslate nohighlight">
\begin{gather*}
\varphi \in \text{argmin}_{\varphi \in \mathcal{F}}\ \text{W}_2(\nabla \varphi \#\mu_s, \mu_t),
\end{gather*}</div><p>where <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> is the space functions that are on every set <span class="math notranslate nohighlight">\(E_k\)</span> l-strongly convex
with an L-Lipschitz gradient, given <span class="math notranslate nohighlight">\((E_k)_{k \in [K]}\)</span> a partition of the ambient source space.</p>
<p>The problem is solved on “fitting” source and target data via a convex Quadratically Constrained Quadratic Program,
yielding the values <code class="code docutils literal notranslate"><span class="pre">phi</span></code> and the gradients <code class="code docutils literal notranslate"><span class="pre">G</span></code> at at the source points.
The images of “new” source samples are then found by solving a (simpler) Quadratically Constrained Linear Program
at each point, using the fitting “parameters” <code class="code docutils literal notranslate"><span class="pre">phi</span></code> and <code class="code docutils literal notranslate"><span class="pre">G</span></code>. We provide two possible images, which
correspond to “lower” and “upper potentials” (<span class="xref std std-ref">[59]</span>, Theorem 3.14). Each of these two images are optimal
solutions of the SSNB problem, and can be used in practice.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function requires the CVXPY library</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Accepts any backend but will convert to Numpy then back to the backend.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>strongly_convex_constant</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – constant for the strong convexity of the input potential phi, defaults to 0.6</p></li>
<li><p><strong>gradient_lipschitz_constant</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – constant for the Lipschitz property of the input gradient G, defaults to 1.4</p></li>
<li><p><strong>its</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iterations, defaults to 100</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if true</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>RandomState</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Seed used for random number generator (for the initialisation in <code class="code docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id91" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<p>François-Pierre Paty, Alexandre d’Aspremont, and Marco Cuturi. Regularity as regularization:
Smooth and strongly convex brenier potentials in optimal transport. In International Conference
on Artificial Intelligence and Statistics, pages 1222–1232. PMLR, 2020.</p>
</aside>
<aside class="footnote brackets" id="id92" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></span>
<p>Adrien B Taylor. Convex interpolation and performance estimation of first-order methods for
convex optimization. PhD thesis, Catholic University of Louvain, Louvain-la-Neuve, Belgium,
2017.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.mapping.html#id11" title="ot.mapping.nearest_brenier_potential_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_fit</span></code></a></dt><dd><p>Fitting the SSNB on source and target data</p>
</dd>
<dt><a class="reference internal" href="ot.mapping.html#id13" title="ot.mapping.nearest_brenier_potential_predict_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_predict_bounds</span></code></a></dt><dd><p>Predicting SSNB images on new source data</p>
</dd>
</dl>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="id93">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#NearestBrenierPotential.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id93" title="Link to this definition"></a></dt>
<dd><p>Fits the Smooth Strongly Convex Nearest Brenier Potential [58] to the source data <code class="code docutils literal notranslate"><span class="pre">Xs</span></code> to the target data
<code class="code docutils literal notranslate"><span class="pre">Xt</span></code>, with the partition given by the (optional) labels <code class="code docutils literal notranslate"><span class="pre">ys</span></code>.</p>
<p>Wrapper for <code class="code docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_fit</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function requires the CVXPY library</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Accepts any backend but will convert to Numpy then back to the backend.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em> (</em><em>n</em><em>, </em><em>d</em><em>)</em>) – source points used to compute the optimal values phi and G</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em> (</em><em>n</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – classes of the reference points, defaults to a single class</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em> (</em><em>n</em><em>, </em><em>d</em><em>)</em>) – values of the gradients at the reference points X</p></li>
<li><p><strong>yt</strong> (<em>optional</em>) – ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id94" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<p>François-Pierre Paty, Alexandre d’Aspremont, and Marco Cuturi. Regularity as regularization:
Smooth and strongly convex brenier potentials in optimal transport. In International Conference
on Artificial Intelligence and Statistics, pages 1222–1232. PMLR, 2020.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.mapping.html#id11" title="ot.mapping.nearest_brenier_potential_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_fit</span></code></a></dt><dd><p>Fitting the SSNB on source and target data</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id95">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#NearestBrenierPotential.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id95" title="Link to this definition"></a></dt>
<dd><p>Computes the images of the new source samples <code class="code docutils literal notranslate"><span class="pre">Xs</span></code> of classes <code class="code docutils literal notranslate"><span class="pre">ys</span></code> by the fitted
Smooth Strongly Convex Nearest Brenier Potentials (SSNB) <span class="xref std std-ref">[58]</span>. The output is the images of two SSNB optimal
maps, called ‘lower’ and ‘upper’ potentials (from <span class="xref std std-ref">[59]</span>, Theorem 3.14).</p>
<p>Wrapper for <code class="code docutils literal notranslate"><span class="pre">nearest_brenier_potential_predict_bounds</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function requires the CVXPY library</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Accepts any backend but will convert to Numpy then back to the backend.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em> (</em><em>m</em><em>, </em><em>d</em><em>)</em>) – input source points</p></li>
<li><p><strong>ys</strong> (<em>: array_like</em><em> (</em><em>m</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – classes of the input source points, defaults to a single class</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G_lu</strong> – gradients of the lower and upper bounding potentials at Y (images of the source inputs)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like (2, m, d)</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id96" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<p>François-Pierre Paty, Alexandre d’Aspremont, and Marco Cuturi. Regularity as regularization:
Smooth and strongly convex brenier potentials in optimal transport. In International Conference
on Artificial Intelligence and Statistics, pages 1222–1232. PMLR, 2020.</p>
</aside>
<aside class="footnote brackets" id="id97" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></span>
<p>Adrien B Taylor. Convex interpolation and performance estimation of first-order methods for
convex optimization. PhD thesis, Catholic University of Louvain, Louvain-la-Neuve, Belgium,
2017.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.mapping.html#id13" title="ot.mapping.nearest_brenier_potential_predict_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.mapping.nearest_brenier_potential_predict_bounds</span></code></a></dt><dd><p>Predicting SSNB images on new source data</p>
</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id98">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornL1l2Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id98" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
L1L2 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id99">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id99" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id100">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id100" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id101">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id102" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id103" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
<aside class="footnote brackets" id="id104" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id105">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornL1l2Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id105" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id106">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornLpl1Transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cl=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_inner_iter=200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id106" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on sinkhorn algorithm +
LpL1 class regularization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_cl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Class regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>max_inner_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=200</em><em>)</em>) – The number of iteration in the inner loop</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.inf</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit a cost defined by
limit_max.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id107">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id107" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id108">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id109" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id110" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
<aside class="footnote brackets" id="id111" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id112">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornLpl1Transport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id112" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id113">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">SinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn_log'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='continuous'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id113" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation OT method based on Sinkhorn Algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1000</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – The precision required to stop the optimization algorithm.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values. Accepted values are  ‘median’,
‘max’, ‘log’ and ‘loglog’.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;continuous&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the nearest neighbor method proposed in <span class="xref std std-ref">[6]</span> while “continuous” use the out of sample
method from <span class="xref std std-ref">[66]</span> and <span class="xref std std-ref">[19]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=np.inf</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an cost defined
by this variable</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id114">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id114" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id115">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id115" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id116">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id117" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id118" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems (NIPS)
26, 2013</p>
</aside>
<aside class="footnote brackets" id="id119" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
<aside class="footnote brackets" id="id120" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></span>
<p>Seguy, V., Bhushan Damodaran, B., Flamary, R., Courty, N., Rolet, A.
&amp; Blondel, M. Large-scale Optimal Transport and Mapping Estimation.
International Conference on Learning Representation (2018)</p>
</aside>
<aside class="footnote brackets" id="id121" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>66<span class="fn-bracket">]</span></span>
<p>Pooladian, Aram-Alexandre, and Jonathan Niles-Weed. “Entropic
estimation of optimal transport maps.” arXiv preprint
arXiv:2109.12004 (2021).</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id122">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id122" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id123">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id123" title="Link to this definition"></a></dt>
<dd><p>Transports target samples <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span> onto source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xt</strong> – The transport target samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id124">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#SinkhornTransport.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id124" title="Link to this definition"></a></dt>
<dd><p>Transports source samples <span class="math notranslate nohighlight">\(\mathbf{X_s}\)</span> onto target ones <span class="math notranslate nohighlight">\(\mathbf{X_t}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The source input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels for source samples</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The target input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels for target. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=128</em><em>)</em>) – The batch size for out of sample inverse transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>transp_Xs</strong> – The transport source samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id125">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">UnbalancedSinkhornTransport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reg_e=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m=0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol=1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric='sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution_estimation=&lt;function</span> <span class="pre">distribution_estimation_uniform&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_of_sample_map='ferradans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_max=10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id125" title="Link to this definition"></a></dt>
<dd><p>Domain Adaptation unbalanced OT method based on sinkhorn algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reg_e</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Entropic regularization parameter</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – Mass regularization parameter</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’,  ‘sinkhorn_stabilized’ or
‘sinkhorn_epsilon_scaling’, see those function for specific parameters</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – The minimum number of iteration before stopping the optimization
algorithm if it has not converged</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10e-9</em><em>)</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the verbosity of the optimization algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Controls the logs of the optimization algorithm</p></li>
<li><p><strong>metric</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;sqeuclidean&quot;</em><em>)</em>) – The ground metric for the Wasserstein problem</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If given, normalize the ground metric to avoid numerical errors that
can occur with large metric values.</p></li>
<li><p><strong>distribution_estimation</strong> (<em>callable</em><em>, </em><em>optional</em><em> (</em><em>defaults to the uniform</em><em>)</em>) – The kind of distribution estimation to employ</p></li>
<li><p><strong>out_of_sample_map</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default=&quot;ferradans&quot;</em><em>)</em>) – The kind of out of sample mapping to apply to transport samples
from a domain into another one. Currently the only possible option is
“ferradans” which uses the method proposed in <span class="xref std std-ref">[6]</span>.</p></li>
<li><p><strong>limit_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=10</em><em>)</em>) – Controls the semi supervised mode. Transport between labeled source
and target samples of different classes will exhibit an infinite cost
(10 times the maximum value of the cost matrix)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id126">
<span class="sig-name descname"><span class="pre">coupling_</span></span><a class="headerlink" href="#id126" title="Link to this definition"></a></dt>
<dd><p>The optimal coupling</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_source_samples, n_target_samples)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id127">
<span class="sig-name descname"><span class="pre">log_</span></span><a class="headerlink" href="#id127" title="Link to this definition"></a></dt>
<dd><p>The dictionary of log, empty dict if parameter log is not True</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<p class="rubric" id="id128">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id129" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id130" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<p>Ferradans, S., Papadakis, N., Peyré, G., &amp; Aujol, J. F. (2014).
Regularized discrete optimal transport. SIAM Journal on Imaging
Sciences, 7(3), 1853-1882.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="id131">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#UnbalancedSinkhornTransport.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id131" title="Link to this definition"></a></dt>
<dd><p>Build a coupling matrix from source and target sets of samples
<span class="math notranslate nohighlight">\((\mathbf{X_s}, \mathbf{y_s})\)</span> and <span class="math notranslate nohighlight">\((\mathbf{X_t}, \mathbf{y_t})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>ys</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_source_samples</em><em>,</em><em>)</em>) – The class labels</p></li>
<li><p><strong>Xt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>, </em><em>n_features</em><em>)</em>) – The training input samples.</p></li>
<li><p><strong>yt</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_target_samples</em><em>,</em><em>)</em>) – <p>The class labels. If some target samples are unlabelled, fill the
<span class="math notranslate nohighlight">\(\mathbf{y_t}\)</span>’s elements with -1.</p>
<p>Warning: Note that, due to this convention -1 cannot be used as a
class label</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id132">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">distribution_estimation_uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#distribution_estimation_uniform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id132" title="Link to this definition"></a></dt>
<dd><p>estimates a uniform distribution from an array of samples <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The array of samples</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mu</strong> – The uniform distribution estimated from <span class="math notranslate nohighlight">\(\mathbf{X}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id133">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">emd_laplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'knn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pos'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#emd_laplace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id133" title="Link to this definition"></a></dt>
<dd><p>Solve the optimal transport problem (OT) with Laplacian regularization</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\eta \cdot \Omega_\alpha(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{x_s}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x_t}\)</span> are source and target samples</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_\alpha\)</span> is the Laplacian regularization term</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\Omega_\alpha = \frac{1 - \alpha}{n_s^2} \sum_{i,j}
\mathbf{S^s}_{i,j} \|T(\mathbf{x}^s_i) - T(\mathbf{x}^s_j) \|^2 +
\frac{\alpha}{n_t^2} \sum_{i,j}
\mathbf{S^t}_{i,j} \|T(\mathbf{x}^t_i) - T(\mathbf{x}^t_j) \|^2\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathbf{S^s}_{i,j}, \mathbf{S^t}_{i,j}\)</span> denoting source and target similarity
matrices and <span class="math notranslate nohighlight">\(T(\cdot)\)</span> being a barycentric mapping.</p>
<p>The algorithm used for solving the problem is the conditional gradient algorithm as proposed in
<span class="xref std std-ref">[5]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>sim</strong> (<em>string</em><em>, </em><em>optional</em>) – Type of similarity (‘knn’ or ‘gauss’) used to construct the Laplacian.</p></li>
<li><p><strong>sim_param</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Parameter (number of the nearest neighbors for sim=’knn’
or bandwidth for sim=’gauss’) used to compute the Laplacian.</p></li>
<li><p><strong>reg</strong> (<em>string</em>) – Type of Laplacian regularization</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term for Laplacian regularization</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term  for source domain’s importance in regularization</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner emd solver) (&gt;0)</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner CG solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner CG solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id134">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id135" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id136" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></span>
<p>R. Flamary, N. Courty, D. Tuia, A. Rakotomamonjy,
“Optimal transport with Laplacian regularization: Applications to domain adaptation and shape matching,”
in NIPS Workshop on Optimal Transport and Machine Learning OTML, 2014.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id137">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_l1l2_gl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_l1l2_gl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id137" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with group
lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term
<span class="math notranslate nohighlight">\(\Omega_e(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^2\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class
<cite>c</cite> in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <span class="xref std std-ref">[5, 7]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-12</em><em>)</em>) – Small value to avoid division by zero</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id138">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id139" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id140" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence and
applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.optim.html#id22" title="ot.optim.gcg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.gcg</span></code></a></dt><dd><p>Generalized conditional gradient for OT problems</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id141">
<span class="sig-prename descclassname"><span class="pre">ot.da.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_lpl1_mm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numInnerItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopInnerThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/da.html#sinkhorn_lpl1_mm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id141" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization optimal transport problem with non-convex
group lasso regularization</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \Omega_e(\gamma) + \eta \ \Omega_g(\gamma)\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>ns</cite>, <cite>nt</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_e\)</span> is the entropic regularization term <span class="math notranslate nohighlight">\(\Omega_e
(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega_g\)</span> is the group lasso  regularization term
<span class="math notranslate nohighlight">\(\Omega_g(\gamma)=\sum_{i,c} \|\gamma_{i,\mathcal{I}_c}\|^{1/2}_1\)</span>
where  <span class="math notranslate nohighlight">\(\mathcal{I}_c\)</span> are the index of samples from class <cite>c</cite>
in the source domain.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target weights (sum to 1)</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized conditional
gradient as proposed in <a class="reference internal" href="../all.html#references-sinkhorn-lpl1-mm"><span class="std std-ref">[5, 7]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – samples weights in the source domain</p></li>
<li><p><strong>labels_a</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>)</em>) – labels of samples in the source domain</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>)</em>) – samples weights in the target domain</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>nt</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term for entropic regularization &gt;0</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Regularization term  for group lasso regularization &gt;0</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>numInnerItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations (inner sinkhorn solver)</p></li>
<li><p><strong>stopInnerThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (inner sinkhorn solver) (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id142">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id143" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>N. Courty; R. Flamary; D. Tuia; A. Rakotomamonjy,
“Optimal Transport for Domain Adaptation,” in IEEE
Transactions on Pattern Analysis and Machine Intelligence ,
vol.PP, no.99, pp.1-1</p>
</aside>
<aside class="footnote brackets" id="id144" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></span>
<p>Rakotomamonjy, A., Flamary, R., &amp; Courty, N. (2015).
Generalized conditional gradient: analysis of convergence
and applications. arXiv preprint arXiv:1510.06567.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.coot.html" class="btn btn-neutral float-left" title="ot.coot" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.datasets.html" class="btn btn-neutral float-right" title="ot.datasets" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2025, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span> 0.9.6.post1
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>