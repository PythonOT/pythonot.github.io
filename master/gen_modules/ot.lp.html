

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.lp &mdash; POT Python Optimal Transport 0.9.6dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=6e3d2238"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.mapping" href="ot.mapping.html" />
    <link rel="prev" title="ot.lowrank" href="ot.lowrank.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quick start guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.coot.html">ot.coot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.da.html">ot.da</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gaussian.html">ot.gaussian</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gmm.html">ot.gmm</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lowrank.html">ot.lowrank</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.lp</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.center_ot_dual"><code class="docutils literal notranslate"><span class="pre">center_ot_dual()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.check_number_threads"><code class="docutils literal notranslate"><span class="pre">check_number_threads()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.emd"><code class="docutils literal notranslate"><span class="pre">emd()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.emd2"><code class="docutils literal notranslate"><span class="pre">emd2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.estimate_dual_null_weights"><code class="docutils literal notranslate"><span class="pre">estimate_dual_null_weights()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.free_support_barycenter"><code class="docutils literal notranslate"><span class="pre">free_support_barycenter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-lp-free-support-barycenter">Examples using <code class="docutils literal notranslate"><span class="pre">ot.lp.free_support_barycenter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-lp-generalized-free-support-barycenter">Examples using <code class="docutils literal notranslate"><span class="pre">ot.lp.generalized_free_support_barycenter</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.mapping.html">ot.mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../all.html">API and modules</a></li>
      <li class="breadcrumb-item active">ot.lp</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.lp.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.lp">
<span id="ot-lp"></span><h1>ot.lp<a class="headerlink" href="#module-ot.lp" title="Link to this heading"></a></h1>
<p>Solvers for the original linear program OT problem.</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.center_ot_dual">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">center_ot_dual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#center_ot_dual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.center_ot_dual" title="Link to this definition"></a></dt>
<dd><p>Center dual OT potentials w.r.t. their weights</p>
<p>The main idea of this function is to find unique dual potentials
that ensure some kind of centering/fairness. The main idea is to find dual potentials that lead to the same final objective value for both source and targets (see below for more details). It will help having
stability when multiple calling of the OT solver with small changes.</p>
<p>Basically we add another constraint to the potential that will not
change the objective value but will ensure unicity. The constraint
is the following:</p>
<div class="math notranslate nohighlight">
\[\alpha^T \mathbf{a} = \beta^T \mathbf{b}\]</div>
<p>in addition to the OT problem constraints.</p>
<p>since <span class="math notranslate nohighlight">\(\sum_i a_i=\sum_j b_j\)</span> this can be solved by adding/removing
a constant from both  <span class="math notranslate nohighlight">\(\alpha_0\)</span> and <span class="math notranslate nohighlight">\(\beta_0\)</span>.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}c &amp;= \frac{\beta_0^T \mathbf{b} - \alpha_0^T \mathbf{a}}{\mathbf{1}^T \mathbf{b} + \mathbf{1}^T \mathbf{a}}\\\alpha &amp;= \alpha_0 + c\\\beta &amp;= \beta_0 + c\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha0</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Source dual potential</p></li>
<li><p><strong>beta0</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Target dual potential</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Target histogram (uniform weight if empty list)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>alpha</strong> (<em>(ns,) numpy.ndarray, float64</em>) – Source centered dual potential</p></li>
<li><p><strong>beta</strong> (<em>(nt,) numpy.ndarray, float64</em>) – Target centered dual potential</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.check_number_threads">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">check_number_threads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numThreads</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#check_number_threads"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.check_number_threads" title="Link to this definition"></a></dt>
<dd><p>Checks whether or not the requested number of threads has a valid value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – The requested number of threads, should either be a strictly positive integer or “max” or None</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>numThreads</strong> – Corrected number of threads</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#emd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> matrix in numpy needs to be a C-order
numpy.array in float64 format. It will be converted if not in this
format</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data type
of the provided input with the following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="../all.html#references-emd"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Loss matrix (c-order array in numpy with type float64)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost and dual variables.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (ns, nt)</em>) – Optimal transportation matrix for the given
parameters</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – If input log is true, a dictionary containing the
cost and dual variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="go">array([[0.5, 0. ],</span>
<span class="go">       [0. , 0.5]])</span>
</pre></div>
</div>
<p class="rubric" id="references-emd">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W. (2011,
December).  Displacement interpolation using Lagrangian mass transport.
In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p. 158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd2">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#emd2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd2" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan and
transportation loss to the data type of the provided input with the
following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="../all.html#references-emd2"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Loss matrix (for numpy c-order array with type float64)</p></li>
<li><p><strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Nb of processes used for multiple emd computation (deprecated)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing dual
variables. Otherwise returns only the optimal transportation cost.</p></li>
<li><p><strong>return_matrix</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns the optimal transportation matrix in the log.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float, array-like</em>) – Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is true, a dictionary containing dual
variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric" id="references-emd2">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.estimate_dual_null_weights">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">estimate_dual_null_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#estimate_dual_null_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.estimate_dual_null_weights" title="Link to this definition"></a></dt>
<dd><p>Estimate feasible values for 0-weighted dual potentials</p>
<p>The feasible values are computed efficiently but rather coarsely.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is necessary because the C++ solver in <cite>emd_c</cite>
discards all samples in the distributions with
zeros weights. This means that while the primal variable (transport
matrix) is exact, the solver only returns feasible dual potentials
on the samples with weights different from zero.</p>
</div>
<p>First we compute the constraints violations:</p>
<div class="math notranslate nohighlight">
\[\mathbf{V} = \alpha + \beta^T - \mathbf{M}\]</div>
<p>Next we compute the max amount of violation per row (<span class="math notranslate nohighlight">\(\alpha\)</span>) and
columns (<span class="math notranslate nohighlight">\(beta\)</span>)</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{v^a}_i = \max_j \mathbf{V}_{i,j}\\\mathbf{v^b}_j = \max_i \mathbf{V}_{i,j}\end{aligned}\end{align} \]</div>
<p>Finally we update the dual potential with 0 weights if a
constraint is violated</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\alpha_i = \alpha_i - \mathbf{v^a}_i \quad \text{ if } \mathbf{a}_i=0 \text{ and } \mathbf{v^a}_i&gt;0\\\beta_j = \beta_j - \mathbf{v^b}_j \quad \text{ if } \mathbf{b}_j=0 \text{ and } \mathbf{v^b}_j &gt; 0\end{aligned}\end{align} \]</div>
<p>In the end the dual potentials are centered using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p>
<p>Note that all those updates do not change the objective value of the
solution but provide dual potentials that do not violate the constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha0</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Source dual potential</p></li>
<li><p><strong>beta0</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Target dual potential</p></li>
<li><p><strong>alpha0</strong> – Source dual potential</p></li>
<li><p><strong>beta0</strong> – Target dual potential</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Source distribution (uniform weights if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Target distribution (uniform weights if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.1)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Loss matrix (c-order array with type float64)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>alpha</strong> (<em>(ns,) numpy.ndarray, float64</em>) – Source corrected dual potential</p></li>
<li><p><strong>beta</strong> (<em>(nt,) numpy.ndarray, float64</em>) – Target corrected dual potential</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.free_support_barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measures_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measures_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.free_support_barycenter" title="Link to this definition"></a></dt>
<dd><p>Solves the free support (locations of the barycenters are optimized, not the weights) Wasserstein barycenter problem (i.e. the weighted Frechet mean for the 2-Wasserstein distance), formally:</p>
<div class="math notranslate nohighlight">
\[\min_\mathbf{X} \quad \sum_{i=1}^N w_i W_2^2(\mathbf{b}, \mathbf{X}, \mathbf{a}_i, \mathbf{X}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(w \in \mathbb{(0, 1)}^{N}\)</span>’s are the barycenter weights and sum to one</p></li>
<li><p><cite>measure_weights</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span>: empirical measures weights (on simplex)</p></li>
<li><p><cite>measures_locations</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d}\)</span>: empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{k}\)</span> is the desired weights vector of the barycenter</p></li>
</ul>
<p>This problem is considered in <span class="xref std std-ref">[20]</span> (Algorithm 2).
There are two differences with the following codes:</p>
<ul class="simple">
<li><p>we do not optimize over the weights</p></li>
<li><p>we do not do line search for the locations updates, we use i.e. <span class="math notranslate nohighlight">\(\theta = 1\)</span> in
<span class="xref std std-ref">[20]</span> (Algorithm 2). This can be seen as a discrete
implementation of the fixed-point algorithm of
<span class="xref std std-ref">[43]</span> proposed in the continuous setting.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measures_locations</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – The discrete support of a measure supported on <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>measures_weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Numpy arrays where each numpy array has <span class="math notranslate nohighlight">\(k_i\)</span> non-negatives values summing to one
representing the weights of each discrete input measure</p></li>
<li><p><strong>X_init</strong> (<em>(</em><em>k</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>k</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>X</strong> – Support locations (on k atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(k,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="references-free-support-barycenter">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, Marco, and Arnaud Doucet. “Fast computation of Wasserstein barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></span>
<p>Álvarez-Esteban, Pedro C., et al. “A fixed-point approach to barycenters in Wasserstein space.” Journal of Mathematical Analysis and Applications 441.2 (2016): 744-762.</p>
</aside>
</aside>
</dd></dl>

<section id="examples-using-ot-lp-free-support-barycenter">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.lp.free_support_barycenter</span></code><a class="headerlink" href="#examples-using-ot-lp-free-support-barycenter" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Illustration of 2D Wasserstein and Sinkhorn barycenters if distributions are weighted sum of Diracs."><img alt="" src="../_images/sphx_glr_plot_free_support_barycenter_thumb.png" />
<p><a class="reference internal" href="../auto_examples/barycenters/plot_free_support_barycenter.html#sphx-glr-auto-examples-barycenters-plot-free-support-barycenter-py"><span class="std std-ref">2D free support Wasserstein barycenters of distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">2D free support Wasserstein barycenters of distributions</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.generalized_free_support_barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">generalized_free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_bary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#generalized_free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.generalized_free_support_barycenter" title="Link to this definition"></a></dt>
<dd><p>Solves the free support generalized Wasserstein barycenter problem: finding a barycenter (a discrete measure with
a fixed amount of points of uniform weights) whose respective projections fit the input measures.
More formally:</p>
<div class="math notranslate nohighlight">
\[\min_\gamma \quad \sum_{i=1}^p w_i W_2^2(\nu_i, \mathbf{P}_i\#\gamma)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\gamma = \sum_{l=1}^n b_l\delta_{y_l}\)</span> is the desired barycenter with each <span class="math notranslate nohighlight">\(y_l \in \mathbb{R}^d\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{n}\)</span> is the desired weights vector of the barycenter</p></li>
<li><p>The input measures are <span class="math notranslate nohighlight">\(\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{x_{i,j}}\)</span></p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span> are the respective empirical measures weights (on the simplex)</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d_i}\)</span> are the respective empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(w = (w_1, \cdots w_p)\)</span> are the barycenter coefficients (on the simplex)</p></li>
<li><p>Each <span class="math notranslate nohighlight">\(\mathbf{P}_i \in \mathbb{R}^{d, d_i}\)</span>, and <span class="math notranslate nohighlight">\(P_i\#\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{P_ix_{i,j}}\)</span></p></li>
</ul>
<p>As show by <span class="xref std std-ref">[42]</span>,
this problem can be re-written as a Wasserstein Barycenter problem,
which we solve using the free support method <span class="xref std std-ref">[20]</span>
(Algorithm 2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>d_i</em><em>) </em><em>array-like</em>) – Discrete supports of the input measures: each consists of <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d_i</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>a_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Measure weights: each element is a vector (k_i) on the simplex</p></li>
<li><p><strong>P_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>d_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Each <span class="math notranslate nohighlight">\(P_i\)</span> is a linear map <span class="math notranslate nohighlight">\(\mathbb{R}^{d} \rightarrow \mathbb{R}^{d_i}\)</span></p></li>
<li><p><strong>n_samples_bary</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Number of barycenter points</p></li>
<li><p><strong>Y_init</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter measure (on the simplex)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>p</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (on the simplex)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>eps</strong> (<em>Stability coefficient for the change</em><em> of </em><em>variable matrix inversion</em>) – If the <span class="math notranslate nohighlight">\(\mathbf{P}_i^T\)</span> matrices don’t span <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, the problem is ill-defined and a matrix
inversion will fail. In this case one may set eps=1e-8 and get a solution anyway (which may make little sense)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Y</strong> – Support locations (on n_samples_bary atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(n_samples_bary,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="references-generalized-free-support-barycenter">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, M. and Doucet, A.. “Fast computation of Wasserstein barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>42<span class="fn-bracket">]</span></span>
<p>Delon, J., Gozlan, N., and Saint-Dizier, A.. Generalized Wasserstein barycenters between probability measures living on different subspaces. arXiv preprint arXiv:2105.09755, 2021.</p>
</aside>
</aside>
</dd></dl>

</section>
<section id="examples-using-ot-lp-generalized-free-support-barycenter">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.lp.generalized_free_support_barycenter</span></code><a class="headerlink" href="#examples-using-ot-lp-generalized-free-support-barycenter" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example illustrates the computation of Generalized Wasserstein Barycenter as proposed in [42]."><img alt="" src="../_images/sphx_glr_plot_generalized_free_support_barycenter_thumb.png" />
<p><a class="reference internal" href="../auto_examples/barycenters/plot_generalized_free_support_barycenter.html#sphx-glr-auto-examples-barycenters-plot-generalized-free-support-barycenter-py"><span class="std std-ref">Generalized Wasserstein Barycenter Demo</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generalized Wasserstein Barycenter Demo</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'highs-ipm'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/cvx.html#barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.barycenter" title="Link to this definition"></a></dt>
<dd><p>Compute the Wasserstein barycenter of distributions A</p>
<blockquote>
<div><p>The function solves the following optimization problem [16]:</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = arg\min_\mathbf{a} \sum_i W_{1}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_1(\cdot,\cdot)\)</span> is the Wasserstein distance (see ot.emd.sinkhorn)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
</ul>
<p>The linear program is solved using the interior point solver from scipy.optimize.
If cvxopt solver if installed it can use cvxopt</p>
<p>Note that this problem do not scale well (both in memory and computational time).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> (</em><em>d</em><em>,</em><em>n</em><em>)</em>) – n training distributions a_i of size d</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>d</em><em>,</em><em>d</em><em>)</em>) – loss matrix   for OT</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term &gt;0</p></li>
<li><p><strong>weights</strong> (<em>np.ndarray</em><em> (</em><em>n</em><em>,</em><em>)</em>) – Weights of each histogram a_i on the simplex (barycentric coordinates)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>solver</strong> (<em>string</em><em>, </em><em>optional</em>) – the solver used, default ‘interior-point’ use the lp solver from
scipy.optimize. None, or ‘glpk’ or ‘mosek’ use the solver from cvxopt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>(d,) ndarray</em>) – Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<p>Agueh, M., &amp; Carlier, G. (2011). Barycenters in the Wasserstein space. SIAM Journal on Mathematical Analysis, 43(2), 904-924.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.binary_search_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">binary_search_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#binary_search_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.binary_search_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the Wasserstein distance on the circle using the Binary search algorithm proposed in [44].
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<div class="math notranslate nohighlight">
\[W_p^p(u,v) = \inf_{\theta\in\mathbb{R}}\int_0^1 |F_u^{-1}(q)  - (F_v-\theta)^{-1}(q)|^p\ \mathrm{d}q\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F_u\)</span> and <span class="math notranslate nohighlight">\(F_v\)</span> are respectively the cdfs of <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span></p></li>
</ul>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the target domain (coordinates on [0,1[)</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Power p used for computing the Wasserstein distance</p></li>
<li><p><strong>Lm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Lower bound dC</p></li>
<li><p><strong>Lp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Upper bound dC</p></li>
<li><p><strong>tm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Lower bound theta</p></li>
<li><p><strong>tp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Upper bound theta</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stopping condition</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, sort the values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, returns also the optimal theta</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float</em>) – Cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – log dictionary returned only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_search_circle</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.1])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<p>Delon, Julie, Julien Salomon, and Andrei Sobolevski. “Fast transport optimization for Monge costs on the circle.” SIAM Journal on Applied Mathematics 70.7 (2010): 2239-2258.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.dmmot_monge_1dgrid_loss">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">dmmot_monge_1dgrid_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/dmmot.html#dmmot_monge_1dgrid_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.dmmot_monge_1dgrid_loss" title="Link to this definition"></a></dt>
<dd><p>Compute the discrete multi-marginal optimal transport of distributions A.</p>
<p>This function operates on distributions whose supports are real numbers on
the real line.</p>
<p>The algorithm solves both primal and dual d-MMOT programs concurrently to
produce the optimal transport plan as well as the total (minimal) cost.
The cost is a ground cost, and the solution is independent of
which Monge cost is desired.</p>
<p>The algorithm accepts <span class="math notranslate nohighlight">\(d\)</span> distributions (i.e., histograms)
<span class="math notranslate nohighlight">\(a_{1}, \ldots, a_{d} \in \mathbb{R}_{+}^{n}\)</span> with <span class="math notranslate nohighlight">\(e^{\prime}
a_{j}=1\)</span> for all <span class="math notranslate nohighlight">\(j \in[d]\)</span>. Although the algorithm states that all
histograms have the same number of bins, the algorithm can be easily
adapted to accept as inputs <span class="math notranslate nohighlight">\(a_{i} \in \mathbb{R}_{+}^{n_{i}}\)</span>
with <span class="math notranslate nohighlight">\(n_{i} \neq n_{j}\)</span> [50].</p>
<p>The function solves the following optimization problem[51]:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}\begin{aligned}
    \underset{\gamma\in\mathbb{R}^{n^{d}}_{+}} {\textrm{min}}
    \sum_{i_1,\ldots,i_d} c(i_1,\ldots, i_d)\, \gamma(i_1,\ldots,i_d)
    \quad \textrm{s.t.}
    \sum_{i_2,\ldots,i_d} \gamma(i_1,\ldots,i_d) &amp;= a_1(i_i),
    (\forall i_1\in[n])\\
    \qquad\vdots\\
    \sum_{i_1,\ldots,i_{d-1}} \gamma(i_1,\ldots,i_d) &amp;= a_{d}(i_{d}),
    (\forall i_d\in[n]).
    \end{aligned}
\end{align}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>nx.ndarray</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – The input ndarray containing distributions of n bins in d dimensions.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, print debugging information during execution. Default=False.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, record log. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>obj</strong> (<em>float</em>) – the value of the primal objective function evaluated at the solution.</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – A dictionary containing the log of the discrete mmot problem:
- ‘A’: a dictionary that maps tuples of indices to the corresponding
primal variables. The tuples are the indices of the entries that are
set to their minimum value during the algorithm.
- ‘primal objective’: a float, the value of the objective function
evaluated at the solution.
- ‘dual’: a list of arrays, the dual variables corresponding to
the input arrays. The i-th element of the list is the dual variable
corresponding to the i-th dimension of the input arrays.
- ‘dual objective’: a float, the value of the dual objective function
evaluated at the solution.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></span>
<p>Ronak Mehta, Jeffery Kline, Vishnu Suresh Lokhande, Glenn Fung, &amp;
Vikas Singh (2023). Efficient Discrete Multi Marginal Optimal
Transport Regularization. In The Eleventh International
Conference on Learning Representations.</p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>56<span class="fn-bracket">]</span></span>
<p>Jeffery Kline. Properties of the d-dimensional earth mover’s
problem. Discrete Applied Mathematics, 265: 128-141, 2019.</p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<p>Leonid V Kantorovich. On the translocation of masses. Dokl. Akad.
Nauk SSSR, 37:227-229, 1942.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.lp.dmmot_monge_1dgrid_optimize" title="ot.lp.dmmot_monge_1dgrid_optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.dmmot_monge_1dgrid_optimize</span></code></a></dt><dd><p>Optimize the d-Dimensional Earth</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mover</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.dmmot_monge_1dgrid_optimize">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">dmmot_monge_1dgrid_optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_decay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.995</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/dmmot.html#dmmot_monge_1dgrid_optimize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.dmmot_monge_1dgrid_optimize" title="Link to this definition"></a></dt>
<dd><p>Minimize the d-dimensional EMD using gradient descent.</p>
<p>Discrete Multi-Marginal Optimal Transport (d-MMOT): Let <span class="math notranslate nohighlight">\(a_1, \ldots,
a_d\in\mathbb{R}^n_{+}\)</span> be discrete probability distributions. Here,
the d-MMOT is the LP,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}\begin{aligned}
    \underset{x\in\mathbb{R}^{n^{d}}_{+}} {\textrm{min}}
    \sum_{i_1,\ldots,i_d} c(i_1,\ldots, i_d)\, x(i_1,\ldots,i_d) \quad
    \textrm{s.t.}
    \sum_{i_2,\ldots,i_d} x(i_1,\ldots,i_d) &amp;= a_1(i_i),
    (\forall i_1\in[n])\\
    \qquad\vdots\\
    \sum_{i_1,\ldots,i_{d-1}} x(i_1,\ldots,i_d) &amp;= a_{d}(i_{d}),
    (\forall i_d\in[n]).
    \end{aligned}
\end{align}\end{split}\]</div>
<p>The dual linear program of the d-MMOT problem is:</p>
<div class="math notranslate nohighlight">
\[\underset{z_j\in\mathbb{R}^n, j\in[d]}{\textrm{maximize}}\qquad\sum_{j}
a_j'z_j\qquad \textrm{subject to}\qquad z_{1}(i_1)+\cdots+z_{d}(i_{d})
\leq c(i_1,\ldots,i_{d}),\]</div>
<p>where the indices in the constraints include all <span class="math notranslate nohighlight">\(i_j\in[n]\)</span>, :math:
<cite>jin[d]</cite>. Denote by <span class="math notranslate nohighlight">\(\phi(a_1,\ldots,a_d)\)</span>, the optimal objective
value of the LP in d-MMOT problem. Let <span class="math notranslate nohighlight">\(z^*\)</span> be an optimal solution
to the dual program. Then,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    \nabla \phi(a_1,\ldots,a_{d}) &amp;= z^*,
    ~~\text{and for any $t\in \mathbb{R}$,}~~
    \phi(a_1,a_2,\ldots,a_{d}) = \sum_{j}a_j'
    (z_j^* + t\, \eta), \nonumber \\
    \text{where } \eta &amp;:= (z_1^{*}(n)\,e, z^*_1(n)\,e, \cdots,
    z^*_{d}(n)\,e)
\end{align}\end{split}\]</div>
<p>Using these dual variables naturally provided by the algorithm in
ot.lp.dmmot_monge_1dgrid_loss, gradient steps move each input distribution
to minimize their d-mmot distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>nx.ndarray</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – The input ndarray containing distributions of n bins in d dimensions.</p></li>
<li><p><strong>niters</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – The maximum number of iterations for the optimization algorithm.</p></li>
<li><p><strong>lr_init</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – The initial learning rate (step size) for the optimization algorithm.</p></li>
<li><p><strong>lr_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.995</em><em>)</em>) – The learning rate decay rate in each iteration.</p></li>
<li><p><strong>print_rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – The rate at which to print the objective value and gradient norm
during the optimization algorithm.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, print debugging information during execution. Default=False.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, record log. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>list of ndarrays, each of shape (n,)</em>) – The optimal solution as a list of n approximate barycenters, each of
length vecsize.</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></span>
<p>Ronak Mehta, Jeffery Kline, Vishnu Suresh Lokhande, Glenn Fung, &amp;
Vikas Singh (2023). Efficient Discrete Multi Marginal Optimal
Transport Regularization. In The Eleventh International
Conference on Learning Representations.</p>
</aside>
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></span>
<p>Olvi L Mangasarian and RR Meyer. Nonlinear perturbation of linear
programs. SIAM Journal on Control and Optimization, 17(6):745-752, 1979</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></span>
<p>Michael C Ferris and Olvi L Mangasarian. Finite perturbation of
convex programs. Applied Mathematics and Optimization, 23(1):263-273,
1991.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.lp.dmmot_monge_1dgrid_loss" title="ot.lp.dmmot_monge_1dgrid_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.dmmot_monge_1dgrid_loss</span></code></a></dt><dd><p>d-Dimensional Earth Mover’s Solver</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#emd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> matrix in numpy needs to be a C-order
numpy.array in float64 format. It will be converted if not in this
format</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data type
of the provided input with the following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="../all.html#references-emd"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Loss matrix (c-order array in numpy with type float64)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost and dual variables.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (ns, nt)</em>) – Optimal transportation matrix for the given
parameters</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – If input log is true, a dictionary containing the
cost and dual variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="go">array([[0.5, 0. ],</span>
<span class="go">       [0. , 0.5]])</span>
</pre></div>
</div>
<p class="rubric" id="id15">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W. (2011,
December).  Displacement interpolation using Lagrangian mass transport.
In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p. 158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id17">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#emd2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id17" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan and
transportation loss to the data type of the provided input with the
following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="../all.html#references-emd2"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Loss matrix (for numpy c-order array with type float64)</p></li>
<li><p><strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Nb of processes used for multiple emd computation (deprecated)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing dual
variables. Otherwise returns only the optimal transportation cost.</p></li>
<li><p><strong>return_matrix</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns the optimal transportation matrix in the log.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float, array-like</em>) – Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is true, a dictionary containing dual
variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric" id="id18">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd2_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd2_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#emd2_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd2_1d" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p>x_a and x_b are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>This implementation only supports metrics
of the form <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id36"><span class="problematic" id="id20">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>(</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>(</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only works with either of the strings
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite>.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, returns math:<cite>gamma</cite> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy’s <cite>coo_matrix</cite>
format. Only used if log is set to True. Due to implementation details,
this function runs faster when dense is set to False.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the transportation matrix.
Otherwise returns only the loss.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float</em>) – Cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is True, a dictionary containing the Optimal transportation
matrix for the given parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd2_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id17" title="ot.lp.emd2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><a class="reference internal" href="#ot.lp.emd_1d" title="ot.lp.emd_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd_1d</span></code></a></dt><dd><p>EMD for 1d distributions (returns the transportation matrix instead of the cost)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#emd_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd_1d" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p>x_a and x_b are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>This implementation only supports metrics
of the form <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id37"><span class="problematic" id="id22">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>(</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>(</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only works with either of the strings
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite>.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, returns math:<cite>gamma</cite> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy’s <cite>coo_matrix</cite>
format. Due to implementation details, this function runs faster when
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite> metrics
are used.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) ndarray</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is True, a dictionary containing the cost</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><a class="reference internal" href="#ot.lp.emd2_1d" title="ot.lp.emd2_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2_1d</span></code></a></dt><dd><p>EMD for 1d distributions (returns cost instead of the transportation matrix)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd_1d_sorted">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd_1d_sorted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ot.lp.emd_1d_sorted" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between sorted 1d measures and
returns the OT matrix and the associated cost</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_weights</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source histogram</p></li>
<li><p><strong>v_weights</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target histogram</p></li>
<li><p><strong>u</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>v</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only works with either of the strings
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite>.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(n, ) ndarray, float64</em>) – Values in the Optimal transportation matrix</p></li>
<li><p><strong>indices</strong> (<em>(n, 2) ndarray, int64</em>) – Indices of the values stored in gamma for the Optimal transportation
matrix</p></li>
<li><p><em>cost</em> – cost associated to the optimal transportation</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id24">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measures_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measures_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id24" title="Link to this definition"></a></dt>
<dd><p>Solves the free support (locations of the barycenters are optimized, not the weights) Wasserstein barycenter problem (i.e. the weighted Frechet mean for the 2-Wasserstein distance), formally:</p>
<div class="math notranslate nohighlight">
\[\min_\mathbf{X} \quad \sum_{i=1}^N w_i W_2^2(\mathbf{b}, \mathbf{X}, \mathbf{a}_i, \mathbf{X}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(w \in \mathbb{(0, 1)}^{N}\)</span>’s are the barycenter weights and sum to one</p></li>
<li><p><cite>measure_weights</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span>: empirical measures weights (on simplex)</p></li>
<li><p><cite>measures_locations</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d}\)</span>: empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{k}\)</span> is the desired weights vector of the barycenter</p></li>
</ul>
<p>This problem is considered in <span class="xref std std-ref">[20]</span> (Algorithm 2).
There are two differences with the following codes:</p>
<ul class="simple">
<li><p>we do not optimize over the weights</p></li>
<li><p>we do not do line search for the locations updates, we use i.e. <span class="math notranslate nohighlight">\(\theta = 1\)</span> in
<span class="xref std std-ref">[20]</span> (Algorithm 2). This can be seen as a discrete
implementation of the fixed-point algorithm of
<span class="xref std std-ref">[43]</span> proposed in the continuous setting.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measures_locations</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – The discrete support of a measure supported on <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>measures_weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Numpy arrays where each numpy array has <span class="math notranslate nohighlight">\(k_i\)</span> non-negatives values summing to one
representing the weights of each discrete input measure</p></li>
<li><p><strong>X_init</strong> (<em>(</em><em>k</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>k</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>X</strong> – Support locations (on k atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(k,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="id25">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, Marco, and Arnaud Doucet. “Fast computation of Wasserstein barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></span>
<p>Álvarez-Esteban, Pedro C., et al. “A fixed-point approach to barycenters in Wasserstein space.” Journal of Mathematical Analysis and Applications 441.2 (2016): 744-762.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id28">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">generalized_free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_bary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#generalized_free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id28" title="Link to this definition"></a></dt>
<dd><p>Solves the free support generalized Wasserstein barycenter problem: finding a barycenter (a discrete measure with
a fixed amount of points of uniform weights) whose respective projections fit the input measures.
More formally:</p>
<div class="math notranslate nohighlight">
\[\min_\gamma \quad \sum_{i=1}^p w_i W_2^2(\nu_i, \mathbf{P}_i\#\gamma)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\gamma = \sum_{l=1}^n b_l\delta_{y_l}\)</span> is the desired barycenter with each <span class="math notranslate nohighlight">\(y_l \in \mathbb{R}^d\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{n}\)</span> is the desired weights vector of the barycenter</p></li>
<li><p>The input measures are <span class="math notranslate nohighlight">\(\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{x_{i,j}}\)</span></p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span> are the respective empirical measures weights (on the simplex)</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d_i}\)</span> are the respective empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(w = (w_1, \cdots w_p)\)</span> are the barycenter coefficients (on the simplex)</p></li>
<li><p>Each <span class="math notranslate nohighlight">\(\mathbf{P}_i \in \mathbb{R}^{d, d_i}\)</span>, and <span class="math notranslate nohighlight">\(P_i\#\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{P_ix_{i,j}}\)</span></p></li>
</ul>
<p>As show by <span class="xref std std-ref">[42]</span>,
this problem can be re-written as a Wasserstein Barycenter problem,
which we solve using the free support method <span class="xref std std-ref">[20]</span>
(Algorithm 2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>d_i</em><em>) </em><em>array-like</em>) – Discrete supports of the input measures: each consists of <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d_i</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>a_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Measure weights: each element is a vector (k_i) on the simplex</p></li>
<li><p><strong>P_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>d_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Each <span class="math notranslate nohighlight">\(P_i\)</span> is a linear map <span class="math notranslate nohighlight">\(\mathbb{R}^{d} \rightarrow \mathbb{R}^{d_i}\)</span></p></li>
<li><p><strong>n_samples_bary</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Number of barycenter points</p></li>
<li><p><strong>Y_init</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter measure (on the simplex)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>p</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (on the simplex)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>eps</strong> (<em>Stability coefficient for the change</em><em> of </em><em>variable matrix inversion</em>) – If the <span class="math notranslate nohighlight">\(\mathbf{P}_i^T\)</span> matrices don’t span <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, the problem is ill-defined and a matrix
inversion will fail. In this case one may set eps=1e-8 and get a solution anyway (which may make little sense)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Y</strong> – Support locations (on n_samples_bary atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(n_samples_bary,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="id29">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, M. and Doucet, A.. “Fast computation of Wasserstein barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id31" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>42<span class="fn-bracket">]</span></span>
<p>Delon, J., Gozlan, N., and Saint-Dizier, A.. Generalized Wasserstein barycenters between probability measures living on different subspaces. arXiv preprint arXiv:2105.09755, 2021.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.semidiscrete_wasserstein2_unif_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">semidiscrete_wasserstein2_unif_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#semidiscrete_wasserstein2_unif_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.semidiscrete_wasserstein2_unif_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the closed-form for the 2-Wasserstein distance between samples and a uniform distribution on <span class="math notranslate nohighlight">\(S^1\)</span>
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<div class="math notranslate nohighlight">
\[W_2^2(\mu_n, \nu) = \sum_{i=1}^n \alpha_i x_i^2 - \left(\sum_{i=1}^n \alpha_i x_i\right)^2 + \sum_{i=1}^n \alpha_i x_i \left(1-\alpha_i-2\sum_{k=1}^{i-1}\alpha_k\right) + \frac{1}{12}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\nu=\mathrm{Unif}(S^1)\)</span> and <span class="math notranslate nohighlight">\(\mu_n  = \sum_{i=1}^n \alpha_i \delta_{x_i}\)</span></p></li>
</ul>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi},\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – Samples</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Cost associated to the optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">semidiscrete_wasserstein2_unif_circle</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="go">array([0.02111111])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></span>
<p>Bonet, C., Berg, P., Courty, N., Septier, F., Drumetz, L., &amp; Pham, M. T. (2023). Spherical sliced-wasserstein. International Conference on Learning Representations.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.wasserstein_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">wasserstein_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#wasserstein_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.wasserstein_1d" title="Link to this definition"></a></dt>
<dd><p>Computes the 1 dimensional OT loss [15] between two (batched) empirical
distributions</p>
<p>It is formally the p-Wasserstein distance raised to the power p.
We do so in a vectorized way by first building the individual quantile functions then integrating them.</p>
<p>This function should be preferred to <cite>emd_1d</cite> whenever the backend is
different to numpy, and when gradients over
either sample positions or weights are required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – locations of the first empirical distribution</p></li>
<li><p><strong>v_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em>) – locations of the second empirical distribution</p></li>
<li><p><strong>u_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – weights of the first empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>v_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – weights of the second empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – order of the ground metric used, should be at least 1 (see [2, Chap. 2], default is 1</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – sort the distributions atoms locations, if False we will consider they have been sorted prior to being passed to
the function, default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>cost</strong> – the batched EMD</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float/array-like, shape (…)</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2018). Computational Optimal Transport.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.wasserstein_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">wasserstein_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#wasserstein_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.wasserstein_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the Wasserstein distance on the circle using either [45] for p=1 or
the binary search algorithm proposed in [44] otherwise.
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it requires to first find the coordinates
using e.g. the atan2 function.</p>
<p>General loss returned:</p>
<div class="math notranslate nohighlight">
\[OT_{loss} = \inf_{\theta\in\mathbb{R}}\int_0^1 |cdf_u^{-1}(q)  - (cdf_v-\theta)^{-1}(q)|^p\ \mathrm{d}q\]</div>
<p>For p=1, [45]</p>
<div class="math notranslate nohighlight">
\[W_1(u,v) = \int_0^1 |F_u(t)-F_v(t)-LevMed(F_u-F_v)|\ \mathrm{d}t\]</div>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the target domain (coordinates on [0,1[)</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Power p used for computing the Wasserstein distance</p></li>
<li><p><strong>Lm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Lower bound dC. For p&gt;1.</p></li>
<li><p><strong>Lp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Upper bound dC. For p&gt;1.</p></li>
<li><p><strong>tm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Lower bound theta. For p&gt;1.</p></li>
<li><p><strong>tp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Upper bound theta. For p&gt;1.</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stopping condition. For p&gt;1.</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, sort the values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Cost associated to the optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wasserstein_circle</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([0.1])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id34" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<p>Hundrieser, Shayan, Marcel Klatt, and Axel Munk. “The statistics of circular optimal transport.” Directional Statistics for Innovative Applications: A Bicentennial Tribute to Florence Nightingale. Singapore: Springer Nature Singapore, 2022. 57-82.</p>
</aside>
<aside class="footnote brackets" id="id35" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></span>
<p>Delon, Julie, Julien Salomon, and Andrei Sobolevski. “Fast transport optimization for Monge costs on the circle.” SIAM Journal on Applied Mathematics 70.7 (2010): 2239-2258.</p>
</aside>
</aside>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.lowrank.html" class="btn btn-neutral float-left" title="ot.lowrank" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.mapping.html" class="btn btn-neutral float-right" title="ot.mapping" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2023, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span> 0.9.6dev0
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>