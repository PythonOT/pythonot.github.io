<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.lp &mdash; POT Python Optimal Transport 0.9.1dev documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.optim" href="ot.optim.html" />
    <link rel="prev" title="ot.gromov" href="ot.gromov.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9.1dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quick start guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.coot.html">ot.coot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.da.html">ot.da</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gaussian.html">ot.gaussian</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.lp</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.center_ot_dual"><code class="docutils literal notranslate"><span class="pre">center_ot_dual()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.check_number_threads"><code class="docutils literal notranslate"><span class="pre">check_number_threads()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.emd"><code class="docutils literal notranslate"><span class="pre">emd()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.emd2"><code class="docutils literal notranslate"><span class="pre">emd2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.estimate_dual_null_weights"><code class="docutils literal notranslate"><span class="pre">estimate_dual_null_weights()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.lp.free_support_barycenter"><code class="docutils literal notranslate"><span class="pre">free_support_barycenter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-lp-free-support-barycenter">Examples using <code class="docutils literal notranslate"><span class="pre">ot.lp.free_support_barycenter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-lp-generalized-free-support-barycenter">Examples using <code class="docutils literal notranslate"><span class="pre">ot.lp.generalized_free_support_barycenter</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../all.html">API and modules</a></li>
      <li class="breadcrumb-item active">ot.lp</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.lp.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.lp">
<span id="ot-lp"></span><h1>ot.lp<a class="headerlink" href="#module-ot.lp" title="Permalink to this heading"></a></h1>
<p>Solvers for the original linear program OT problem.</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.center_ot_dual">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">center_ot_dual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#center_ot_dual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.center_ot_dual" title="Permalink to this definition"></a></dt>
<dd><p>Center dual OT potentials w.r.t. their weights</p>
<p>The main idea of this function is to find unique dual potentials
that ensure some kind of centering/fairness. The main idea is to find dual potentials that lead to the same final objective value for both source and targets (see below for more details). It will help having
stability when multiple calling of the OT solver with small changes.</p>
<p>Basically we add another constraint to the potential that will not
change the objective value but will ensure unicity. The constraint
is the following:</p>
<div class="math notranslate nohighlight">
\[\alpha^T \mathbf{a} = \beta^T \mathbf{b}\]</div>
<p>in addition to the OT problem constraints.</p>
<p>since <span class="math notranslate nohighlight">\(\sum_i a_i=\sum_j b_j\)</span> this can be solved by adding/removing
a constant from both  <span class="math notranslate nohighlight">\(\alpha_0\)</span> and <span class="math notranslate nohighlight">\(\beta_0\)</span>.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}c &amp;= \frac{\beta_0^T \mathbf{b} - \alpha_0^T \mathbf{a}}{\mathbf{1}^T \mathbf{b} + \mathbf{1}^T \mathbf{a}}\\\alpha &amp;= \alpha_0 + c\\\beta &amp;= \beta_0 + c\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha0</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Source dual potential</p></li>
<li><p><strong>beta0</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Target dual potential</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Target histogram (uniform weight if empty list)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>alpha</strong> (<em>(ns,) numpy.ndarray, float64</em>) – Source centered dual potential</p></li>
<li><p><strong>beta</strong> (<em>(nt,) numpy.ndarray, float64</em>) – Target centered dual potential</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.check_number_threads">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">check_number_threads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numThreads</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#check_number_threads"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.check_number_threads" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether or not the requested number of threads has a valid value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – The requested number of threads, should either be a strictly positive integer or “max” or None</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>numThreads</strong> – Corrected number of threads</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)">int</a></p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#emd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd" title="Permalink to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> matrix in numpy needs to be a C-order
numpy.array in float64 format. It will be converted if not in this
format</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data type
of the provided input with the following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="../all.html#references-emd"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Loss matrix (c-order array in numpy with type float64)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost and dual variables.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (ns, nt)</em>) – Optimal transportation matrix for the given
parameters</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – If input log is true, a dictionary containing the
cost and dual variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="go">array([[0.5, 0. ],</span>
<span class="go">       [0. , 0.5]])</span>
</pre></div>
</div>
<p class="rubric" id="references-emd">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W. (2011,
December).  Displacement interpolation using Lagrangian mass transport.
In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p. 158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#id87" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd2">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#emd2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd2" title="Permalink to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan and
transportation loss to the data type of the provided input with the
following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="../all.html#references-emd2"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Loss matrix (for numpy c-order array with type float64)</p></li>
<li><p><strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Nb of processes used for multiple emd computation (deprecated)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing dual
variables. Otherwise returns only the optimal transportation cost.</p></li>
<li><p><strong>return_matrix</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns the optimal transportation matrix in the log.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float, array-like</em>) – Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is true, a dictionary containing dual
variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric" id="references-emd2">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#id87" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.estimate_dual_null_weights">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">estimate_dual_null_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#estimate_dual_null_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.estimate_dual_null_weights" title="Permalink to this definition"></a></dt>
<dd><p>Estimate feasible values for 0-weighted dual potentials</p>
<p>The feasible values are computed efficiently but rather coarsely.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is necessary because the C++ solver in <cite>emd_c</cite>
discards all samples in the distributions with
zeros weights. This means that while the primal variable (transport
matrix) is exact, the solver only returns feasible dual potentials
on the samples with weights different from zero.</p>
</div>
<p>First we compute the constraints violations:</p>
<div class="math notranslate nohighlight">
\[\mathbf{V} = \alpha + \beta^T - \mathbf{M}\]</div>
<p>Next we compute the max amount of violation per row (<span class="math notranslate nohighlight">\(\alpha\)</span>) and
columns (<span class="math notranslate nohighlight">\(beta\)</span>)</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{v^a}_i = \max_j \mathbf{V}_{i,j}\\\mathbf{v^b}_j = \max_i \mathbf{V}_{i,j}\end{aligned}\end{align} \]</div>
<p>Finally we update the dual potential with 0 weights if a
constraint is violated</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\alpha_i = \alpha_i - \mathbf{v^a}_i \quad \text{ if } \mathbf{a}_i=0 \text{ and } \mathbf{v^a}_i&gt;0\\\beta_j = \beta_j - \mathbf{v^b}_j \quad \text{ if } \mathbf{b}_j=0 \text{ and } \mathbf{v^b}_j &gt; 0\end{aligned}\end{align} \]</div>
<p>In the end the dual potentials are centered using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p>
<p>Note that all those updates do not change the objective value of the
solution but provide dual potentials that do not violate the constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha0</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Source dual potential</p></li>
<li><p><strong>beta0</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Target dual potential</p></li>
<li><p><strong>alpha0</strong> – Source dual potential</p></li>
<li><p><strong>beta0</strong> – Target dual potential</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Source distribution (uniform weights if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Target distribution (uniform weights if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.25)"><em>numpy.ndarray</em></a><em>, </em><em>float64</em>) – Loss matrix (c-order array with type float64)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>alpha</strong> (<em>(ns,) numpy.ndarray, float64</em>) – Source corrected dual potential</p></li>
<li><p><strong>beta</strong> (<em>(nt,) numpy.ndarray, float64</em>) – Target corrected dual potential</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.free_support_barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measures_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measures_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.free_support_barycenter" title="Permalink to this definition"></a></dt>
<dd><p>Solves the free support (locations of the barycenters are optimized, not the weights) Wasserstein barycenter problem (i.e. the weighted Frechet mean for the 2-Wasserstein distance), formally:</p>
<div class="math notranslate nohighlight">
\[\min_\mathbf{X} \quad \sum_{i=1}^N w_i W_2^2(\mathbf{b}, \mathbf{X}, \mathbf{a}_i, \mathbf{X}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(w \in \mathbb{(0, 1)}^{N}\)</span>’s are the barycenter weights and sum to one</p></li>
<li><p><cite>measure_weights</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span>: empirical measures weights (on simplex)</p></li>
<li><p><cite>measures_locations</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d}\)</span>: empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{k}\)</span> is the desired weights vector of the barycenter</p></li>
</ul>
<p>This problem is considered in <span class="xref std std-ref">[20]</span> (Algorithm 2).
There are two differences with the following codes:</p>
<ul class="simple">
<li><p>we do not optimize over the weights</p></li>
<li><p>we do not do line search for the locations updates, we use i.e. <span class="math notranslate nohighlight">\(\theta = 1\)</span> in
<span class="xref std std-ref">[20]</span> (Algorithm 2). This can be seen as a discrete
implementation of the fixed-point algorithm of
<span class="xref std std-ref">[43]</span> proposed in the continuous setting.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measures_locations</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – The discrete support of a measure supported on <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>measures_weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Numpy arrays where each numpy array has <span class="math notranslate nohighlight">\(k_i\)</span> non-negatives values summing to one
representing the weights of each discrete input measure</p></li>
<li><p><strong>X_init</strong> (<em>(</em><em>k</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>k</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>X</strong> – Support locations (on k atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(k,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="references-free-support-barycenter">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="note">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, Marco, and Arnaud Doucet. “Fast computation of Wasserstein barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id4" role="note">
<span class="label"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></span>
<p>Álvarez-Esteban, Pedro C., et al. “A fixed-point approach to barycenters in Wasserstein space.” Journal of Mathematical Analysis and Applications 441.2 (2016): 744-762.</p>
</aside>
</aside>
</dd></dl>

<section id="examples-using-ot-lp-free-support-barycenter">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.lp.free_support_barycenter</span></code><a class="headerlink" href="#examples-using-ot-lp-free-support-barycenter" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Illustration of 2D Wasserstein and Sinkhorn barycenters if distributions are weighted sum of Di..."><img alt="" src="../_images/sphx_glr_plot_free_support_barycenter_thumb.png" />
<p><a class="reference internal" href="../auto_examples/barycenters/plot_free_support_barycenter.html#sphx-glr-auto-examples-barycenters-plot-free-support-barycenter-py"><span class="std std-ref">2D free support Wasserstein barycenters of distributions</span></a></p>
  <div class="sphx-glr-thumbnail-title">2D free support Wasserstein barycenters of distributions</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.generalized_free_support_barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">generalized_free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_bary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#generalized_free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.generalized_free_support_barycenter" title="Permalink to this definition"></a></dt>
<dd><p>Solves the free support generalized Wasserstein barycenter problem: finding a barycenter (a discrete measure with
a fixed amount of points of uniform weights) whose respective projections fit the input measures.
More formally:</p>
<div class="math notranslate nohighlight">
\[\min_\gamma \quad \sum_{i=1}^p w_i W_2^2(\nu_i, \mathbf{P}_i\#\gamma)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\gamma = \sum_{l=1}^n b_l\delta_{y_l}\)</span> is the desired barycenter with each <span class="math notranslate nohighlight">\(y_l \in \mathbb{R}^d\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{n}\)</span> is the desired weights vector of the barycenter</p></li>
<li><p>The input measures are <span class="math notranslate nohighlight">\(\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{x_{i,j}}\)</span></p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span> are the respective empirical measures weights (on the simplex)</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d_i}\)</span> are the respective empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(w = (w_1, \cdots w_p)\)</span> are the barycenter coefficients (on the simplex)</p></li>
<li><p>Each <span class="math notranslate nohighlight">\(\mathbf{P}_i \in \mathbb{R}^{d, d_i}\)</span>, and <span class="math notranslate nohighlight">\(P_i\#\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{P_ix_{i,j}}\)</span></p></li>
</ul>
<p>As show by <span class="xref std std-ref">[42]</span>,
this problem can be re-written as a Wasserstein Barycenter problem,
which we solve using the free support method <span class="xref std std-ref">[20]</span>
(Algorithm 2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>d_i</em><em>) </em><em>array-like</em>) – Discrete supports of the input measures: each consists of <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d_i</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>a_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Measure weights: each element is a vector (k_i) on the simplex</p></li>
<li><p><strong>P_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>d_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Each <span class="math notranslate nohighlight">\(P_i\)</span> is a linear map <span class="math notranslate nohighlight">\(\mathbb{R}^{d} \rightarrow \mathbb{R}^{d_i}\)</span></p></li>
<li><p><strong>n_samples_bary</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Number of barycenter points</p></li>
<li><p><strong>Y_init</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter measure (on the simplex)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>p</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (on the simplex)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>eps</strong> (<em>Stability coefficient for the change</em><em> of </em><em>variable matrix inversion</em>) – If the <span class="math notranslate nohighlight">\(\mathbf{P}_i^T\)</span> matrices don’t span <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, the problem is ill-defined and a matrix
inversion will fail. In this case one may set eps=1e-8 and get a solution anyway (which may make little sense)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Y</strong> – Support locations (on n_samples_bary atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(n_samples_bary,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="references-generalized-free-support-barycenter">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, M. and Doucet, A.. “Fast computation of Wasserstein barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span>42<span class="fn-bracket">]</span></span>
<p>Delon, J., Gozlan, N., and Saint-Dizier, A.. Generalized Wasserstein barycenters between probability measures living on different subspaces. arXiv preprint arXiv:2105.09755, 2021.</p>
</aside>
</aside>
</dd></dl>

</section>
<section id="examples-using-ot-lp-generalized-free-support-barycenter">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.lp.generalized_free_support_barycenter</span></code><a class="headerlink" href="#examples-using-ot-lp-generalized-free-support-barycenter" title="Permalink to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example illustrates the computation of Generalized Wasserstein Barycenter as proposed in [..."><img alt="" src="../_images/sphx_glr_plot_generalized_free_support_barycenter_thumb.png" />
<p><a class="reference internal" href="../auto_examples/barycenters/plot_generalized_free_support_barycenter.html#sphx-glr-auto-examples-barycenters-plot-generalized-free-support-barycenter-py"><span class="std std-ref">Generalized Wasserstein Barycenter Demo</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generalized Wasserstein Barycenter Demo</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.lp.barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'interior-point'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/cvx.html#barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.barycenter" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Wasserstein barycenter of distributions A</p>
<blockquote>
<div><p>The function solves the following optimization problem [16]:</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = arg\min_\mathbf{a} \sum_i W_{1}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_1(\cdot,\cdot)\)</span> is the Wasserstein distance (see ot.emd.sinkhorn)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
</ul>
<p>The linear program is solved using the interior point solver from scipy.optimize.
If cvxopt solver if installed it can use cvxopt</p>
<p>Note that this problem do not scale well (both in memory and computational time).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> (</em><em>d</em><em>,</em><em>n</em><em>)</em>) – n training distributions a_i of size d</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>d</em><em>,</em><em>d</em><em>)</em>) – loss matrix   for OT</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Regularization term &gt;0</p></li>
<li><p><strong>weights</strong> (<em>np.ndarray</em><em> (</em><em>n</em><em>,</em><em>)</em>) – Weights of each histogram a_i on the simplex (barycentric coordinates)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>solver</strong> (<em>string</em><em>, </em><em>optional</em>) – the solver used, default ‘interior-point’ use the lp solver from
scipy.optimize. None, or ‘glpk’ or ‘mosek’ use the solver from cvxopt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>(d,) ndarray</em>) – Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<p>Agueh, M., &amp; Carlier, G. (2011). Barycenters in the Wasserstein space. SIAM Journal on Mathematical Analysis, 43(2), 904-924.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.binary_search_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">binary_search_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#binary_search_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.binary_search_circle" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Wasserstein distance on the circle using the Binary search algorithm proposed in [44].
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<div class="math notranslate nohighlight">
\[W_p^p(u,v) = \inf_{\theta\in\mathbb{R}}\int_0^1 |F_u^{-1}(q)  - (F_v-\theta)^{-1}(q)|^p\ \mathrm{d}q\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F_u\)</span> and <span class="math notranslate nohighlight">\(F_v\)</span> are respectively the cdfs of <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span></p></li>
</ul>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the target domain (coordinates on [0,1[)</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Power p used for computing the Wasserstein distance</p></li>
<li><p><strong>Lm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Lower bound dC</p></li>
<li><p><strong>Lp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Upper bound dC</p></li>
<li><p><strong>tm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Lower bound theta</p></li>
<li><p><strong>tp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Upper bound theta</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stopping condition</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, sort the values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, returns also the optimal theta</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float</em>) – Cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – log dictionary returned only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_search_circle</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.1])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<p>Delon, Julie, Julien Salomon, and Andrei Sobolevski. “Fast transport optimization for Monge costs on the circle.” SIAM Journal on Applied Mathematics 70.7 (2010): 2239-2258.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#emd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> matrix in numpy needs to be a C-order
numpy.array in float64 format. It will be converted if not in this
format</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data type
of the provided input with the following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="../all.html#references-emd"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Loss matrix (c-order array in numpy with type float64)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost and dual variables.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (ns, nt)</em>) – Optimal transportation matrix for the given
parameters</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – If input log is true, a dictionary containing the
cost and dual variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="go">array([[0.5, 0. ],</span>
<span class="go">       [0. , 0.5]])</span>
</pre></div>
</div>
<p class="rubric" id="id9">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W. (2011,
December).  Displacement interpolation using Lagrangian mass transport.
In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p. 158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#id87" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id11">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#emd2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id11" title="Permalink to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan and
transportation loss to the data type of the provided input with the
following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="../all.html#references-emd2"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Loss matrix (for numpy c-order array with type float64)</p></li>
<li><p><strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Nb of processes used for multiple emd computation (deprecated)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing dual
variables. Otherwise returns only the optimal transportation cost.</p></li>
<li><p><strong>return_matrix</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns the optimal transportation matrix in the log.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<a class="reference internal" href="#ot.lp.center_ot_dual" title="ot.lp.center_ot_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code></a>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float, array-like</em>) – Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is true, a dictionary containing dual
variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric" id="id12">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id13" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#id87" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd2_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd2_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#emd2_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd2_1d" title="Permalink to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p>x_a and x_b are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>When ‘minkowski’ is used as a metric, <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id30"><span class="problematic" id="id14">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>(</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>(</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only strings listed in <a class="reference internal" href="../all.html#ot.dist" title="ot.dist"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.dist()</span></code></a> are accepted.
Due to implementation details, this function runs faster when
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite> metrics
are used.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, returns math:<cite>gamma</cite> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy’s <cite>coo_matrix</cite>
format. Only used if log is set to True. Due to implementation details,
this function runs faster when dense is set to False.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the transportation matrix.
Otherwise returns only the loss.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float</em>) – Cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is True, a dictionary containing the Optimal transportation
matrix for the given parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd2_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id15" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id11" title="ot.lp.emd2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><a class="reference internal" href="#ot.lp.emd_1d" title="ot.lp.emd_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd_1d</span></code></a></dt><dd><p>EMD for 1d distributions (returns the transportation matrix instead of the cost)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#emd_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd_1d" title="Permalink to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p>x_a and x_b are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>When ‘minkowski’ is used as a metric, <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id31"><span class="problematic" id="id16">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>(</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>(</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em><em>, </em><em>optional</em>) – Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only strings listed in <a class="reference internal" href="../all.html#ot.dist" title="ot.dist"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.dist()</span></code></a> are accepted.
Due to implementation details, this function runs faster when
<cite>‘sqeuclidean’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite> metrics are used.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, returns math:<cite>gamma</cite> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy’s <cite>coo_matrix</cite>
format. Due to implementation details, this function runs faster when
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite> metrics
are used.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost.
Otherwise returns only the optimal transportation matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(ns, nt) ndarray</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is True, a dictionary containing the cost</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id17" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#id0" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><a class="reference internal" href="#ot.lp.emd2_1d" title="ot.lp.emd2_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2_1d</span></code></a></dt><dd><p>EMD for 1d distributions (returns cost instead of the transportation matrix)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id18">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measures_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measures_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id18" title="Permalink to this definition"></a></dt>
<dd><p>Solves the free support (locations of the barycenters are optimized, not the weights) Wasserstein barycenter problem (i.e. the weighted Frechet mean for the 2-Wasserstein distance), formally:</p>
<div class="math notranslate nohighlight">
\[\min_\mathbf{X} \quad \sum_{i=1}^N w_i W_2^2(\mathbf{b}, \mathbf{X}, \mathbf{a}_i, \mathbf{X}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(w \in \mathbb{(0, 1)}^{N}\)</span>’s are the barycenter weights and sum to one</p></li>
<li><p><cite>measure_weights</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span>: empirical measures weights (on simplex)</p></li>
<li><p><cite>measures_locations</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d}\)</span>: empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{k}\)</span> is the desired weights vector of the barycenter</p></li>
</ul>
<p>This problem is considered in <span class="xref std std-ref">[20]</span> (Algorithm 2).
There are two differences with the following codes:</p>
<ul class="simple">
<li><p>we do not optimize over the weights</p></li>
<li><p>we do not do line search for the locations updates, we use i.e. <span class="math notranslate nohighlight">\(\theta = 1\)</span> in
<span class="xref std std-ref">[20]</span> (Algorithm 2). This can be seen as a discrete
implementation of the fixed-point algorithm of
<span class="xref std std-ref">[43]</span> proposed in the continuous setting.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measures_locations</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – The discrete support of a measure supported on <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>measures_weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Numpy arrays where each numpy array has <span class="math notranslate nohighlight">\(k_i\)</span> non-negatives values summing to one
representing the weights of each discrete input measure</p></li>
<li><p><strong>X_init</strong> (<em>(</em><em>k</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>k</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>X</strong> – Support locations (on k atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(k,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="id19">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id20" role="note">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, Marco, and Arnaud Doucet. “Fast computation of Wasserstein barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id21" role="note">
<span class="label"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></span>
<p>Álvarez-Esteban, Pedro C., et al. “A fixed-point approach to barycenters in Wasserstein space.” Journal of Mathematical Analysis and Applications 441.2 (2016): 744-762.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id22">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">generalized_free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_bary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp.html#generalized_free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id22" title="Permalink to this definition"></a></dt>
<dd><p>Solves the free support generalized Wasserstein barycenter problem: finding a barycenter (a discrete measure with
a fixed amount of points of uniform weights) whose respective projections fit the input measures.
More formally:</p>
<div class="math notranslate nohighlight">
\[\min_\gamma \quad \sum_{i=1}^p w_i W_2^2(\nu_i, \mathbf{P}_i\#\gamma)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\gamma = \sum_{l=1}^n b_l\delta_{y_l}\)</span> is the desired barycenter with each <span class="math notranslate nohighlight">\(y_l \in \mathbb{R}^d\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{n}\)</span> is the desired weights vector of the barycenter</p></li>
<li><p>The input measures are <span class="math notranslate nohighlight">\(\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{x_{i,j}}\)</span></p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span> are the respective empirical measures weights (on the simplex)</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d_i}\)</span> are the respective empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(w = (w_1, \cdots w_p)\)</span> are the barycenter coefficients (on the simplex)</p></li>
<li><p>Each <span class="math notranslate nohighlight">\(\mathbf{P}_i \in \mathbb{R}^{d, d_i}\)</span>, and <span class="math notranslate nohighlight">\(P_i\#\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{P_ix_{i,j}}\)</span></p></li>
</ul>
<p>As show by <span class="xref std std-ref">[42]</span>,
this problem can be re-written as a Wasserstein Barycenter problem,
which we solve using the free support method <span class="xref std std-ref">[20]</span>
(Algorithm 2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>d_i</em><em>) </em><em>array-like</em>) – Discrete supports of the input measures: each consists of <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d_i</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>a_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Measure weights: each element is a vector (k_i) on the simplex</p></li>
<li><p><strong>P_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>d_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Each <span class="math notranslate nohighlight">\(P_i\)</span> is a linear map <span class="math notranslate nohighlight">\(\mathbb{R}^{d} \rightarrow \mathbb{R}^{d_i}\)</span></p></li>
<li><p><strong>n_samples_bary</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Number of barycenter points</p></li>
<li><p><strong>Y_init</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter measure (on the simplex)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>p</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (on the simplex)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>eps</strong> (<em>Stability coefficient for the change</em><em> of </em><em>variable matrix inversion</em>) – If the <span class="math notranslate nohighlight">\(\mathbf{P}_i^T\)</span> matrices don’t span <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, the problem is ill-defined and a matrix
inversion will fail. In this case one may set eps=1e-8 and get a solution anyway (which may make little sense)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Y</strong> – Support locations (on n_samples_bary atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(n_samples_bary,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="id23">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id24" role="note">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, M. and Doucet, A.. “Fast computation of Wasserstein barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id25" role="note">
<span class="label"><span class="fn-bracket">[</span>42<span class="fn-bracket">]</span></span>
<p>Delon, J., Gozlan, N., and Saint-Dizier, A.. Generalized Wasserstein barycenters between probability measures living on different subspaces. arXiv preprint arXiv:2105.09755, 2021.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.semidiscrete_wasserstein2_unif_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">semidiscrete_wasserstein2_unif_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#semidiscrete_wasserstein2_unif_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.semidiscrete_wasserstein2_unif_circle" title="Permalink to this definition"></a></dt>
<dd><p>Computes the closed-form for the 2-Wasserstein distance between samples and a uniform distribution on <span class="math notranslate nohighlight">\(S^1\)</span>
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<div class="math notranslate nohighlight">
\[W_2^2(\mu_n, \nu) = \sum_{i=1}^n \alpha_i x_i^2 - \left(\sum_{i=1}^n \alpha_i x_i\right)^2 + \sum_{i=1}^n \alpha_i x_i \left(1-\alpha_i-2\sum_{k=1}^{i-1}\alpha_k\right) + \frac{1}{12}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\nu=\mathrm{Unif}(S^1)\)</span> and <span class="math notranslate nohighlight">\(\mu_n  = \sum_{i=1}^n \alpha_i \delta_{x_i}\)</span></p></li>
</ul>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi},\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – Samples</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Cost associated to the optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)">float</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">semidiscrete_wasserstein2_unif_circle</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="go">array([0.02111111])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id26" role="note">
<span class="label"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></span>
<p>Bonet, C., Berg, P., Courty, N., Septier, F., Drumetz, L., &amp; Pham, M. T. (2023). Spherical sliced-wasserstein. International Conference on Learning Representations.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.wasserstein_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">wasserstein_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#wasserstein_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.wasserstein_1d" title="Permalink to this definition"></a></dt>
<dd><p>Computes the 1 dimensional OT loss [15] between two (batched) empirical
distributions</p>
<p>It is formally the p-Wasserstein distance raised to the power p.
We do so in a vectorized way by first building the individual quantile functions then integrating them.</p>
<p>This function should be preferred to <cite>emd_1d</cite> whenever the backend is
different to numpy, and when gradients over
either sample positions or weights are required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – locations of the first empirical distribution</p></li>
<li><p><strong>v_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em>) – locations of the second empirical distribution</p></li>
<li><p><strong>u_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – weights of the first empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>v_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – weights of the second empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – order of the ground metric used, should be at least 1 (see [2, Chap. 2], default is 1</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – sort the distributions atoms locations, if False we will consider they have been sorted prior to being passed to
the function, default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>cost</strong> – the batched EMD</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float/array-like, shape (…)</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id27" role="note">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2018). Computational Optimal Transport.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.wasserstein_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">wasserstein_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#wasserstein_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.wasserstein_circle" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Wasserstein distance on the circle using either [45] for p=1 or
the binary search algorithm proposed in [44] otherwise.
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it requires to first find the coordinates
using e.g. the atan2 function.</p>
<p>General loss returned:</p>
<div class="math notranslate nohighlight">
\[OT_{loss} = \inf_{\theta\in\mathbb{R}}\int_0^1 |cdf_u^{-1}(q)  - (cdf_v-\theta)^{-1}(q)|^p\ \mathrm{d}q\]</div>
<p>For p=1, [45]</p>
<div class="math notranslate nohighlight">
\[W_1(u,v) = \int_0^1 |F_u(t)-F_v(t)-LevMed(F_u-F_v)|\ \mathrm{d}t\]</div>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the target domain (coordinates on [0,1[)</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Power p used for computing the Wasserstein distance</p></li>
<li><p><strong>Lm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Lower bound dC. For p&gt;1.</p></li>
<li><p><strong>Lp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – Upper bound dC. For p&gt;1.</p></li>
<li><p><strong>tm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Lower bound theta. For p&gt;1.</p></li>
<li><p><strong>tp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Upper bound theta. For p&gt;1.</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – Stopping condition. For p&gt;1.</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, sort the values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Cost associated to the optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)">float</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wasserstein_circle</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([0.1])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id28" role="note">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<p>Hundrieser, Shayan, Marcel Klatt, and Axel Munk. “The statistics of circular optimal transport.” Directional Statistics for Innovative Applications: A Bicentennial Tribute to Florence Nightingale. Singapore: Springer Nature Singapore, 2022. 57-82.</p>
</aside>
<aside class="footnote brackets" id="id29" role="note">
<span class="label"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></span>
<p>Delon, Julie, Julien Salomon, and Andrei Sobolevski. “Fast transport optimization for Monge costs on the circle.” SIAM Journal on Applied Mathematics 70.7 (2010): 2239-2258.</p>
</aside>
</aside>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.gromov.html" class="btn btn-neutral float-left" title="ot.gromov" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.optim.html" class="btn btn-neutral float-right" title="ot.optim" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Rémi Flamary, Nicolas Courty.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span>
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>