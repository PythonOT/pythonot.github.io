

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.lp &mdash; POT Python Optimal Transport 0.9.6dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=6e3d2238"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.mapping" href="ot.mapping.html" />
    <link rel="prev" title="ot.lowrank" href="ot.lowrank.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/plot_quickstart_guide.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.coot.html">ot.coot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.da.html">ot.da</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gaussian.html">ot.gaussian</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gmm.html">ot.gmm</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lowrank.html">ot.lowrank</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.lp</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.NorthWestMMGluing"><code class="docutils literal notranslate"><span class="pre">NorthWestMMGluing()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.barycenter"><code class="docutils literal notranslate"><span class="pre">barycenter()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.binary_search_circle"><code class="docutils literal notranslate"><span class="pre">binary_search_circle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.check_number_threads"><code class="docutils literal notranslate"><span class="pre">check_number_threads()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.dmmot_monge_1dgrid_loss"><code class="docutils literal notranslate"><span class="pre">dmmot_monge_1dgrid_loss()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.dmmot_monge_1dgrid_optimize"><code class="docutils literal notranslate"><span class="pre">dmmot_monge_1dgrid_optimize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.emd"><code class="docutils literal notranslate"><span class="pre">emd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.emd2"><code class="docutils literal notranslate"><span class="pre">emd2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.emd2_1d"><code class="docutils literal notranslate"><span class="pre">emd2_1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.emd_1d"><code class="docutils literal notranslate"><span class="pre">emd_1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.emd_1d_sorted"><code class="docutils literal notranslate"><span class="pre">emd_1d_sorted()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.free_support_barycenter"><code class="docutils literal notranslate"><span class="pre">free_support_barycenter()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.free_support_barycenter_generic_costs"><code class="docutils literal notranslate"><span class="pre">free_support_barycenter_generic_costs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.generalized_free_support_barycenter"><code class="docutils literal notranslate"><span class="pre">generalized_free_support_barycenter()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.linear_circular_ot"><code class="docutils literal notranslate"><span class="pre">linear_circular_ot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.ot_barycenter_energy"><code class="docutils literal notranslate"><span class="pre">ot_barycenter_energy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.semidiscrete_wasserstein2_unif_circle"><code class="docutils literal notranslate"><span class="pre">semidiscrete_wasserstein2_unif_circle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.wasserstein_1d"><code class="docutils literal notranslate"><span class="pre">wasserstein_1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.lp.wasserstein_circle"><code class="docutils literal notranslate"><span class="pre">wasserstein_circle()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.mapping.html">ot.mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../all.html">API and modules</a></li>
      <li class="breadcrumb-item active">ot.lp</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.lp.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.lp">
<span id="ot-lp"></span><h1>ot.lp<a class="headerlink" href="#module-ot.lp" title="Link to this heading"></a></h1>
<p>Solvers for the original linear program OT problem.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.NorthWestMMGluing">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">NorthWestMMGluing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pi_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/_barycenter_solvers.html#NorthWestMMGluing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.NorthWestMMGluing" title="Link to this definition"></a></dt>
<dd><p>Glue transport plans <span class="math notranslate nohighlight">\((\pi_1, ..., \pi_K)\)</span> which have a common first
marginal using the (multi-marginal) North-West Corner method. Writing the
marginals of each <span class="math notranslate nohighlight">\(\pi_k\in \mathbb{R}^{n\times n_l}\)</span> as <span class="math notranslate nohighlight">\(a \in
\mathbb{R}^n\)</span> and <span class="math notranslate nohighlight">\(b_k \in \mathbb{R}^{n_k}\)</span>, the output represents a
particular K-marginal transport plan <span class="math notranslate nohighlight">\(\rho \in
\mathbb{R}^{n_1\times\cdots\times n_K}\)</span> whose k-th marginal is <span class="math notranslate nohighlight">\(b_k\)</span>.
This K-plan is such that there exists a K+1-marginal transport plan
<span class="math notranslate nohighlight">\(\gamma \in \mathbb{R}^{n\times n_1 \times \cdots \times n_K}\)</span> such
that <span class="math notranslate nohighlight">\(\sum_i\gamma_{i,j_1,\cdots,j_K} = \rho_{j_1, \cdots, j_K}\)</span> and
with Einstein summation convention, <span class="math notranslate nohighlight">\(\gamma_{i, j_1, \cdots, j_K} =
[\pi_k]_{i, j_k}\)</span> for all <span class="math notranslate nohighlight">\(k=1,\cdots,K\)</span>.</p>
<p>Instead of outputting the full K-multi-marginal plan <span class="math notranslate nohighlight">\(\rho\)</span>, this
function provides an array <cite>J</cite> of shape (N, K) where each <cite>J[i]</cite> is of the
form <cite>(J[i, 1], …, J[i, K])</cite> with each <cite>J[i, k]</cite> between 0 and
<span class="math notranslate nohighlight">\(n_k-1\)</span>, and a weight vector <cite>w</cite> of size N, such that the K-plan
<span class="math notranslate nohighlight">\(\rho\)</span> writes:</p>
<div class="math notranslate nohighlight">
\[\rho_{j_1, \cdots, j_K} = \mathbb{1}\left(\exists i \text{ s.t. } (j_1, \cdots, j_K) = (J[i, 1], \cdots, J[i, K])\right)\ w_i.\]</div>
<p>This representation is useful for its memory efficiency, as it avoids
storing the full K-marginal plan.</p>
<p>If <cite>log=True</cite>, the function computes the full K+1-marginal transport plan
<span class="math notranslate nohighlight">\(\gamma\)</span> and stores it in log_dict[‘gamma’]. Note that this option is
extremely costly in memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pi_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>arrays</em><em> (</em><em>n</em><em>, </em><em>n_k</em><em>)</em>) – List of transport plans.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, return a log dictionary (computationally expensive).</p></li>
<li><p><strong>a</strong> (<em>array</em><em> (</em><em>n</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – The common first marginal of each transport plan. If None is provided,
it is computed as the first marginal of the first transport plan.</p></li>
<li><p><strong>nx</strong> (<em>backend</em><em>, </em><em>optional</em>) – The backend to use. If None is provided, the backend of the first
transport plan is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>J</strong> (<em>array (N, K)</em>) – The indices (J[i, 1], …, J[i, K]) of the K-plan <span class="math notranslate nohighlight">\(\rho\)</span>.</p></li>
<li><p><strong>w</strong> (<em>array (N,)</em>) – The weights w_i of the K-plan <span class="math notranslate nohighlight">\(\rho\)</span>.</p></li>
<li><p><strong>log_dict</strong> (<em>dict, optional</em>) – If log=True, a dictionary containing the full K+1-marginal transport
plan under the key ‘gamma’.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'highs-ipm'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/_barycenter_solvers.html#barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.barycenter" title="Link to this definition"></a></dt>
<dd><p>Compute the Wasserstein barycenter of distributions A</p>
<blockquote>
<div><p>The function solves the following optimization problem [16]:</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = arg\min_\mathbf{a} \sum_i W_{1}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_1(\cdot,\cdot)\)</span> is the Wasserstein distance (see ot.emd.sinkhorn)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
</ul>
<p>The linear program is solved using the interior point solver from scipy.optimize.
If cvxopt solver if installed it can use cvxopt</p>
<p>Note that this problem do not scale well (both in memory and computational time).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> (</em><em>d</em><em>,</em><em>n</em><em>)</em>) – n training distributions a_i of size d</p></li>
<li><p><strong>M</strong> (<em>np.ndarray</em><em> (</em><em>d</em><em>,</em><em>d</em><em>)</em>) – loss matrix for OT</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Regularization term &gt;0</p></li>
<li><p><strong>weights</strong> (<em>np.ndarray</em><em> (</em><em>n</em><em>,</em><em>)</em>) – Weights of each histogram a_i on the simplex (barycentric coordinates)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>solver</strong> (<em>string</em><em>, </em><em>optional</em>) – the solver used, default ‘interior-point’ use the lp solver from
scipy.optimize. None, or ‘glpk’ or ‘mosek’ use the solver from cvxopt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>(d,) ndarray</em>) – Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<p>Agueh, M., &amp; Carlier, G. (2011). Barycenters in the Wasserstein space. SIAM Journal on Mathematical Analysis, 43(2), 904-924.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.binary_search_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">binary_search_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#binary_search_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.binary_search_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the Wasserstein distance on the circle using the Binary search algorithm proposed in [44].
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<div class="math notranslate nohighlight">
\[W_p^p(u,v) = \inf_{\theta\in\mathbb{R}}\int_0^1 |F_u^{-1}(q)  - (F_v-\theta)^{-1}(q)|^p\ \mathrm{d}q\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F_u\)</span> and <span class="math notranslate nohighlight">\(F_v\)</span> are respectively the cdfs of <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span></p></li>
</ul>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the target domain (coordinates on [0,1[)</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Power p used for computing the Wasserstein distance</p></li>
<li><p><strong>Lm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Lower bound dC</p></li>
<li><p><strong>Lp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Upper bound dC</p></li>
<li><p><strong>tm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Lower bound theta</p></li>
<li><p><strong>tp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Upper bound theta</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stopping condition</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, sort the values.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, returns also the optimal theta</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float/array-like, shape (…)</em>) – Batched cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – log dictionary returned only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_search_circle</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.1])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<p>Delon, Julie, Julien Salomon, and Andrei Sobolevski. “Fast transport optimization for Monge costs on the circle.” SIAM Journal on Applied Mathematics 70.7 (2010): 2239-2258.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.check_number_threads">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">check_number_threads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numThreads</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/utils.html#check_number_threads"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.check_number_threads" title="Link to this definition"></a></dt>
<dd><p>Checks whether or not the requested number of threads has a valid value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – The requested number of threads, should either be a strictly positive integer or “max” or None</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>numThreads</strong> – Corrected number of threads</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.dmmot_monge_1dgrid_loss">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">dmmot_monge_1dgrid_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/dmmot.html#dmmot_monge_1dgrid_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.dmmot_monge_1dgrid_loss" title="Link to this definition"></a></dt>
<dd><p>Compute the discrete multi-marginal optimal transport of distributions A.</p>
<p>This function operates on distributions whose supports are real numbers on
the real line.</p>
<p>The algorithm solves both primal and dual d-MMOT programs concurrently to
produce the optimal transport plan as well as the total (minimal) cost.
The cost is a ground cost, and the solution is independent of
which Monge cost is desired.</p>
<p>The algorithm accepts <span class="math notranslate nohighlight">\(d\)</span> distributions (i.e., histograms)
<span class="math notranslate nohighlight">\(a_{1}, \ldots, a_{d} \in \mathbb{R}_{+}^{n}\)</span> with <span class="math notranslate nohighlight">\(e^{\prime}
a_{j}=1\)</span> for all <span class="math notranslate nohighlight">\(j \in[d]\)</span>. Although the algorithm states that all
histograms have the same number of bins, the algorithm can be easily
adapted to accept as inputs <span class="math notranslate nohighlight">\(a_{i} \in \mathbb{R}_{+}^{n_{i}}\)</span>
with <span class="math notranslate nohighlight">\(n_{i} \neq n_{j}\)</span> [50].</p>
<p>The function solves the following optimization problem[51]:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}\begin{aligned}
    \underset{\gamma\in\mathbb{R}^{n^{d}}_{+}} {\textrm{min}}
    \sum_{i_1,\ldots,i_d} c(i_1,\ldots, i_d)\, \gamma(i_1,\ldots,i_d)
    \quad \textrm{s.t.}
    \sum_{i_2,\ldots,i_d} \gamma(i_1,\ldots,i_d) &amp;= a_1(i_i),
    (\forall i_1\in[n])\\
    \qquad\vdots\\
    \sum_{i_1,\ldots,i_{d-1}} \gamma(i_1,\ldots,i_d) &amp;= a_{d}(i_{d}),
    (\forall i_d\in[n]).
    \end{aligned}
\end{align}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>nx.ndarray</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – The input ndarray containing distributions of n bins in d dimensions.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, print debugging information during execution. Default=False.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, record log. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>obj</strong> (<em>float</em>) – the value of the primal objective function evaluated at the solution.</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – A dictionary containing the log of the discrete mmot problem:
- ‘A’: a dictionary that maps tuples of indices to the corresponding
primal variables. The tuples are the indices of the entries that are
set to their minimum value during the algorithm.
- ‘primal objective’: a float, the value of the objective function
evaluated at the solution.
- ‘dual’: a list of arrays, the dual variables corresponding to
the input arrays. The i-th element of the list is the dual variable
corresponding to the i-th dimension of the input arrays.
- ‘dual objective’: a float, the value of the dual objective function
evaluated at the solution.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></span>
<p>Ronak Mehta, Jeffery Kline, Vishnu Suresh Lokhande, Glenn Fung, &amp;
Vikas Singh (2023). Efficient Discrete Multi Marginal Optimal
Transport Regularization. In The Eleventh International
Conference on Learning Representations.</p>
</aside>
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>56<span class="fn-bracket">]</span></span>
<p>Jeffery Kline. Properties of the d-dimensional earth mover’s
problem. Discrete Applied Mathematics, 265: 128-141, 2019.</p>
</aside>
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>58<span class="fn-bracket">]</span></span>
<p>Leonid V Kantorovich. On the translocation of masses. Dokl. Akad.
Nauk SSSR, 37:227-229, 1942.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.lp.dmmot_monge_1dgrid_optimize" title="ot.lp.dmmot_monge_1dgrid_optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.dmmot_monge_1dgrid_optimize</span></code></a></dt><dd><p>Optimize the d-Dimensional Earth</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mover</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.dmmot_monge_1dgrid_optimize">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">dmmot_monge_1dgrid_optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_decay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.995</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/dmmot.html#dmmot_monge_1dgrid_optimize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.dmmot_monge_1dgrid_optimize" title="Link to this definition"></a></dt>
<dd><p>Minimize the d-dimensional EMD using gradient descent.</p>
<p>Discrete Multi-Marginal Optimal Transport (d-MMOT): Let <span class="math notranslate nohighlight">\(a_1, \ldots,
a_d\in\mathbb{R}^n_{+}\)</span> be discrete probability distributions. Here,
the d-MMOT is the LP,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}\begin{aligned}
    \underset{x\in\mathbb{R}^{n^{d}}_{+}} {\textrm{min}}
    \sum_{i_1,\ldots,i_d} c(i_1,\ldots, i_d)\, x(i_1,\ldots,i_d) \quad
    \textrm{s.t.}
    \sum_{i_2,\ldots,i_d} x(i_1,\ldots,i_d) &amp;= a_1(i_i),
    (\forall i_1\in[n])\\
    \qquad\vdots\\
    \sum_{i_1,\ldots,i_{d-1}} x(i_1,\ldots,i_d) &amp;= a_{d}(i_{d}),
    (\forall i_d\in[n]).
    \end{aligned}
\end{align}\end{split}\]</div>
<p>The dual linear program of the d-MMOT problem is:</p>
<div class="math notranslate nohighlight">
\[\underset{z_j\in\mathbb{R}^n, j\in[d]}{\textrm{maximize}}\qquad\sum_{j}
a_j'z_j\qquad \textrm{subject to}\qquad z_{1}(i_1)+\cdots+z_{d}(i_{d})
\leq c(i_1,\ldots,i_{d}),\]</div>
<p>where the indices in the constraints include all <span class="math notranslate nohighlight">\(i_j\in[n]\)</span>, :math:
<cite>jin[d]</cite>. Denote by <span class="math notranslate nohighlight">\(\phi(a_1,\ldots,a_d)\)</span>, the optimal objective
value of the LP in d-MMOT problem. Let <span class="math notranslate nohighlight">\(z^*\)</span> be an optimal solution
to the dual program. Then,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    \nabla \phi(a_1,\ldots,a_{d}) &amp;= z^*,
    ~~\text{and for any $t\in \mathbb{R}$,}~~
    \phi(a_1,a_2,\ldots,a_{d}) = \sum_{j}a_j'
    (z_j^* + t\, \eta), \nonumber \\
    \text{where } \eta &amp;:= (z_1^{*}(n)\,e, z^*_1(n)\,e, \cdots,
    z^*_{d}(n)\,e)
\end{align}\end{split}\]</div>
<p>Using these dual variables naturally provided by the algorithm in
ot.lp.dmmot_monge_1dgrid_loss, gradient steps move each input distribution
to minimize their d-mmot distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>nx.ndarray</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – The input ndarray containing distributions of n bins in d dimensions.</p></li>
<li><p><strong>niters</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – The maximum number of iterations for the optimization algorithm.</p></li>
<li><p><strong>lr_init</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1e-5</em><em>)</em>) – The initial learning rate (step size) for the optimization algorithm.</p></li>
<li><p><strong>lr_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.995</em><em>)</em>) – The learning rate decay rate in each iteration.</p></li>
<li><p><strong>print_rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100</em><em>)</em>) – The rate at which to print the objective value and gradient norm
during the optimization algorithm.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, print debugging information during execution. Default=False.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, record log. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>list of ndarrays, each of shape (n,)</em>) – The optimal solution as a list of n approximate barycenters, each of
length vecsize.</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>55<span class="fn-bracket">]</span></span>
<p>Ronak Mehta, Jeffery Kline, Vishnu Suresh Lokhande, Glenn Fung, &amp;
Vikas Singh (2023). Efficient Discrete Multi Marginal Optimal
Transport Regularization. In The Eleventh International
Conference on Learning Representations.</p>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>60<span class="fn-bracket">]</span></span>
<p>Olvi L Mangasarian and RR Meyer. Nonlinear perturbation of linear
programs. SIAM Journal on Control and Optimization, 17(6):745-752, 1979</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>59<span class="fn-bracket">]</span></span>
<p>Michael C Ferris and Olvi L Mangasarian. Finite perturbation of
convex programs. Applied Mathematics and Optimization, 23(1):263-273,
1991.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.lp.dmmot_monge_1dgrid_loss" title="ot.lp.dmmot_monge_1dgrid_loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.dmmot_monge_1dgrid_loss</span></code></a></dt><dd><p>d-Dimensional Earth Mover’s Solver</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/_network_simplex.html#emd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = \mathop{\arg \min}_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> matrix in numpy needs to be a C-order
numpy.array in float64 format. It will be converted if not in this
format</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan to the data type
of the provided input with the following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="#references-emd"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Loss matrix (c-order array in numpy with type float64)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost and dual variables.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>array-like, shape (ns, nt)</em>) – Optimal transportation matrix for the given
parameters</p></li>
<li><p><strong>log</strong> (<em>dict, optional</em>) – If input log is true, a dictionary containing the
cost and dual variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="go">array([[0.5, 0. ],</span>
<span class="go">       [0. , 0.5]])</span>
</pre></div>
</div>
<p class="rubric" id="references-emd">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W. (2011,
December).  Displacement interpolation using Lagrangian mass transport.
In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p. 158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd2">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_dual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/_network_simplex.html#emd2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd2" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem and returns the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F\\s.t. \ \gamma \mathbf{1} = \mathbf{a}\\     \gamma^T \mathbf{1} = \mathbf{b}\\     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are the sample weights</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. But the algorithm uses the C++ CPU backend
which can lead to copy overhead on GPU arrays.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will cast the computed transport plan and
transportation loss to the data type of the provided input with the
following priority: <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, then <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>,
then <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> if marginals are not provided.
Casting to an integer tensor might result in a loss of precision.
If this behaviour is unwanted, please make sure to provide a
floating point input.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if the vectors <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> do not sum to the same value.</p>
</div>
<p>Uses the algorithm proposed in <a class="reference internal" href="#references-emd2"><span class="std std-ref">[1]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Source histogram (uniform weight if empty list)</p></li>
<li><p><strong>b</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Target histogram (uniform weight if empty list)</p></li>
<li><p><strong>M</strong> (<em>(</em><em>ns</em><em>,</em><em>nt</em><em>) </em><em>array-like</em><em>, </em><em>float64</em>) – Loss matrix (for numpy c-order array with type float64)</p></li>
<li><p><strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Nb of processes used for multiple emd computation (deprecated)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em><em> (</em><em>default=100000</em><em>)</em>) – The maximum number of iterations before stopping the optimization
algorithm if it has not converged.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing dual
variables. Otherwise returns only the optimal transportation cost.</p></li>
<li><p><strong>return_matrix</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns the optimal transportation matrix in the log.</p></li>
<li><p><strong>center_dual</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, centers the dual potential using function
<code class="xref py py-func docutils literal notranslate"><span class="pre">ot.lp.center_ot_dual()</span></code>.</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float, array-like</em>) – Optimal transportation loss for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is true, a dictionary containing dual
variables and exit status</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd accepts lists and
perform automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span><span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric" id="references-emd2">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bonneel, N., Van De Panne, M., Paris, S., &amp; Heidrich, W.
(2011, December).  Displacement interpolation using Lagrangian mass
transport. In ACM Transactions on Graphics (TOG) (Vol. 30, No. 6, p.
158). ACM.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.bregman.html#ot.bregman.sinkhorn" title="ot.bregman.sinkhorn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.bregman.sinkhorn</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd2_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd2_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#emd2_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd2_1d" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the loss</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p><span class="math notranslate nohighlight">\(x_a\)</span> and <span class="math notranslate nohighlight">\(x_b\)</span> are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>This implementation only supports metrics
of the form <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id30"><span class="problematic" id="id11">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>ndarray</em><em> of </em><em>float64</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>)</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>ndarray</em><em> of </em><em>float64</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>)</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>ndarray</em><em> of </em><em>float64</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>ndarray</em><em> of </em><em>float64</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only works with either of the strings
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite>.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, returns <span class="math notranslate nohighlight">\(\gamma\)</span> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy’s <cite>coo_matrix</cite>
format. Only used if log is set to True. Due to implementation details,
this function runs faster when dense is set to False.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the transportation matrix.
Otherwise returns only the loss.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss</strong> (<em>float</em>) – Cost associated to the optimal transportation</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is True, a dictionary containing the Optimal transportation
matrix for the given parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd2_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd2_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.lp.emd2" title="ot.lp.emd2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><a class="reference internal" href="#ot.lp.emd_1d" title="ot.lp.emd_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd_1d</span></code></a></dt><dd><p>EMD for 1d distributions (returns the transportation matrix instead of the cost)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_marginals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#emd_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.emd_1d" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between 1d measures and returns
the OT matrix</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\gamma = arg\min_\gamma \sum_i \sum_j \gamma_{ij} d(x_a[i], x_b[j])\\s.t. \gamma 1 = a,
     \gamma^T 1= b,
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p>d is the metric</p></li>
<li><p><span class="math notranslate nohighlight">\(x_a\)</span> and <span class="math notranslate nohighlight">\(x_b\)</span> are the samples</p></li>
<li><p>a and b are the sample weights</p></li>
</ul>
<p>This implementation only supports metrics
of the form <span class="math notranslate nohighlight">\(d(x, y) = |x - y|^p\)</span>.</p>
<p>Uses the algorithm detailed in <a href="#id31"><span class="problematic" id="id13">[1]_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> (<em>ndarray</em><em> of </em><em>float64</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>)</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>x_b</strong> (<em>ndarray</em><em> of </em><em>float64</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>,</em><em>) or </em><em>(</em><em>ns</em><em>, </em><em>1</em><em>)</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>a</strong> (<em>ndarray</em><em> of </em><em>float64</em><em>, </em><em>shape</em><em> (</em><em>ns</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Source histogram (default is uniform weight)</p></li>
<li><p><strong>b</strong> (<em>ndarray</em><em> of </em><em>float64</em><em>, </em><em>shape</em><em> (</em><em>nt</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Target histogram (default is uniform weight)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only works with either of the strings
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite>.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
<li><p><strong>dense</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, returns <span class="math notranslate nohighlight">\(\gamma\)</span> as a dense ndarray of shape (ns, nt).
Otherwise returns a sparse representation using scipy’s <cite>coo_matrix</cite>
format. Due to implementation details, this function runs faster when
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite> metrics
are used.</p></li>
<li><p><strong>log</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, returns a dictionary containing the cost.
Otherwise returns only the optimal transportation matrix.</p></li>
<li><p><strong>check_marginals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, checks that the marginals mass are equal. If False, skips the
check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>ndarray, shape (ns, nt)</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – If input log is True, a dictionary containing the cost</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple example with obvious solution. The function emd_1d accepts lists and
performs automatic conversion to numpy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_b</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">emd_1d</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)</span>
<span class="go">array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>EMD for multidimensional distributions</p>
</dd>
<dt><a class="reference internal" href="#ot.lp.emd2_1d" title="ot.lp.emd2_1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2_1d</span></code></a></dt><dd><p>EMD for 1d distributions (returns cost instead of the transportation matrix)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.emd_1d_sorted">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">emd_1d_sorted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ot.lp.emd_1d_sorted" title="Link to this definition"></a></dt>
<dd><p>Solves the Earth Movers distance problem between sorted 1d measures and
returns the OT matrix and the associated cost</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_weights</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source histogram</p></li>
<li><p><strong>v_weights</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target histogram</p></li>
<li><p><strong>u</strong> (<em>(</em><em>ns</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Source dirac locations (on the real line)</p></li>
<li><p><strong>v</strong> (<em>(</em><em>nt</em><em>,</em><em>) </em><em>ndarray</em><em>, </em><em>float64</em>) – Target dirac locations (on the real line)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em><em> (</em><em>default='sqeuclidean'</em><em>)</em>) – Metric to be used. Only works with either of the strings
<cite>‘sqeuclidean’</cite>, <cite>‘minkowski’</cite>, <cite>‘cityblock’</cite>,  or <cite>‘euclidean’</cite>.</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1.0</em><em>)</em>) – The p-norm to apply for if metric=’minkowski’</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(n, ) ndarray, float64</em>) – Values in the Optimal transportation matrix</p></li>
<li><p><strong>indices</strong> (<em>(n, 2) ndarray, int64</em>) – Indices of the values stored in gamma for the Optimal transportation
matrix</p></li>
<li><p><em>cost</em> – cost associated to the optimal transportation</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.free_support_barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measures_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measures_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/_barycenter_solvers.html#free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.free_support_barycenter" title="Link to this definition"></a></dt>
<dd><p>Solves the free support (locations of the barycenters are optimized, not the weights) Wasserstein barycenter problem (i.e. the weighted Frechet mean for the 2-Wasserstein distance), formally:</p>
<div class="math notranslate nohighlight">
\[\min_\mathbf{X} \quad \sum_{i=1}^N w_i W_2^2(\mathbf{b}, \mathbf{X}, \mathbf{a}_i, \mathbf{X}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(w \in \mathbb{(0, 1)}^{N}\)</span>’s are the barycenter weights and sum to one</p></li>
<li><p><cite>measure_weights</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span>: empirical measures weights (on simplex)</p></li>
<li><p><cite>measures_locations</cite> denotes the <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d}\)</span>: empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{k}\)</span> is the desired weights vector of the barycenter</p></li>
</ul>
<p>This problem is considered in <a class="reference internal" href="ot.bregman.html#references-free-support-barycenter"><span class="std std-ref">[20]</span></a> (Algorithm 2).
There are two differences with the following codes:</p>
<ul class="simple">
<li><p>we do not optimize over the weights</p></li>
<li><p>we do not do line search for the locations updates, we use i.e. <span class="math notranslate nohighlight">\(\theta = 1\)</span> in
<a class="reference internal" href="ot.bregman.html#references-free-support-barycenter"><span class="std std-ref">[20]</span></a> (Algorithm 2). This can be seen as a discrete
implementation of the fixed-point algorithm of
<a class="reference internal" href="ot.bregman.html#references-free-support-barycenter"><span class="std std-ref">[43]</span></a> proposed in the continuous setting.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measures_locations</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – The discrete support of a measure supported on <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>measures_weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>N</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Numpy arrays where each numpy array has <span class="math notranslate nohighlight">\(k_i\)</span> non-negatives values summing to one
representing the weights of each discrete input measure</p></li>
<li><p><strong>X_init</strong> (<em>(</em><em>k</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>k</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (non-negatives, sum to 1)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>X</strong> (<em>(k,d) array-like</em>) – Support locations (on k atoms) of the barycenter</p></li>
<li><p><em>.. _references-free-support-barycenter</em></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id15" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, Marco, and Arnaud Doucet. “Fast computation of Wasserstein barycenters.”
International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></span>
<p>Álvarez-Esteban, Pedro C., et al. “A fixed-point approach to barycenters in Wasserstein space.”
Journal of Mathematical Analysis and Applications 441.2 (2016): 744-762.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.free_support_barycenter_generic_costs">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">free_support_barycenter_generic_costs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cost_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ground_bary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L2_barycentric_proj'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ground_bary_lr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ground_bary_numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ground_bary_stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ground_bary_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SGD'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean_measure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/_barycenter_solvers.html#free_support_barycenter_generic_costs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.free_support_barycenter_generic_costs" title="Link to this definition"></a></dt>
<dd><p>Solves the OT barycenter problem [77] for generic costs using the fixed
point algorithm, iterating the ground barycenter function B on transport
plans between the current barycenter and the measures.</p>
<p>The problem finds an optimal barycenter support <cite>X</cite> of given size (n, d)
(enforced by the initialisation), minimising a sum of pairwise transport
costs for the costs <span class="math notranslate nohighlight">\(c_k\)</span>:</p>
<div class="math notranslate nohighlight">
\[\min_{X} \sum_{k=1}^K \mathcal{T}_{c_k}(X, a, Y_k, b_k),\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(X\)</span> (n, d) is the barycenter support,</p></li>
<li><p><span class="math notranslate nohighlight">\(a\)</span> (n) is the (fixed) barycenter weights,</p></li>
<li><p><span class="math notranslate nohighlight">\(Y_k\)</span> (m_k, d_k) is the k-th measure support
(<cite>measure_locations[k]</cite>),</p></li>
<li><p><span class="math notranslate nohighlight">\(b_k\)</span> (m_k) is the k-th measure weights (<cite>measure_weights[k]</cite>),</p></li>
<li><p><span class="math notranslate nohighlight">\(c_k: \mathbb{R}^{n\times d}\times\mathbb{R}^{m_k\times d_k}\rightarrow \mathbb{R}_+^{n\times m_k}\)</span> is the k-th cost function (which computes the pairwise cost matrix)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{T}_{c_k}(X, a, Y_k, b)\)</span> is the OT cost between the barycenter measure and the k-th measure with respect to the cost <span class="math notranslate nohighlight">\(c_k\)</span>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathcal{T}_{c_k}(X, a, Y_k, b_k) = \min_\pi \quad \langle \pi, c_k(X, Y_k) \rangle_F\\s.t. \ \pi \mathbf{1} = \mathbf{a}\\     \pi^T \mathbf{1} = \mathbf{b_k}\\     \pi \geq 0\end{aligned}\end{align} \]</div>
<p>in other words, <span class="math notranslate nohighlight">\(\mathcal{T}_{c_k}(X, a, Y_k, b_k)\)</span> is <cite>ot.emd2(a, b_k, c_k(X, Y_k))</cite>.</p>
<p>The function <span class="math notranslate nohighlight">\(B:\mathbb{R}^{n\times d_1}\times
\cdots\times\mathbb{R}^{n\times d_K} \longrightarrow \mathbb{R}^{n\times d}\)</span>
is an input to the solver. <cite>B</cite> computes solutions of the following
minimisation problem given <span class="math notranslate nohighlight">\((Y_1, \cdots, Y_K) \in \mathbb{R}^{n\times
d_1}\times\cdots\times\mathbb{R}^{n\times d_K}\)</span> (broadcasted along <cite>n</cite>):</p>
<div class="math notranslate nohighlight">
\[B(y_1, \cdots, y_K) = \mathrm{argmin}_{x \in \mathbb{R}^d} \sum_{k=1}^K c_k(x, y_k),\]</div>
<p>The input function B takes a list of K arrays of shape (n, d_k) and returns
an array of shape (n, d). For certain costs, <span class="math notranslate nohighlight">\(B\)</span> can be computed
explicitly, or through a numerical solver.</p>
<p>This function implements two algorithms:</p>
<ul class="simple">
<li><p>Algorithm 2 from [77] when <cite>method=true_fixed_point</cite> is used, which may
increase the support size of the barycenter at each iteration, with a
maximum final size of <span class="math notranslate nohighlight">\(N_0 + T\sum_k n_k - TK\)</span> for T iterations and
an initial support size of <span class="math notranslate nohighlight">\(N_0\)</span>. The computation of the iterates is
done using the North West Corner multi-marginal gluing method. This method
has convergence guarantees [77].</p></li>
<li><p>Algorithm 3 from [77] when <cite>method=L2_barycentric_proj</cite> is used, which is
a heuristic simplification which fixes the weights and support size of the
barycenter by performing barycentric projections of the pair-wise OT
matrices. This method is substantially faster than the first one, but does
not have convergence guarantees. (Default)</p></li>
</ul>
<p>The implemented methods ([77] Algorithms 2 and 3), generalises [20] and [43]
to general costs and includes convergence guarantees, including for discrete
measures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measure_locations</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>array-like</em>) – List of K arrays of measure positions, each of shape (m_k, d_k).</p></li>
<li><p><strong>measure_weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>array-like</em>) – List of K arrays of measure weights, each of shape (m_k).</p></li>
<li><p><strong>X_init</strong> (<em>array-like</em>) – Array of shape (n, d) representing initial barycenter points.</p></li>
<li><p><strong>cost_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>callable</em><em> or </em><em>callable</em>) – List of K cost functions <span class="math notranslate nohighlight">\(c_k: \mathbb{R}^{n\times
d}\times\mathbb{R}^{m_k\times d_k} \rightarrow \mathbb{R}_+^{n\times
m_k}\)</span>. If cost_list is a single callable, the same cost is used K times.</p></li>
<li><p><strong>ground_bary</strong> (<em>callable</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Function List(array(n, d_k)) -&gt; array(n, d) accepting a list of K arrays
of shape <span class="math notranslate nohighlight">\((n\times d_K)\)</span>, computing the ground barycenters
(broadcasted over n). If not provided, done with Adam on PyTorch
(requires PyTorch backend), inefficiently using the cost functions in
<cite>cost_list</cite>.</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>optional</em>) – Array of shape (n,) representing weights of the barycenter
measure.Defaults to uniform.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Maximum number of iterations (default is 100).</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) – Barycentre method: ‘L2_barycentric_proj’ (default) for Euclidean
barycentric projection, or ‘true_fixed_point’ for iterates using the
North West Corner multi-marginal gluing method.</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – If <span class="math notranslate nohighlight">\(W_2^2(a_t, X_t, a_{t+1}, X_{t+1}) &lt; \mathrm{stopThr} \times
\frac{1}{n}\|X_t\|_2^2\)</span>, terminate (default is 1e-5).</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to return the log dictionary (default is False).</p></li>
<li><p><strong>ground_bary_lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Learning rate for the ground barycenter solver (if auto is used).</p></li>
<li><p><strong>ground_bary_numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Maximum number of iterations for the ground barycenter solver (if auto
is used).</p></li>
<li><p><strong>ground_bary_stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold for the ground barycenter solver (if auto is used): stop
if the energy decreases less than this value.</p></li>
<li><p><strong>ground_bary_solver</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) – Solver for auto ground bary solver (torch SGD or Adam). Default is
“SGD”.</p></li>
<li><p><strong>clean_measure</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – For method==’true_fixed_point’, whether to clean the discrete measure
(X, a) at each iteration to remove duplicate points and sum their
weights (default is False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em>) – Array of shape (n, d) representing barycenter points.</p></li>
<li><p><strong>log_dict</strong> (<em>list of array-like, optional</em>) – log containing the exit status, list of iterations and list of
displacements if log is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>77<span class="fn-bracket">]</span></span>
<p>Tanguy, Eloi and Delon, Julie and Gozlan, Nathaël (2024). Computing
barycenters of Measures for Generic Transport Costs. arXiv preprint
2501.04016 (2024)</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, Marco, and Arnaud Doucet. “Fast computation of Wasserstein
barycenters.” International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>43<span class="fn-bracket">]</span></span>
<p>Álvarez-Esteban, Pedro C., et al. “A fixed-point approach to
barycenters in Wasserstein space.” Journal of Mathematical Analysis and
Applications 441.2 (2016): 744-762.</p>
</aside>
</aside>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the case of the L2 cost <span class="math notranslate nohighlight">\(c_k(x, y) = \|x-y\|_2^2\)</span>,
the ground barycenter is simply the Euclidean barycenter, i.e.
<span class="math notranslate nohighlight">\(B(y_1, \cdots, y_K) = \sum_k w_k y_k\)</span>. In this case, we recover
the free-support algorithm from [20].</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ot.lp.free_support_barycenter : Free support solver for the case where
<span class="math notranslate nohighlight">\(c_k(x,y) = \lambda_k\|x-y\|_2^2\)</span>.</p>
<p>ot.lp.generalized_free_support_barycenter : Free support solver for the case
where <span class="math notranslate nohighlight">\(c_k(x,y) = \|P_kx-y\|_2^2\)</span> with <span class="math notranslate nohighlight">\(P_k\)</span> linear.</p>
<p>ot.lp.NorthWestMMGluing : gluing method used in the <cite>true_fixed_point</cite>
method.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.generalized_free_support_barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">generalized_free_support_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_bary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/_barycenter_solvers.html#generalized_free_support_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.generalized_free_support_barycenter" title="Link to this definition"></a></dt>
<dd><p>Solves the free support generalized Wasserstein barycenter problem: finding a barycenter (a discrete measure with
a fixed amount of points of uniform weights) whose respective projections fit the input measures.
More formally:</p>
<div class="math notranslate nohighlight">
\[\min_\gamma \quad \sum_{i=1}^p w_i W_2^2(\nu_i, \mathbf{P}_i\#\gamma)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\gamma = \sum_{l=1}^n b_l\delta_{y_l}\)</span> is the desired barycenter with each <span class="math notranslate nohighlight">\(y_l \in \mathbb{R}^d\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b} \in \mathbb{R}^{n}\)</span> is the desired weights vector of the barycenter</p></li>
<li><p>The input measures are <span class="math notranslate nohighlight">\(\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{x_{i,j}}\)</span></p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{a}_i \in \mathbb{R}^{k_i}\)</span> are the respective empirical measures weights (on the simplex)</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\mathbf{X}_i \in \mathbb{R}^{k_i, d_i}\)</span> are the respective empirical measures atoms locations</p></li>
<li><p><span class="math notranslate nohighlight">\(w = (w_1, \cdots w_p)\)</span> are the barycenter coefficients (on the simplex)</p></li>
<li><p>Each <span class="math notranslate nohighlight">\(\mathbf{P}_i \in \mathbb{R}^{d, d_i}\)</span>, and <span class="math notranslate nohighlight">\(P_i\#\nu_i = \sum_{j=1}^{k_i}a_{i,j}\delta_{P_ix_{i,j}}\)</span></p></li>
</ul>
<p>As show by <a class="reference internal" href="#references-generalized-free-support-barycenter"><span class="std std-ref">[42]</span></a>,
this problem can be re-written as a Wasserstein Barycenter problem,
which we solve using the free support method <a class="reference internal" href="#references-generalized-free-support-barycenter"><span class="std std-ref">[20]</span></a>
(Algorithm 2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>d_i</em><em>) </em><em>array-like</em>) – Discrete supports of the input measures: each consists of <span class="math notranslate nohighlight">\(k_i\)</span> locations of a <cite>d_i</cite>-dimensional space
(<span class="math notranslate nohighlight">\(k_i\)</span> can be different for each element of the list)</p></li>
<li><p><strong>a_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>k_i</em><em>,</em><em>) </em><em>array-like</em>) – Measure weights: each element is a vector (k_i) on the simplex</p></li>
<li><p><strong>P_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>p</em><em> (</em><em>d_i</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Each <span class="math notranslate nohighlight">\(P_i\)</span> is a linear map <span class="math notranslate nohighlight">\(\mathbb{R}^{d} \rightarrow \mathbb{R}^{d_i}\)</span></p></li>
<li><p><strong>n_samples_bary</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Number of barycenter points</p></li>
<li><p><strong>Y_init</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>d</em><em>) </em><em>array-like</em>) – Initialization of the support locations (on <cite>k</cite> atoms) of the barycenter</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n_samples_bary</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the weights of the barycenter measure (on the simplex)</p></li>
<li><p><strong>weights</strong> (<em>(</em><em>p</em><em>,</em><em>) </em><em>array-like</em>) – Initialization of the coefficients of the barycenter (on the simplex)</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>numThreads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>&quot;max&quot;</em><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>, </em><em>i.e. OpenMP is not used</em><em>)</em>) – If compiled with OpenMP, chooses the number of threads to parallelize.
“max” selects the highest number possible.</p></li>
<li><p><strong>eps</strong> (<em>Stability coefficient for the change</em><em> of </em><em>variable matrix inversion</em>) – If the <span class="math notranslate nohighlight">\(\mathbf{P}_i^T\)</span> matrices don’t span <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, the problem is ill-defined and a matrix
inversion will fail. In this case one may set eps=1e-8 and get a solution anyway (which may make little sense)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Y</strong> – Support locations (on n_samples_bary atoms) of the barycenter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(n_samples_bary,d) array-like</p>
</dd>
</dl>
<p class="rubric" id="references-generalized-free-support-barycenter">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></span>
<p>Cuturi, M. and Doucet, A.. “Fast computation of Wasserstein barycenters.”
International Conference on Machine Learning. 2014.</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>42<span class="fn-bracket">]</span></span>
<p>Delon, J., Gozlan, N., and Saint-Dizier, A.. Generalized Wasserstein barycenters
between probability measures living on different subspaces.
arXiv preprint arXiv:2105.09755, 2021.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.linear_circular_ot">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">linear_circular_ot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#linear_circular_ot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.linear_circular_ot" title="Link to this definition"></a></dt>
<dd><p>Computes the Linear Circular Optimal Transport distance from <a class="reference internal" href="#references-lcot"><span class="std std-ref">[78]</span></a> using <span class="math notranslate nohighlight">\(\eta=\mathrm{Unif}(S^1)\)</span>
as reference measure.
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<p>General loss returned:</p>
<div class="math notranslate nohighlight">
\[\mathrm{LCOT}_2^2(\mu, \nu) = \int_0^1 d_{S^1}\big(\hat{\mu}(t), \hat{\nu}(t)\big)^2\ \mathrm{d}t\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\mu}(x)=F_{\mu}^{-1}(x-\int z\mathrm{d}\mu(z)+\frac12) - x\)</span> for all <span class="math notranslate nohighlight">\(x\in [0,1[\)</span>,
and <span class="math notranslate nohighlight">\(d_{S^1}(x,y)=\min(|x-y|, 1-|x-y|)\)</span> for <span class="math notranslate nohighlight">\(x,y\in [0,1[\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples in the target domain (coordinates on [0,1[), if None, compute distance against uniform distribution</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Batched cost associated to the linear optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float/array-like, shape (…)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_circular_ot</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([0.0127])</span>
</pre></div>
</div>
<p class="rubric" id="references-lcot">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>78<span class="fn-bracket">]</span></span>
<p>Martin, R. D., Medri, I., Bai, Y., Liu, X., Yan, K., Rohde, G. K., &amp; Kolouri, S. (2024). LCOT: Linear Circular Optimal Transport. International Conference on Learning Representations.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.ot_barycenter_energy">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">ot_barycenter_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cost_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/_barycenter_solvers.html#ot_barycenter_energy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.ot_barycenter_energy" title="Link to this definition"></a></dt>
<dd><p>Computes the energy of the OT barycenter functional for a given barycenter
support <cite>X</cite> and weights <cite>a</cite>: .. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">}</span><span class="o">^</span><span class="n">K</span> <span class="n">w_k</span> \<span class="n">mathcal</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">c_k</span><span class="p">}(</span><span class="n">X</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Y_k</span><span class="p">,</span> <span class="n">b_k</span><span class="p">),</span>
</pre></div>
</div>
<p>where: - <span class="math notranslate nohighlight">\(X\)</span> (n, d) is the barycenter support, - <span class="math notranslate nohighlight">\(a\)</span> (n) is the
barycenter weights, - <span class="math notranslate nohighlight">\(Y_k\)</span> (m_k, d_k) is the k-th measure support</p>
<blockquote>
<div><p>(<cite>measure_locations[k]</cite>),</p>
</div></blockquote>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(b_k\)</span> (m_k) is the k-th measure weights (<cite>measure_weights[k]</cite>),</p></li>
<li><dl class="simple">
<dt>:math:<a href="#id23"><span class="problematic" id="id24">`</span></a>c_k: mathbb{R}^{ntimes d}timesmathbb{R}^{m_ktimes d_k}</dt><dd><p>rightarrow mathbb{R}_+^{ntimes m_k}` is the k-th cost function
(which computes the pairwise cost matrix)</p>
</dd>
</dl>
</li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{T}_{c_k}(X, a, Y_k, b)\)</span> is the OT cost between the
barycenter measure and the k-th measure with respect to the cost
<span class="math notranslate nohighlight">\(c_k\)</span>.</p></li>
</ul>
<p>The function computes <span class="math notranslate nohighlight">\(V(X, a)\)</span> as defined above.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>measure_locations</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>array-like</em>) – List of K arrays of measure positions, each of shape (m_k, d_k).</p></li>
<li><p><strong>measure_weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>array-like</em>) – List of K arrays of measure weights, each of shape (m_k).</p></li>
<li><p><strong>X</strong> (<em>array-like</em>) – Array of shape (n, d) representing barycenter points.</p></li>
<li><p><strong>a</strong> (<em>array-like</em>) – Array of shape (n,) representing barycenter weights.</p></li>
<li><p><strong>cost_list</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>callable</em><em> or </em><em>callable</em>) – List of K cost functions <span class="math notranslate nohighlight">\(c_k: \mathbb{R}^{n\times
d}\times\mathbb{R}^{m_k\times d_k} \rightarrow \mathbb{R}_+^{n\times
m_k}\)</span>. If cost_list is a single callable, the same cost is used K times.</p></li>
<li><p><strong>nx</strong> (<em>backend</em><em>, </em><em>optional</em>) – The backend to use.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>V</strong> – The value of the OT barycenter functional <span class="math notranslate nohighlight">\(V(X, a)\)</span>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id25" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>77<span class="fn-bracket">]</span></span>
<p>Tanguy, Eloi and Delon, Julie and Gozlan, Nathaël (2024). Computing
barycenters of Measures for Generic Transport Costs. arXiv preprint
2501.04016 (2024)</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.lp.free_support_barycenter_generic_costs" title="ot.lp.free_support_barycenter_generic_costs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.free_support_barycenter_generic_costs</span></code></a></dt><dd><p>Free support solver for the</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">associated</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.semidiscrete_wasserstein2_unif_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">semidiscrete_wasserstein2_unif_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#semidiscrete_wasserstein2_unif_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.semidiscrete_wasserstein2_unif_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the closed-form for the 2-Wasserstein distance between samples and a uniform distribution on <span class="math notranslate nohighlight">\(S^1\)</span>
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it is required to first find the coordinates
using e.g. the atan2 function.</p>
<div class="math notranslate nohighlight">
\[W_2^2(\mu_n, \nu) = \sum_{i=1}^n \alpha_i x_i^2 - \left(\sum_{i=1}^n \alpha_i x_i\right)^2 + \sum_{i=1}^n \alpha_i x_i \left(1-\alpha_i-2\sum_{k=1}^{i-1}\alpha_k\right) + \frac{1}{12}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\nu=\mathrm{Unif}(S^1)\)</span> and <span class="math notranslate nohighlight">\(\mu_n  = \sum_{i=1}^n \alpha_i \delta_{x_i}\)</span></p></li>
</ul>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi},\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – Samples</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Batched cost associated to the optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float/array-like, shape (…)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">semidiscrete_wasserstein2_unif_circle</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="go">array([0.02111111])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>46<span class="fn-bracket">]</span></span>
<p>Bonet, C., Berg, P., Courty, N., Septier, F., Drumetz, L., &amp; Pham, M. T. (2023). Spherical sliced-wasserstein. International Conference on Learning Representations.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.wasserstein_1d">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">wasserstein_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#wasserstein_1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.wasserstein_1d" title="Link to this definition"></a></dt>
<dd><p>Computes the 1 dimensional OT loss [15] between two (batched) empirical
distributions</p>
<p>It is formally the p-Wasserstein distance raised to the power p.
We do so in a vectorized way by first building the individual quantile functions then integrating them.</p>
<p>This function should be preferred to <cite>emd_1d</cite> whenever the backend is
different to numpy, and when gradients over
either sample positions or weights are required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – locations of the first empirical distribution</p></li>
<li><p><strong>v_values</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em>) – locations of the second empirical distribution</p></li>
<li><p><strong>u_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – weights of the first empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>v_weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>m</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – weights of the second empirical distribution, if None then uniform weights are used</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – order of the ground metric used, should be at least 1 (see [2, Chap. 2], default is 1</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – sort the distributions atoms locations, if False we will consider they have been sorted prior to being passed to
the function, default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>cost</strong> – the batched EMD</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float/array-like, shape (…)</p>
</dd>
</dl>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2018). Computational Optimal Transport.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.lp.wasserstein_circle">
<span class="sig-prename descclassname"><span class="pre">ot.lp.</span></span><span class="sig-name descname"><span class="pre">wasserstein_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/lp/solver_1d.html#wasserstein_circle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.lp.wasserstein_circle" title="Link to this definition"></a></dt>
<dd><p>Computes the Wasserstein distance on the circle using either <a class="reference internal" href="#references-wasserstein-circle"><span class="std std-ref">[45]</span></a> for p=1 or
the binary search algorithm proposed in <a class="reference internal" href="#references-wasserstein-circle"><span class="std std-ref">[44]</span></a> otherwise.
Samples need to be in <span class="math notranslate nohighlight">\(S^1\cong [0,1[\)</span>. If they are on <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>,
takes the value modulo 1.
If the values are on <span class="math notranslate nohighlight">\(S^1\subset\mathbb{R}^2\)</span>, it requires to first find the coordinates
using e.g. the atan2 function.</p>
<p>General loss returned:</p>
<div class="math notranslate nohighlight">
\[OT_{loss} = \inf_{\theta\in\mathbb{R}}\int_0^1 |cdf_u^{-1}(q)  - (cdf_v-\theta)^{-1}(q)|^p\ \mathrm{d}q\]</div>
<p>For p=1, [45]</p>
<div class="math notranslate nohighlight">
\[W_1(u,v) = \int_0^1 |F_u(t)-F_v(t)-LevMed(F_u-F_v)|\ \mathrm{d}t\]</div>
<p>For values <span class="math notranslate nohighlight">\(x=(x_1,x_2)\in S^1\)</span>, it is required to first get their coordinates with</p>
<div class="math notranslate nohighlight">
\[u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}\]</div>
<p>using e.g. ot.utils.get_coordinate_circle(x)</p>
<p>The function runs on backend but tensorflow and jax are not supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the source domain (coordinates on [0,1[)</p></li>
<li><p><strong>v_values</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em>) – samples in the target domain (coordinates on [0,1[)</p></li>
<li><p><strong>u_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the source domain</p></li>
<li><p><strong>v_weights</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – samples weights in the target domain</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=1</em><em>)</em>) – Power p used for computing the Wasserstein distance</p></li>
<li><p><strong>Lm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Lower bound dC. For p&gt;1.</p></li>
<li><p><strong>Lp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Upper bound dC. For p&gt;1.</p></li>
<li><p><strong>tm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Lower bound theta. For p&gt;1.</p></li>
<li><p><strong>tp</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Upper bound theta. For p&gt;1.</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stopping condition. For p&gt;1.</p></li>
<li><p><strong>require_sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, sort the values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> – Batched cost associated to the optimal transportation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float/array-like, shape (…)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">]])</span><span class="o">%</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wasserstein_circle</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">array([0.1])</span>
</pre></div>
</div>
<p class="rubric" id="references-wasserstein-circle">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id28" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>44<span class="fn-bracket">]</span></span>
<p>Hundrieser, Shayan, Marcel Klatt, and Axel Munk. “The statistics of circular optimal transport.” Directional Statistics for Innovative Applications: A Bicentennial Tribute to Florence Nightingale. Singapore: Springer Nature Singapore, 2022. 57-82.</p>
</aside>
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>45<span class="fn-bracket">]</span></span>
<p>Delon, Julie, Julien Salomon, and Andrei Sobolevski. “Fast transport optimization for Monge costs on the circle.” SIAM Journal on Applied Mathematics 70.7 (2010): 2239-2258.</p>
</aside>
</aside>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.lowrank.html" class="btn btn-neutral float-left" title="ot.lowrank" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.mapping.html" class="btn btn-neutral float-right" title="ot.mapping" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2025, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span> 0.9.6dev0
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>