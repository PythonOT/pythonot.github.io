

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.unbalanced &mdash; POT Python Optimal Transport 0.9.6dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=6e3d2238"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.utils" href="ot.utils.html" />
    <link rel="prev" title="ot.stochastic" href="ot.stochastic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/plot_quickstart_guide.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.batch.html">ot.batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.coot.html">ot.coot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.da.html">ot.da</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gaussian.html">ot.gaussian</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gmm.html">ot.gmm</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lowrank.html">ot.lowrank</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.mapping.html">ot.mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.unbalanced</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.barycenter_unbalanced"><code class="docutils literal notranslate"><span class="pre">barycenter_unbalanced()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.barycenter_unbalanced_sinkhorn"><code class="docutils literal notranslate"><span class="pre">barycenter_unbalanced_sinkhorn()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.barycenter_unbalanced_stabilized"><code class="docutils literal notranslate"><span class="pre">barycenter_unbalanced_stabilized()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.lbfgsb_unbalanced"><code class="docutils literal notranslate"><span class="pre">lbfgsb_unbalanced()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.lbfgsb_unbalanced2"><code class="docutils literal notranslate"><span class="pre">lbfgsb_unbalanced2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.mm_unbalanced"><code class="docutils literal notranslate"><span class="pre">mm_unbalanced()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.mm_unbalanced2"><code class="docutils literal notranslate"><span class="pre">mm_unbalanced2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.sinkhorn_knopp_unbalanced"><code class="docutils literal notranslate"><span class="pre">sinkhorn_knopp_unbalanced()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.sinkhorn_stabilized_unbalanced"><code class="docutils literal notranslate"><span class="pre">sinkhorn_stabilized_unbalanced()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced"><code class="docutils literal notranslate"><span class="pre">sinkhorn_unbalanced()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced2"><code class="docutils literal notranslate"><span class="pre">sinkhorn_unbalanced2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced_translation_invariant"><code class="docutils literal notranslate"><span class="pre">sinkhorn_unbalanced_translation_invariant()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../all.html">API and modules</a></li>
      <li class="breadcrumb-item active">ot.unbalanced</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.unbalanced.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.unbalanced">
<span id="ot-unbalanced"></span><h1>ot.unbalanced<a class="headerlink" href="#module-ot.unbalanced" title="Link to this heading"></a></h1>
<p>Solvers related to Unbalanced Optimal Transport problems.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.barycenter_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">barycenter_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_sinkhorn.html#barycenter_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.barycenter_unbalanced" title="Link to this definition"></a></dt>
<dd><p>Compute the entropic unbalanced wasserstein barycenter of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<blockquote>
<div><p>The function solves the following optimization problem with <span class="math notranslate nohighlight">\(\mathbf{a}\)</span></p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = \mathop{\arg \min}_\mathbf{a} \quad \sum_i W_{u_{reg}}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_{u_{reg}}(\cdot,\cdot)\)</span> is the unbalanced entropic regularized Wasserstein distance (see <a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced" title="ot.unbalanced.sinkhorn_unbalanced"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced()</span></code></a>)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
<li><p>reg and <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> are respectively the regularization term and the cost matrix for OT</p></li>
<li><p>reg_mis the marginal relaxation hyperparameter</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-barycenter-unbalanced"><span class="std std-ref">[10]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – <cite>n_hists</cite> training distributions <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> of dimension <cite>dim</cite></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>dim</em><em>)</em>) – ground metric matrix for OT.</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Marginal relaxation term &gt; 0</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_hists</em><em>,</em><em>) </em><em>optional</em>) – Weight of each distribution (barycentric coordinates)
If None, uniform weights are used.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>array-like, shape (dim,)</em>) – Unbalanced Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-barycenter-unbalanced">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Benamou, J. D., Carlier, G., Cuturi, M., Nenna, L., &amp; Peyré, G.
(2015). Iterative Bregman projections for regularized transportation
problems. SIAM Journal on Scientific Computing, 37(2), A1111-A1138.</p>
</aside>
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprin
arXiv:1607.05816.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.barycenter_unbalanced_sinkhorn">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">barycenter_unbalanced_sinkhorn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_sinkhorn.html#barycenter_unbalanced_sinkhorn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.barycenter_unbalanced_sinkhorn" title="Link to this definition"></a></dt>
<dd><p>Compute the entropic unbalanced wasserstein barycenter of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<blockquote>
<div><p>The function solves the following optimization problem with <span class="math notranslate nohighlight">\(\mathbf{a}\)</span></p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = \mathop{\arg \min}_\mathbf{a} \quad \sum_i W_{u_{reg}}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_{u_{reg}}(\cdot,\cdot)\)</span> is the unbalanced entropic regularized Wasserstein distance (see <a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced" title="ot.unbalanced.sinkhorn_unbalanced"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced()</span></code></a>)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
<li><p>reg and <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> are respectively the regularization term and the cost matrix for OT</p></li>
<li><p>reg_mis the marginal relaxation hyperparameter</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-barycenter-unbalanced-sinkhorn"><span class="std std-ref">[10]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – <cite>n_hists</cite> training distributions <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> of dimension <cite>dim</cite></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>dim</em><em>)</em>) – ground metric matrix for OT.</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Marginal relaxation term &gt; 0</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_hists</em><em>,</em><em>) </em><em>optional</em>) – Weight of each distribution (barycentric coordinates)
If None, uniform weights are used.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record <cite>log</cite> if <cite>True</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>array-like, shape (dim,)</em>) – Unbalanced Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if <span class="math notranslate nohighlight">\(log==True\)</span> in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-barycenter-unbalanced-sinkhorn">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Benamou, J. D., Carlier, G., Cuturi, M., Nenna, L., &amp; Peyré, G.
(2015). Iterative Bregman projections for regularized transportation
problems. SIAM Journal on Scientific Computing, 37(2), A1111-A1138.</p>
</aside>
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprin
arXiv:1607.05816.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.barycenter_unbalanced_stabilized">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">barycenter_unbalanced_stabilized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_sinkhorn.html#barycenter_unbalanced_stabilized"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.barycenter_unbalanced_stabilized" title="Link to this definition"></a></dt>
<dd><p>Compute the entropic unbalanced wasserstein barycenter of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> with stabilization.</p>
<blockquote>
<div><p>The function solves the following optimization problem:</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\mathbf{a} = \mathop{\arg \min}_\mathbf{a} \quad \sum_i W_{u_{reg}}(\mathbf{a},\mathbf{a}_i)\]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(W_{u_{reg}}(\cdot,\cdot)\)</span> is the unbalanced entropic regularized Wasserstein distance (see <a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced" title="ot.unbalanced.sinkhorn_unbalanced"><code class="xref py py-func docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced()</span></code></a>)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> are training distributions in the columns of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span></p></li>
<li><p>reg and <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> are respectively the regularization term and the cost matrix for OT</p></li>
<li><p>reg_mis the marginal relaxation hyperparameter</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-barycenter-unbalanced-stabilized"><span class="std std-ref">[10]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>n_hists</em><em>)</em>) – <cite>n_hists</cite> training distributions <span class="math notranslate nohighlight">\(\mathbf{a}_i\)</span> of dimension <cite>dim</cite></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim</em><em>, </em><em>dim</em><em>)</em>) – ground metric matrix for OT.</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Marginal relaxation term &gt; 0</p></li>
<li><p><strong>tau</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Stabilization threshold for log domain absorption.</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_hists</em><em>,</em><em>) </em><em>optional</em>) – Weight of each distribution (barycentric coordinates)
If None, uniform weights are used.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record <cite>log</cite> if <cite>True</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>array-like, shape (dim,)</em>) – Unbalanced Wasserstein barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if <span class="math notranslate nohighlight">\(log==True\)</span> in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-barycenter-unbalanced-stabilized">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Benamou, J. D., Carlier, G., Cuturi, M., Nenna, L., &amp; Peyré,
G. (2015). Iterative Bregman projections for regularized transportation
problems. SIAM Journal on Scientific Computing, 37(2), A1111-A1138.</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.lbfgsb_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">lbfgsb_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regm_div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_lbfgs.html#lbfgsb_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.lbfgsb_unbalanced" title="Link to this definition"></a></dt>
<dd><p>Solve the unbalanced optimal transport problem and return the OT plan using L-BFGS-B algorithm.
The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \arg \min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \mathrm{div}(\gamma, \mathbf{c}) +
\mathrm{reg_{m1}} \cdot \mathrm{div_m}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{div_m}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is a reference distribution for the regularization</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{div_m}\)</span> is a divergence, either Kullback-Leibler divergence,</p></li>
</ul>
<p>or half-squared <span class="math notranslate nohighlight">\(\ell_2\)</span> divergence, or Total variation
- <span class="math notranslate nohighlight">\(\mathrm{div}\)</span> is a divergence, either Kullback-Leibler divergence,
or half-squared <span class="math notranslate nohighlight">\(\ell_2\)</span> divergence</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. First, it converts all arrays into Numpy arrays,
then uses the L-BFGS-B algorithm from scipy.optimize to solve the optimization problem.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite>
If <cite>a</cite> is an empty list or array ([]),
then <cite>a</cite> is set to uniform distribution.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>dim_b</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_b</cite>
If <cite>b</cite> is an empty list or array ([]),
then <cite>b</cite> is set to uniform distribution.</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – regularization term &gt;=0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term: nonnegative (including 0) but cannot be infinity.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is a scalar or an indexable object of length 1,
then the same <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is applied to both marginal relaxations.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is an array, it must be a Numpy array.</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = \mathbf{a} \mathbf{b}^T\)</span>.</p></li>
<li><p><strong>reg_div</strong> (<em>string</em><em> or </em><em>pair</em><em> of </em><em>callable functions</em><em>, </em><em>optional</em><em> (</em><em>default = 'kl'</em><em>)</em>) – Divergence used for regularization.
Can take three values: ‘entropy’ (negative entropy), or
‘kl’ (Kullback-Leibler) or ‘l2’ (half-squared) or a tuple
of two callable functions returning the reg term and its derivative.
Note that the callable functions should be able to handle Numpy arrays
and not tensors from the backend, otherwise functions will be converted to Numpy
leading to a computational overhead.</p></li>
<li><p><strong>regm_div</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = 'kl'</em><em>)</em>) – Divergence to quantify the difference between the marginals.
Can take three values: ‘kl’ (Kullback-Leibler) or ‘l2’ (half-squared) or ‘tv’ (Total Variation)</p></li>
<li><p><strong>G0</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – Initialization of the transport matrix. None corresponds to uniform product.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(dim_a, dim_b) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary returned only if <cite>log</cite> is <cite>True</cite></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">36.</span><span class="p">],[</span><span class="mf">9.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">lbfgsb_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg_m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">reg_div</span><span class="o">=</span><span class="s1">&#39;kl&#39;</span><span class="p">,</span> <span class="n">regm_div</span><span class="o">=</span><span class="s1">&#39;kl&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0.45, 0.  ],</span>
<span class="go">       [0.  , 0.34]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">lbfgsb_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg_m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">reg_div</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">regm_div</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0.4, 0. ],</span>
<span class="go">       [0. , 0.1]])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></span>
<p>Chapel, L., Flamary, R., Wu, H., Févotte, C., and Gasso, G. (2021).
Unbalanced optimal transport through non-negative penalized
linear regression. NeurIPS.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd2" title="ot.lp.emd2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2</span></code></a></dt><dd><p>Unregularized OT loss</p>
</dd>
<dt><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced2" title="ot.unbalanced.sinkhorn_unbalanced2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced2</span></code></a></dt><dd><p>Entropic regularized OT loss</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.lbfgsb_unbalanced2">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">lbfgsb_unbalanced2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regm_div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnCost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_lbfgs.html#lbfgsb_unbalanced2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.lbfgsb_unbalanced2" title="Link to this definition"></a></dt>
<dd><p>Solve the unbalanced optimal transport problem and return the OT cost using L-BFGS-B.
The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \mathrm{div}(\gamma, \mathbf{c}) +
\mathrm{reg_{m1}} \cdot \mathrm{div_m}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{div_m}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is a reference distribution for the regularization</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{div_m}\)</span> is a divergence, either Kullback-Leibler divergence,</p></li>
</ul>
<p>or half-squared <span class="math notranslate nohighlight">\(\ell_2\)</span> divergence, or Total variation
- <span class="math notranslate nohighlight">\(\mathrm{div}\)</span> is a divergence, either Kullback-Leibler divergence,
or half-squared <span class="math notranslate nohighlight">\(\ell_2\)</span> divergence</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is backend-compatible and will work on arrays
from all compatible backends. First, it converts all arrays into Numpy arrays,
then uses the L-BFGS-B algorithm from scipy.optimize to solve the optimization problem.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite>
If <cite>a</cite> is an empty list or array ([]),
then <cite>a</cite> is set to uniform distribution.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>dim_b</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_b</cite>
If <cite>b</cite> is an empty list or array ([]),
then <cite>b</cite> is set to uniform distribution.</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – regularization term &gt;=0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term: nonnegative (including 0) but cannot be infinity.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is a scalar or an indexable object of length 1,
then the same <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is applied to both marginal relaxations.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is an array, it must be a Numpy array.</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = \mathbf{a} \mathbf{b}^T\)</span>.</p></li>
<li><p><strong>reg_div</strong> (<em>string</em><em> or </em><em>pair</em><em> of </em><em>callable functions</em><em>, </em><em>optional</em><em> (</em><em>default = 'kl'</em><em>)</em>) – Divergence used for regularization.
Can take three values: ‘entropy’ (negative entropy), or
‘kl’ (Kullback-Leibler) or ‘l2’ (half-squared) or a tuple
of two callable functions returning the reg term and its derivative.
Note that the callable functions should be able to handle Numpy arrays
and not tensors from the backend, otherwise functions will be converted to Numpy
leading to a computational overhead.</p></li>
<li><p><strong>regm_div</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = 'kl'</em><em>)</em>) – Divergence to quantify the difference between the marginals.
Can take three values: ‘kl’ (Kullback-Leibler) or ‘l2’ (half-squared) or ‘tv’ (Total Variation)</p></li>
<li><p><strong>G0</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – Initialization of the transport matrix. None corresponds to uniform product.</p></li>
<li><p><strong>returnCost</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = &quot;linear&quot;</em><em>)</em>) – If <cite>returnCost</cite> = “linear”, then return the linear part of the unbalanced OT loss.
If <cite>returnCost</cite> = “total”, then return the total unbalanced OT loss.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ot_cost</strong> (<em>array-like</em>) – the OT cost between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span></p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary returned only if <cite>log</cite> is <cite>True</cite></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">36.</span><span class="p">],[</span><span class="mf">9.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">lbfgsb_unbalanced2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg_m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">reg_div</span><span class="o">=</span><span class="s1">&#39;kl&#39;</span><span class="p">,</span> <span class="n">regm_div</span><span class="o">=</span><span class="s1">&#39;kl&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">1.79</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">lbfgsb_unbalanced2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reg_m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">reg_div</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">regm_div</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.8</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></span>
<p>Chapel, L., Flamary, R., Wu, H., Févotte, C., and Gasso, G. (2021).
Unbalanced optimal transport through non-negative penalized
linear regression. NeurIPS.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd2" title="ot.lp.emd2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2</span></code></a></dt><dd><p>Unregularized OT loss</p>
</dd>
<dt><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced2" title="ot.unbalanced.sinkhorn_unbalanced2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced2</span></code></a></dt><dd><p>Entropic regularized OT loss</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.mm_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">mm_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_mm.html#mm_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.mm_unbalanced" title="Link to this definition"></a></dt>
<dd><p>Solve the unbalanced optimal transport problem and return the OT plan.
The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \arg \min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg_{m1}} \cdot \mathrm{div}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{div}(\gamma^T \mathbf{1}, \mathbf{b}) +
\mathrm{reg} \cdot \mathrm{div}(\gamma, \mathbf{c})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target
unbalanced distributions</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is a reference distribution for the regularization</p></li>
<li><p>div is a divergence, either Kullback-Leibler or half-squared <span class="math notranslate nohighlight">\(\ell_2\)</span> divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is a maximization-
minimization algorithm as proposed in <a class="reference internal" href="#references-regpath"><span class="std std-ref">[41]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite>
If <cite>a</cite> is an empty list or array ([]),
then <cite>a</cite> is set to uniform distribution.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>dim_b</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_b</cite>
If <cite>b</cite> is an empty list or array ([]),
then <cite>b</cite> is set to uniform distribution.</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term: nonnegative but cannot be infinity.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is a scalar or an indexable object of length 1,
then the same <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is applied to both marginal relaxations.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is an array,
it must have the same backend as input arrays <cite>(a, b, M)</cite>.</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default = 0</em><em>)</em>) – Regularization term &gt;= 0.
By default, solve the unregularized problem</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = \mathbf{a} \mathbf{b}^T\)</span>.</p></li>
<li><p><strong>div</strong> (<em>string</em><em>, </em><em>optional</em>) – Divergence to quantify the difference between the marginals.
Can take two values: ‘kl’ (Kullback-Leibler) or ‘l2’ (half-squared)</p></li>
<li><p><strong>G0</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – Initialization of the transport matrix</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gamma</strong> (<em>(dim_a, dim_b) array-like</em>) – Optimal transportation matrix for the given parameters</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary returned only if <cite>log</cite> is <cite>True</cite></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">36.</span><span class="p">],[</span><span class="mf">9.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">mm_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">div</span><span class="o">=</span><span class="s1">&#39;kl&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0.45, 0.  ],</span>
<span class="go">       [0.  , 0.34]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">mm_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">div</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0.4, 0. ],</span>
<span class="go">       [0. , 0.1]])</span>
</pre></div>
</div>
<p class="rubric" id="references-regpath">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></span>
<p>Chapel, L., Flamary, R., Wu, H., Févotte, C., and Gasso, G. (2021).
Unbalanced optimal transport through non-negative penalized
linear regression. NeurIPS.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced" title="ot.unbalanced.sinkhorn_unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced</span></code></a></dt><dd><p>Entropic regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.mm_unbalanced2">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">mm_unbalanced2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnCost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_mm.html#mm_unbalanced2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.mm_unbalanced2" title="Link to this definition"></a></dt>
<dd><p>Solve the unbalanced optimal transport problem and return the OT cost.
The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg_{m1}} \cdot \mathrm{div}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{div}(\gamma^T \mathbf{1}, \mathbf{b}) +
\mathrm{reg} \cdot \mathrm{div}(\gamma, \mathbf{c})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target
unbalanced distributions</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is a reference distribution for the regularization</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{div}\)</span> is a divergence, either Kullback-Leibler or half-squared <span class="math notranslate nohighlight">\(\ell_2\)</span> divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is a maximization-
minimization algorithm as proposed in <a class="reference internal" href="#references-regpath"><span class="std std-ref">[41]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite>
If <cite>a</cite> is an empty list or array ([]),
then <cite>a</cite> is set to uniform distribution.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em> (</em><em>dim_b</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_b</cite>
If <cite>b</cite> is an empty list or array ([]),
then <cite>b</cite> is set to uniform distribution.</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term: nonnegative but cannot be infinity.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is a scalar or an indexable object of length 1,
then the same <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is applied to both marginal relaxations.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is an array,
it must have the same backend as input arrays <cite>(a, b, M)</cite>.</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default = 0</em><em>)</em>) – Entropy regularization term &gt;= 0.
By default, solve the unregularized problem</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = mathbf{a} mathbf{b}^T\)</span>.</p></li>
<li><p><strong>div</strong> (<em>string</em><em>, </em><em>optional</em>) – Divergence to quantify the difference between the marginals.
Can take two values: ‘kl’ (Kullback-Leibler) or ‘l2’ (half-squared)</p></li>
<li><p><strong>G0</strong> (<em>array-like</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – Initialization of the transport matrix</p></li>
<li><p><strong>returnCost</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = &quot;linear&quot;</em><em>)</em>) – If <cite>returnCost</cite> = “linear”, then return the linear part of the unbalanced OT loss.
If <cite>returnCost</cite> = “total”, then return the total unbalanced OT loss.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ot_cost</strong> (<em>array-like</em>) – the OT cost between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span></p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary returned only if <cite>log</cite> is <cite>True</cite></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">36.</span><span class="p">],[</span><span class="mf">9.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">mm_unbalanced2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">div</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0.8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">mm_unbalanced2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">div</span><span class="o">=</span><span class="s1">&#39;kl&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">1.79</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>41<span class="fn-bracket">]</span></span>
<p>Chapel, L., Flamary, R., Wu, H., Févotte, C., and Gasso, G. (2021).
Unbalanced optimal transport through non-negative penalized
linear regression. NeurIPS.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd2" title="ot.lp.emd2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd2</span></code></a></dt><dd><p>Unregularized OT loss</p>
</dd>
<dt><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced2" title="ot.unbalanced.sinkhorn_unbalanced2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced2</span></code></a></dt><dd><p>Entropic regularized OT loss</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.sinkhorn_knopp_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_knopp_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_sinkhorn.html#sinkhorn_knopp_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.sinkhorn_knopp_unbalanced" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization unbalanced optimal transport problem and
return the OT plan</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \arg \min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \mathrm{KL}(\gamma, \mathbf{c}) +
\mathrm{reg_{m1}} \cdot \mathrm{KL}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{KL}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is a reference distribution for the regularization</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-sinkhorn-knopp-unbalanced"><span class="std std-ref">[10, 25]</span></a></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Starting from version 0.9.5, the default value has been changed to <cite>reg_type=’kl’</cite> instead of <cite>reg_type=’entropy’</cite>. This makes the function more consistent with the literature
and the other solvers. If you want to use the entropy regularization, please set <cite>reg_type=’entropy’</cite> explicitly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite>
If <cite>a</cite> is an empty list or array ([]),
then <cite>a</cite> is set to uniform distribution.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>)</em>) – One or multiple unnormalized histograms of dimension <cite>dim_b</cite>.
If <cite>b</cite> is an empty list or array ([]),
then <cite>b</cite> is set to uniform distribution.
If many, compute all the OT costs <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}_i)_i\)</span></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is a scalar or an indexable object of length 1,
then the same <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is applied to both marginal relaxations.
The entropic balanced OT can be recovered using <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=float(&quot;inf&quot;)\)</span>.
For semi-relaxed case, use either
<span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=(float(&quot;inf&quot;), scalar)\)</span> or
<span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=(scalar, float(&quot;inf&quot;))\)</span>.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is an array,
it must have the same backend as input arrays <cite>(a, b, M)</cite>.</p></li>
<li><p><strong>reg_type</strong> (<em>string</em><em>, </em><em>optional</em>) – <p>Regularizer term. Can take two values:</p>
<ul>
<li><p>Negative entropy: ‘entropy’:
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \sum_{i,j} \gamma_{i,j} \log(\gamma_{i,j}) - \sum_{i,j} \gamma_{i,j}\)</span>.
This is equivalent (up to a constant) to <span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, 1_{dim_a} 1_{dim_b}^T)\)</span>.</p></li>
<li><p>Kullback-Leibler divergence: ‘kl’:
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, \mathbf{a} \mathbf{b}^T)\)</span>.</p></li>
</ul>
</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = \mathbf{a} \mathbf{b}^T\)</span>.
If <span class="math notranslate nohighlight">\(\texttt{reg_type}=\)</span>’entropy’, then <span class="math notranslate nohighlight">\(\mathbf{c} = 1_{dim_a} 1_{dim_b}^T\)</span>.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the <cite>u</cite>, <cite>v</cite> sinkhorn scaling vectors).</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record <cite>log</cite> if <cite>True</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>if n_hists == 1</em> –</p>
<ul>
<li><dl class="simple">
<dt>gamma<span class="classifier">array-like, shape (dim_a, dim_b)</span></dt><dd><p>Optimal transportation matrix for the given parameters</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><em>else</em> –</p>
<ul>
<li><dl class="simple">
<dt>ot_cost<span class="classifier">array-like, shape (n_hists,)</span></dt><dd><p>the OT cost between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and each of the histograms <span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">sinkhorn_knopp_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">array([[0.3220536, 0.1184769],</span>
<span class="go">       [0.1184769, 0.3220536]])</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn-knopp-unbalanced">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></span>
<p>Frogner C., Zhang C., Mobahi H., Araya-Polo M., Poggio T. :
Learning with a Wasserstein Loss,  Advances in Neural Information
Processing Systems (NIPS) 2015</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.sinkhorn_stabilized_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_stabilized_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_sinkhorn.html#sinkhorn_stabilized_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.sinkhorn_stabilized_unbalanced" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization unbalanced optimal transport
problem and return the loss</p>
<p>The function solves the following optimization problem using log-domain
stabilization as proposed in <a class="reference internal" href="#references-sinkhorn-stabilized-unbalanced"><span class="std std-ref">[10]</span></a>:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \arg \min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \mathrm{KL}(\gamma, \mathbf{c}) +
\mathrm{reg_{m1}} \cdot \mathrm{KL}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{KL}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is a reference distribution for the regularization</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-sinkhorn-stabilized-unbalanced"><span class="std std-ref">[10, 25]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite>
If <cite>a</cite> is an empty list or array ([]),
then <cite>a</cite> is set to uniform distribution.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>)</em>) – One or multiple unnormalized histograms of dimension <cite>dim_b</cite>.
If <cite>b</cite> is an empty list or array ([]),
then <cite>b</cite> is set to uniform distribution.
If many, compute all the OT costs <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}_i)_i\)</span></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is a scalar or an indexable object of length 1,
then the same <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is applied to both marginal relaxations.
The entropic balanced OT can be recovered using <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=float(&quot;inf&quot;)\)</span>.
For semi-relaxed case, use either
<span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=(float(&quot;inf&quot;), scalar)\)</span> or
<span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=(scalar, float(&quot;inf&quot;))\)</span>.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is an array,
it must have the same backend as input arrays <cite>(a, b, M)</cite>.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’, ‘sinkhorn_stabilized’ or
‘sinkhorn_reg_scaling’, see those function for specific parameters</p></li>
<li><p><strong>reg_type</strong> (<em>string</em><em>, </em><em>optional</em>) – <p>Regularizer term. Can take two values:</p>
<ul>
<li><p>Negative entropy: ‘entropy’:
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \sum_{i,j} \gamma_{i,j} \log(\gamma_{i,j}) - \sum_{i,j} \gamma_{i,j}\)</span>.
This is equivalent (up to a constant) to <span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, 1_{dim_a} 1_{dim_b}^T)\)</span>.</p></li>
<li><p>Kullback-Leibler divergence: ‘kl’:
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, \mathbf{a} \mathbf{b}^T)\)</span>.</p></li>
</ul>
</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = \mathbf{a} \mathbf{b}^T\)</span>.
If <span class="math notranslate nohighlight">\(\texttt{reg_type}=\)</span>’entropy’, then <span class="math notranslate nohighlight">\(\mathbf{c} = 1_{dim_a} 1_{dim_b}^T\)</span>.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the <cite>u</cite>, <cite>v</cite> sinkhorn scaling vectors).</p></li>
<li><p><strong>tau</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – threshold for max value in <cite>u</cite> or <cite>v</cite> for log scaling</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record <cite>log</cite> if <cite>True</cite></p></li>
<li><p><strong>warning::</strong> (<em>..</em>) – Starting from version 0.9.5, the default value has been changed to <cite>reg_type=’kl’</cite> instead of <cite>reg_type=’entropy’</cite>. This makes the function more consistent with the literature
and the other solvers. If you want to use the entropy regularization, please set <cite>reg_type=’entropy’</cite> explicitly.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>if n_hists == 1</em> –</p>
<ul>
<li><dl class="simple">
<dt>gamma<span class="classifier">array-like, shape (dim_a, dim_b)</span></dt><dd><p>Optimal transportation matrix for the given parameters</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><em>else</em> –</p>
<ul>
<li><dl class="simple">
<dt>ot_cost<span class="classifier">array-like, shape (n_hists,)</span></dt><dd><p>the OT cost between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and each of the histograms <span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">sinkhorn_stabilized_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">array([[0.3220536, 0.1184769],</span>
<span class="go">       [0.1184769, 0.3220536]])</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn-stabilized-unbalanced">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></span>
<p>Frogner C., Zhang C., Mobahi H., Araya-Polo M., Poggio T. :
Learning with a Wasserstein Loss,  Advances in Neural Information
Processing Systems (NIPS) 2015</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="ot.lp.html#ot.lp.emd" title="ot.lp.emd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.lp.emd</span></code></a></dt><dd><p>Unregularized OT</p>
</dd>
<dt><a class="reference internal" href="ot.optim.html#id0" title="ot.optim.cg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.optim.cg</span></code></a></dt><dd><p>General regularized OT</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.sinkhorn_unbalanced">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_unbalanced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_sinkhorn.html#sinkhorn_unbalanced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.sinkhorn_unbalanced" title="Link to this definition"></a></dt>
<dd><p>Solve the unbalanced entropic regularization optimal transport problem
and return the OT plan</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \arg \min_\gamma \ \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \mathrm{KL}(\gamma, \mathbf{c}) +
\mathrm{reg_{m1}} \cdot \mathrm{KL}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{KL}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is a reference distribution for the regularization</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-sinkhorn-unbalanced"><span class="std std-ref">[10, 25]</span></a></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Starting from version 0.9.5, the default value has been changed to <cite>reg_type=’kl’</cite> instead of <cite>reg_type=’entropy’</cite>. This makes the function more consistent with the literature
and the other solvers. If you want to use the entropy regularization, please set <cite>reg_type=’entropy’</cite> explicitly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite>
If <cite>a</cite> is an empty list or array ([]),
then <cite>a</cite> is set to uniform distribution.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>)</em>) – One or multiple unnormalized histograms of dimension <cite>dim_b</cite>.
If <cite>b</cite> is an empty list or array ([]),
then <cite>b</cite> is set to uniform distribution.
If many, compute all the OT costs <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}_i)_i\)</span></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is a scalar or an indexable object of length 1,
then the same <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is applied to both marginal relaxations.
The entropic balanced OT can be recovered using <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=float(&quot;inf&quot;)\)</span>.
For semi-relaxed case, use either
<span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=(float(&quot;inf&quot;), scalar)\)</span> or
<span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=(scalar, float(&quot;inf&quot;))\)</span>.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is an array,
it must have the same backend as input arrays <cite>(a, b, M)</cite>.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’, ‘sinkhorn_stabilized’, ‘sinkhorn_translation_invariant’ or
‘sinkhorn_reg_scaling’, see those function for specific parameters</p></li>
<li><p><strong>reg_type</strong> (<em>string</em><em>, </em><em>optional</em>) – <p>Regularizer term. Can take two values:</p>
<ul>
<li><p>Negative entropy: ‘entropy’:
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \sum_{i,j} \gamma_{i,j} \log(\gamma_{i,j}) - \sum_{i,j} \gamma_{i,j}\)</span>.
This is equivalent (up to a constant) to <span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, 1_{dim_a} 1_{dim_b}^T)\)</span>.</p></li>
<li><p>Kullback-Leibler divergence (default): ‘kl’:
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, \mathbf{a} \mathbf{b}^T)\)</span>.</p></li>
</ul>
</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = \mathbf{a} \mathbf{b}^T\)</span>.
If <span class="math notranslate nohighlight">\(\texttt{reg_type}=\)</span>’entropy’, then <span class="math notranslate nohighlight">\(\mathbf{c} = 1_{dim_a} 1_{dim_b}^T\)</span>.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the <cite>u</cite>, <cite>v</cite> sinkhorn scaling vectors).</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record <cite>log</cite> if <cite>True</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>if n_hists == 1</em> –</p>
<ul>
<li><dl class="simple">
<dt>gamma<span class="classifier">array-like, shape(dim_a, dim_b)</span></dt><dd><p>Optimal transportation matrix for the given parameters</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><em>else</em> –</p>
<ul>
<li><dl class="simple">
<dt>ot_distance<span class="classifier">array-like, shape (n_hists,)</span></dt><dd><p>the OT distance between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and each of the histograms <span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">sinkhorn_unbalanced</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">array([[0.3220536, 0.1184769],</span>
<span class="go">       [0.1184769, 0.3220536]])</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn-unbalanced">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id15" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems
(NIPS) 26, 2013</p>
</aside>
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms for
Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</aside>
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></span>
<p>Frogner C., Zhang C., Mobahi H., Araya-Polo M., Poggio T. :
Learning with a Wasserstein Loss,  Advances in Neural Information
Processing Systems (NIPS) 2015</p>
</aside>
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>73<span class="fn-bracket">]</span></span>
<p>Séjourné, T., Vialard, F. X., &amp; Peyré, G. (2022).
Faster unbalanced optimal transport: Translation invariant sinkhorn and 1-d frank-wolfe.
In International Conference on Artificial Intelligence and Statistics (pp. 4995-5021). PMLR.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.unbalanced.sinkhorn_knopp_unbalanced" title="ot.unbalanced.sinkhorn_knopp_unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_knopp_unbalanced</span></code></a></dt><dd><p>Unbalanced Classic Sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced"><span class="std std-ref">[10]</span></a></p>
</dd>
<dt><a class="reference internal" href="#ot.unbalanced.sinkhorn_stabilized_unbalanced" title="ot.unbalanced.sinkhorn_stabilized_unbalanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_stabilized_unbalanced</span></code></a></dt><dd><p>Unbalanced Stabilized sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced"><span class="std std-ref">[9, 10]</span></a></p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_reg_scaling_unbalanced</span></code></dt><dd><p>Unbalanced Sinkhorn with epsilon scaling <a class="reference internal" href="#references-sinkhorn-unbalanced"><span class="std std-ref">[9, 10]</span></a></p>
</dd>
<dt><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced_translation_invariant" title="ot.unbalanced.sinkhorn_unbalanced_translation_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced_translation_invariant</span></code></a></dt><dd><p>Translation Invariant Unbalanced Sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced-translation-invariant"><span class="std std-ref">[73]</span></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.sinkhorn_unbalanced2">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_unbalanced2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnCost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_sinkhorn.html#sinkhorn_unbalanced2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.sinkhorn_unbalanced2" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization unbalanced optimal transport problem and
return the cost</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_\gamma \quad \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \mathrm{KL}(\gamma, \mathbf{c}) +
\mathrm{reg_{m1}} \cdot \mathrm{KL}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{KL}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma\geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is a reference distribution for the regularization</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is the generalized
Sinkhorn-Knopp matrix scaling algorithm as proposed in <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[10, 25]</span></a></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Starting from version 0.9.5, the default value has been changed to <cite>reg_type=’kl’</cite> instead of <cite>reg_type=’entropy’</cite>. This makes the function more consistent with the literature
and the other solvers. If you want to use the entropy regularization, please set <cite>reg_type=’entropy’</cite> explicitly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite>
If <cite>a</cite> is an empty list or array ([]),
then <cite>a</cite> is set to uniform distribution.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>)</em>) – One or multiple unnormalized histograms of dimension <cite>dim_b</cite>.
If <cite>b</cite> is an empty list or array ([]),
then <cite>b</cite> is set to uniform distribution.
If many, compute all the OT costs <span class="math notranslate nohighlight">\((\mathbf{a}, \mathbf{b}_i)_i\)</span></p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is a scalar or an indexable object of length 1,
then the same <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is applied to both marginal relaxations.
The entropic balanced OT can be recovered using <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=float(&quot;inf&quot;)\)</span>.
For semi-relaxed case, use either
<span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=(float(&quot;inf&quot;), scalar)\)</span> or
<span class="math notranslate nohighlight">\(\mathrm{reg_{m}}=(scalar, float(&quot;inf&quot;))\)</span>.
If <span class="math notranslate nohighlight">\(\mathrm{reg_{m}}\)</span> is an array,
it must have the same backend as input arrays <cite>(a, b, M)</cite>.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver either ‘sinkhorn’, ‘sinkhorn_stabilized’, ‘sinkhorn_translation_invariant’ or
‘sinkhorn_reg_scaling’, see those function for specific parameters</p></li>
<li><p><strong>reg_type</strong> (<em>string</em><em>, </em><em>optional</em>) – <p>Regularizer term. Can take two values:</p>
<ul>
<li><p>Negative entropy: ‘entropy’:
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \sum_{i,j} \gamma_{i,j} \log(\gamma_{i,j}) - \sum_{i,j} \gamma_{i,j}\)</span>.
This is equivalent (up to a constant) to <span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, 1_{dim_a} 1_{dim_b}^T)\)</span>.</p></li>
<li><p>Kullback-Leibler divergence: ‘kl’:
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, \mathbf{a} \mathbf{b}^T)\)</span>.</p></li>
</ul>
</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = \mathbf{a} \mathbf{b}^T\)</span>.
If <span class="math notranslate nohighlight">\(\texttt{reg_type}=\)</span>’entropy’, then <span class="math notranslate nohighlight">\(\mathbf{c} = 1_{dim_a} 1_{dim_b}^T\)</span>.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the u,v sinkhorn scaling vectors).</p></li>
<li><p><strong>returnCost</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = &quot;linear&quot;</em><em>)</em>) – If <cite>returnCost</cite> = “linear”, then return the linear part of the unbalanced OT loss.
If <cite>returnCost</cite> = “total”, then return the total unbalanced OT loss.</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt;0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record <cite>log</cite> if <cite>True</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ot_cost</strong> (<em>array-like, shape (n_hists,)</em>) – the OT cost between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and each of the histograms <span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span></p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary returned only if <cite>log</cite> is <cite>True</cite></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">sinkhorn_unbalanced2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">0.19600125</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn-unbalanced2">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal
Transport, Advances in Neural Information Processing Systems
(NIPS) 26, 2013</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<p>Schmitzer, B. (2016). Stabilized Sparse Scaling Algorithms for
Entropy Regularized Transport Problems. arXiv preprint arXiv:1610.06519.</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<p>Chizat, L., Peyré, G., Schmitzer, B., &amp; Vialard, F. X. (2016).
Scaling algorithms for unbalanced transport problems. arXiv preprint
arXiv:1607.05816.</p>
</aside>
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></span>
<p>Frogner C., Zhang C., Mobahi H., Araya-Polo M., Poggio T. :
Learning with a Wasserstein Loss,  Advances in Neural Information
Processing Systems (NIPS) 2015</p>
</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>73<span class="fn-bracket">]</span></span>
<p>Séjourné, T., Vialard, F. X., &amp; Peyré, G. (2022).
Faster unbalanced optimal transport: Translation invariant sinkhorn and 1-d frank-wolfe.
In International Conference on Artificial Intelligence and Statistics (pp. 4995-5021). PMLR.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_knopp</span></code></dt><dd><p>Unbalanced Classic Sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[10]</span></a></p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_stabilized</span></code></dt><dd><p>Unbalanced Stabilized sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[9, 10]</span></a></p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_reg_scaling</span></code></dt><dd><p>Unbalanced Sinkhorn with epsilon scaling <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[9, 10]</span></a></p>
</dd>
<dt><a class="reference internal" href="#ot.unbalanced.sinkhorn_unbalanced_translation_invariant" title="ot.unbalanced.sinkhorn_unbalanced_translation_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.unbalanced.sinkhorn_unbalanced_translation_invariant</span></code></a></dt><dd><p>Translation Invariant Unbalanced Sinkhorn <a class="reference internal" href="#references-sinkhorn-unbalanced2"><span class="std std-ref">[73]</span></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.unbalanced.sinkhorn_unbalanced_translation_invariant">
<span class="sig-prename descclassname"><span class="pre">ot.unbalanced.</span></span><span class="sig-name descname"><span class="pre">sinkhorn_unbalanced_translation_invariant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kl'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numItermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stopThr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/unbalanced/_sinkhorn.html#sinkhorn_unbalanced_translation_invariant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.unbalanced.sinkhorn_unbalanced_translation_invariant" title="Link to this definition"></a></dt>
<dd><p>Solve the entropic regularization unbalanced optimal transport problem and
return the OT plan</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}W = \arg \min_\gamma \ \langle \gamma, \mathbf{M} \rangle_F +
\mathrm{reg} \cdot \mathrm{KL}(\gamma, \mathbf{c}) +
\mathrm{reg_{m1}} \cdot \mathrm{KL}(\gamma \mathbf{1}, \mathbf{a}) +
\mathrm{reg_{m2}} \cdot \mathrm{KL}(\gamma^T \mathbf{1}, \mathbf{b})\\s.t.
     \gamma \geq 0\end{aligned}\end{align} \]</div>
<p>where :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the (<cite>dim_a</cite>, <cite>dim_b</cite>) metric cost matrix</p></li>
<li><p><span class="math notranslate nohighlight">\(\Omega\)</span> is the entropic regularization term,KL divergence</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> are source and target unbalanced distributions</p></li>
<li><p>KL is the Kullback-Leibler divergence</p></li>
</ul>
<p>The algorithm used for solving the problem is the translation invariant Sinkhorn algorithm as proposed in <a class="reference internal" href="#references-sinkhorn-unbalanced-translation-invariant"><span class="std std-ref">[73]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>,</em><em>)</em>) – Unnormalized histogram of dimension <cite>dim_a</cite></p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_b</em><em>,</em><em>) or </em><em>(</em><em>dim_b</em><em>, </em><em>n_hists</em><em>)</em>) – One or multiple unnormalized histograms of dimension <cite>dim_b</cite>
If many, compute all the OT distances (a, b_i)</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em>) – loss matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – Entropy regularization term &gt; 0</p></li>
<li><p><strong>reg_m</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>indexable object</em><em> of </em><em>length 1</em><em> or </em><em>2</em>) – Marginal relaxation term.
If reg_m is a scalar or an indexable object of length 1,
then the same reg_m is applied to both marginal relaxations.
The entropic balanced OT can be recovered using <cite>reg_m=float(“inf”)</cite>.
For semi-relaxed case, use either
<cite>reg_m=(float(“inf”), scalar)</cite> or <cite>reg_m=(scalar, float(“inf”))</cite>.
If reg_m is an array, it must have the same backend as input arrays (a, b, M).</p></li>
<li><p><strong>reg_type</strong> (<em>string</em><em>, </em><em>optional</em>) – Regularizer term. Can take two values:
‘entropy’ (negative entropy)
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \sum_{i,j} \gamma_{i,j} \log(\gamma_{i,j}) - \sum_{i,j} \gamma_{i,j}\)</span>, or
‘kl’ (Kullback-Leibler)
<span class="math notranslate nohighlight">\(\Omega(\gamma) = \text{KL}(\gamma, \mathbf{a} \mathbf{b}^T)\)</span>.</p></li>
<li><p><strong>c</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Reference measure for the regularization.
If None, then use <span class="math notranslate nohighlight">\(\mathbf{c} = \mathbf{a} \mathbf{b}^T\)</span>.
If <span class="math notranslate nohighlight">\(\texttt{reg_type}=\)</span>’entropy’, then <span class="math notranslate nohighlight">\(\mathbf{c} = 1_{dim_a} 1_{dim_b}^T\)</span>.</p></li>
<li><p><strong>warmstart</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a><em> of </em><em>arrays</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) – Initialization of dual potentials. If provided, the dual potentials should be given
(that is the logarithm of the u,v sinkhorn scaling vectors).</p></li>
<li><p><strong>numItermax</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Max number of iterations</p></li>
<li><p><strong>stopThr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Stop threshold on error (&gt; 0)</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print information along iterations</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>if n_hists == 1</em> –</p>
<ul>
<li><dl class="simple">
<dt>gamma<span class="classifier">array-like, shape (dim_a, dim_b)</span></dt><dd><p>Optimal transportation matrix for the given parameters</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><em>else</em> –</p>
<ul>
<li><dl class="simple">
<dt>ot_distance<span class="classifier">array-like, shape (n_hists,)</span></dt><dd><p>the OT distance between <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and each of the histograms <span class="math notranslate nohighlight">\(\mathbf{b}_i\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>log<span class="classifier">dict</span></dt><dd><p>log dictionary returned only if <cite>log</cite> is <cite>True</cite></p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ot</span><span class="o">.</span><span class="n">unbalanced</span><span class="o">.</span><span class="n">sinkhorn_unbalanced_translation_invariant</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="go">array([[0.32205357, 0.11847689],</span>
<span class="go">       [0.11847689, 0.32205357]])</span>
</pre></div>
</div>
<p class="rubric" id="references-sinkhorn-unbalanced-translation-invariant">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id25" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>73<span class="fn-bracket">]</span></span>
<p>Séjourné, T., Vialard, F. X., &amp; Peyré, G. (2022).
Faster unbalanced optimal transport: Translation invariant sinkhorn and 1-d frank-wolfe.
In International Conference on Artificial Intelligence and Statistics (pp. 4995-5021). PMLR.</p>
</aside>
</aside>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.stochastic.html" class="btn btn-neutral float-left" title="ot.stochastic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.utils.html" class="btn btn-neutral float-right" title="ot.utils" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2025, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span> 0.9.6dev0
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>