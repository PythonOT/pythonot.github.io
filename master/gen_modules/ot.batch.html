

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.batch &mdash; POT Python Optimal Transport 0.9.6dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=6e3d2238"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.bregman" href="ot.bregman.html" />
    <link rel="prev" title="ot.backend" href="ot.backend.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/plot_quickstart_guide.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.batch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.bregman_log_projection_batch"><code class="docutils literal notranslate"><span class="pre">bregman_log_projection_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.bregman_projection_batch"><code class="docutils literal notranslate"><span class="pre">bregman_projection_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.dist_batch"><code class="docutils literal notranslate"><span class="pre">dist_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.entropy_batch"><code class="docutils literal notranslate"><span class="pre">entropy_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.loss_linear_batch"><code class="docutils literal notranslate"><span class="pre">loss_linear_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.loss_linear_samples_batch"><code class="docutils literal notranslate"><span class="pre">loss_linear_samples_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.loss_quadratic_batch"><code class="docutils literal notranslate"><span class="pre">loss_quadratic_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.loss_quadratic_samples_batch"><code class="docutils literal notranslate"><span class="pre">loss_quadratic_samples_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.solve_batch"><code class="docutils literal notranslate"><span class="pre">solve_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.solve_gromov_batch"><code class="docutils literal notranslate"><span class="pre">solve_gromov_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.solve_sample_batch"><code class="docutils literal notranslate"><span class="pre">solve_sample_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ot.batch.tensor_batch"><code class="docutils literal notranslate"><span class="pre">tensor_batch()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.coot.html">ot.coot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.da.html">ot.da</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gaussian.html">ot.gaussian</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gmm.html">ot.gmm</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lowrank.html">ot.lowrank</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.mapping.html">ot.mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../all.html">API and modules</a></li>
      <li class="breadcrumb-item active">ot.batch</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.batch.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.batch">
<span id="ot-batch"></span><h1>ot.batch<a class="headerlink" href="#module-ot.batch" title="Link to this heading">ÔÉÅ</a></h1>
<p>Batch operations for optimal transport.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.bregman_log_projection_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">bregman_log_projection_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'detach'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_utils.html#bregman_log_projection_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.bregman_log_projection_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Apply Bregman projection to a batch of affinity matrices <span class="math notranslate nohighlight">\(\exp(\mathbf{K})\)</span>.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \mathbf{T} = \mathop{\arg \min}_\mathbf{T} \quad &amp; \text{KL}(\mathbf{T} \| \exp(\mathbf{K})) \\
    \text{s.t.} \quad &amp; \mathbf{T} \mathbf{1} = \mathbf{a} \\
    &amp; \mathbf{T}^T \mathbf{1} = \mathbf{b} \\
    &amp; \mathbf{T} \geq 0
\end{aligned}\end{split}\]</div>
<p>This is equivalent to:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \mathbf{T} = \mathop{\arg \max}_\mathbf{T} \quad &amp; \langle \mathbf{T}, \mathbf{K} \rangle_F \\
    \text{s.t.} \quad &amp; \mathbf{T} \mathbf{1} = \mathbf{a} \\
    &amp; \mathbf{T}^T \mathbf{1} = \mathbf{b} \\
    &amp; \mathbf{T} \geq 0
\end{aligned}\end{split}\]</div>
<p>The optimal solution has the form <span class="math notranslate nohighlight">\(\mathbf{T} = \text{diag}(\exp(\mathbf{u})) \exp(\mathbf{K}) \text{diag}(\exp(\mathbf{v}))\)</span>,
where the dual variables <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> are found iteratively using:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{u}^{(k+1)} = \log(\mathbf{a}) - \text{LSE}(\mathbf{K} + \mathbf{v}^{(k)})\\\mathbf{v}^{(k+1)} = \log(\mathbf{b}) - \text{LSE}(\mathbf{K}^T + \mathbf{u}^{(k)})\end{aligned}\end{align} \]</div>
<p>where LSE denotes the log-sum-exp operation. The iterations are performed using
the log-sum-exp trick to avoid numerical issues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>K</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>m</em><em>)</em>) ‚Äì Affinity matrix for each problem in the batch.</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Source distribution for each problem. If None, uniform distribution is used.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>m</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Target distribution for each problem. If None, uniform distribution is used.</p></li>
<li><p><strong>nx</strong> (<em>backend object</em><em>, </em><em>optional</em>) ‚Äì Numerical backend to use for computations. If None, the default backend is used.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Maximum number of iterations.</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Tolerance for convergence. The solver stops when the maximum change in
the dual variables is below this value.</p></li>
<li><p><strong>grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Gradient computation mode: ‚Äòdetach‚Äô, ‚Äòautodiff‚Äô, or ‚Äòlast_step‚Äô.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Dictionary containing:
- ‚ÄòT‚Äô : array-like, shape (B, n, m)</p>
<blockquote>
<div><p>Optimal transport plan for each problem.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>‚Äôlog_T‚Äô<span class="classifier">array-like, shape (B, n, m)</span></dt><dd><p>Logarithm of the optimal transport plan for each problem.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‚Äôpotentials‚Äô<span class="classifier">tuple of array-like, shapes ((B, n), (B, m))</span></dt><dd><p>Log-scaling factors (u, v).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‚Äôn_iters‚Äô<span class="classifier">int</span></dt><dd><p>Number of iterations performed.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)">dict</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ot.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">bregman_log_projection_batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create batch of affinity matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>  <span class="c1"># 5 problems, 10x15 cost matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">bregman_log_projection_batch</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>  <span class="c1"># Shape (5, 10, 15)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.bregman_projection_batch" title="ot.batch.bregman_projection_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.bregman_projection_batch</span></code></a></dt><dd><p>standard Bregman projection.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.bregman_projection_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">bregman_projection_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'detach'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_utils.html#bregman_projection_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.bregman_projection_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Apply Bregman projection to a batch of affinity matrices <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>.</p>
<p>The function solves the following optimization problem:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \mathbf{T} = \mathop{\arg \min}_\mathbf{T} \quad &amp; \text{KL}(\mathbf{T} \| \mathbf{K}) \\
    \text{s.t.} \quad &amp; \mathbf{T} \mathbf{1} = \mathbf{a} \\
    &amp; \mathbf{T}^T \mathbf{1} = \mathbf{b} \\
    &amp; \mathbf{T} \geq 0
\end{aligned}\end{split}\]</div>
<p>This is equivalent to:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \mathbf{T} = \mathop{\arg \max}_\mathbf{T} \quad &amp; \langle \mathbf{T},  \log(\mathbf{K}) \rangle_F \\
    \text{s.t.} \quad &amp; \mathbf{T} \mathbf{1} = \mathbf{a} \\
    &amp; \mathbf{T}^T \mathbf{1} = \mathbf{b} \\
    &amp; \mathbf{T} \geq 0
\end{aligned}\end{split}\]</div>
<p>The optimal solution has the form <span class="math notranslate nohighlight">\(\mathbf{T} = \text{diag}(\mathbf{f}) \mathbf{K} \text{diag}(\mathbf{g})\)</span>,
where the dual variables <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> are found iteratively using:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{f}^{(k+1)} = \frac{\mathbf{a}}{\sum \mathbf{K} \mathbf{g}^{(k)}}\\\mathbf{g}^{(k+1)} = \frac{\mathbf{b}}{\sum \mathbf{K}^T \mathbf{f}^{(k)}}\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>K</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>m</em><em>)</em>) ‚Äì Affinity matrix for each problem in the batch.</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Source distribution for each problem. If None, uniform distribution is used.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>m</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Target distribution for each problem. If None, uniform distribution is used.</p></li>
<li><p><strong>nx</strong> (<em>backend object</em><em>, </em><em>optional</em>) ‚Äì Numerical backend to use for computations. If None, the default backend is used.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Maximum number of iterations.</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Tolerance for convergence. The solver stops when the maximum change in
the dual variables is below this value.</p></li>
<li><p><strong>grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Gradient computation mode: ‚Äòdetach‚Äô, ‚Äòautodiff‚Äô, or ‚Äòlast_step‚Äô.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Dictionary containing:
- ‚ÄòT‚Äô : array-like, shape (B, n, m)</p>
<blockquote>
<div><p>Optimal transport plan for each problem.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>‚Äôpotentials‚Äô<span class="classifier">tuple of array-like, shapes ((B, n), (B, m))</span></dt><dd><p>Scaling factors (f, g).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‚Äôn_iters‚Äô<span class="classifier">int</span></dt><dd><p>Number of iterations performed.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)">dict</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ot.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">bregman_projection_batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create batch of affinity matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>  <span class="c1"># 5 problems, 10x15 cost matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">bregman_projection_batch</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>  <span class="c1"># Shape (5, 10, 15)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.bregman_log_projection_batch" title="ot.batch.bregman_log_projection_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.bregman_log_projection_batch</span></code></a></dt><dd><p>Bregman projection in the log-domain.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.dist_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">dist_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_linear.html#dist_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.dist_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Batched version of ot.dist, use it to compute many distance matrices in parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>b</em><em>,</em><em>n1</em><em>,</em><em>d</em><em>)</em>) ‚Äì <cite>b</cite> matrices with <cite>n1</cite> samples of size <cite>d</cite></p></li>
<li><p><strong>X2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>b</em><em>,</em><em>n2</em><em>,</em><em>d</em><em>)</em><em>, </em><em>optional</em>) ‚Äì <cite>b</cite> matrices with <cite>n2</cite> samples of size <cite>d</cite> (if None then <span class="math notranslate nohighlight">\(\mathbf{X_2} = \mathbf{X_1}\)</span>)</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì ‚Äòsqeuclidean‚Äô, ‚Äòeuclidean‚Äô, ‚Äòminkowski‚Äô or ‚Äòkl‚Äô</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì p-norm for the Minkowski metrics. Default value is 2.</p></li>
<li><p><strong>nx</strong> (<a class="reference internal" href="ot.backend.html#id0" title="ot.backend.Backend"><em>Backend</em></a><em>, </em><em>optional</em>) ‚Äì Backend to perform computations on. If omitted, the backend defaults to that of <cite>x1</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> ‚Äì distance matrix computed with given metric</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (<cite>b</cite>, <cite>n1</cite>, <cite>n2</cite>)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ot.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">dist_batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">dist_batch</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 10, 15)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../all.html#ot.dist" title="ot.dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.dist</span></code></a></dt><dd><p>equivalent non-batched function.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.entropy_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">entropy_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-16</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_utils.html#entropy_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.entropy_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Computes the entropy of a batch of transport plans T.</p>
<div class="math notranslate nohighlight">
\[H(T)_b = - \sum_{i,j} T_{b,i,j} \log(T_{b,i,j})\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>b</em><em>,</em><em>n1</em><em>,</em><em>n2</em><em>)</em>) ‚Äì <cite>b</cite> transport of size <cite>n1</cite> x <cite>n2</cite>.</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Small constant to avoid numerical issues with log(0). Default is 1e-16.</p></li>
<li><p><strong>nx</strong> (<a class="reference internal" href="ot.backend.html#id0" title="ot.backend.Backend"><em>Backend</em></a><em>, </em><em>optional</em>) ‚Äì Backend to perform computations on. If omitted, the backend defaults to that of <cite>T</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.loss_linear_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">loss_linear_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_linear.html#loss_linear_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.loss_linear_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Computes the linear optimal transport loss given a batch cost matrices and transport plans.</p>
<div class="math notranslate nohighlight">
\[L(T, M)_b =  \langle T_b, M_b \rangle_F\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>ns</em><em>, </em><em>nt</em><em>)</em>) ‚Äì Cost matrix</p></li>
<li><p><strong>T</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>ns</em><em>, </em><em>nt</em><em>)</em>) ‚Äì Transport plan</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> ‚Äì Loss value for each batch element</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (B,)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.dist_batch" title="ot.batch.dist_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.dist_batch</span></code></a></dt><dd><p>batched cost matrix computation for computing M.</p>
</dd>
<dt><a class="reference internal" href="#ot.batch.solve_batch" title="ot.batch.solve_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.solve_batch</span></code></a></dt><dd><p>solver for computing the optimal T.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.loss_linear_samples_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">loss_linear_samples_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l2'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_linear.html#loss_linear_samples_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.loss_linear_samples_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Computes the linear optimal transport loss given samples and transport plan. This is the equivalent of
calling <cite>dist_batch</cite> and then <cite>loss_linear_batch</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>ns</em><em>, </em><em>d</em><em>)</em>) ‚Äì Samples from source distribution</p></li>
<li><p><strong>Y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>nt</em><em>, </em><em>d</em><em>)</em>) ‚Äì Samples from target distribution</p></li>
<li><p><strong>T</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>ns</em><em>, </em><em>nt</em><em>)</em>) ‚Äì Transport plan</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì ‚Äòsqeuclidean‚Äô, ‚Äòeuclidean‚Äô, ‚Äòminkowski‚Äô or ‚Äòkl‚Äô</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>loss</strong> ‚Äì Loss value for each batch element</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (B,)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.dist_batch" title="ot.batch.dist_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.dist_batch</span></code></a></dt><dd><p>batched cost matrix computation for computing M.</p>
</dd>
<dt><a class="reference internal" href="#ot.batch.solve_batch" title="ot.batch.solve_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.solve_batch</span></code></a></dt><dd><p>solver for computing the optimal T.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.loss_quadratic_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">loss_quadratic_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recompute_const</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_quadratic.html#loss_quadratic_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.loss_quadratic_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Computes the gromov-wasserstein cost given a cost tensor and transport plan. Batched version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a>) ‚Äì Cost tensor as returned by <cite>tensor_batch</cite>.</p></li>
<li><p><strong>T</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>m</em><em>)</em>) ‚Äì Transport plan.</p></li>
<li><p><strong>recompute_const</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Whether to recompute the constant term. Default is False. This should be set to True if T does not satisfy the marginal constraints.</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Whether to use symmetric version. Default is True.</p></li>
<li><p><strong>nx</strong> (<em>module</em><em>, </em><em>optional</em>) ‚Äì Backend to use. Default is None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ot.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">tensor_batch</span><span class="p">,</span> <span class="n">loss_quadratic_batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create batch of cost matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># 3 problems, 5x5 source matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># 3 problems, 4x4 target matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">5</span>  <span class="c1"># Uniform source distributions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">/</span> <span class="mi">4</span>  <span class="c1"># Uniform target distributions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">tensor_batch</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;sqeuclidean&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use the uniform transport plan for testing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span> <span class="o">=</span> <span class="n">loss_quadratic_batch</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">recompute_const</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.tensor_batch" title="ot.batch.tensor_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.tensor_batch</span></code></a></dt><dd><p>From computing the cost tensor L.</p>
</dd>
<dt><a class="reference internal" href="#ot.batch.solve_gromov_batch" title="ot.batch.solve_gromov_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.solve_gromov_batch</span></code></a></dt><dd><p>For finding the optimal transport plan T.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.loss_quadratic_samples_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">loss_quadratic_samples_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recompute_const</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_quadratic.html#loss_quadratic_samples_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.loss_quadratic_samples_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Computes the gromov-wasserstein for samples C1, C2 and transport plan. Batched version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>)</em>) ‚Äì Source distributions.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>m</em><em>)</em>) ‚Äì Target distributions.</p></li>
<li><p><strong>C1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>) or </em><em>(</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>, </em><em>d</em><em>)</em>) ‚Äì Source cost matrices.</p></li>
<li><p><strong>C2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>m</em><em>, </em><em>m</em><em>) or </em><em>(</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>, </em><em>d</em><em>)</em>) ‚Äì Target cost matrices.</p></li>
<li><p><strong>T</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>m</em><em>)</em>) ‚Äì Transport plan.</p></li>
<li><p><strong>loss</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Loss function to use. Supported values: ‚Äòsqeuclidean‚Äô, ‚Äòkl‚Äô.
Default is ‚Äòsqeuclidean‚Äô.</p></li>
<li><p><strong>recompute_const</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Whether to recompute the constant term. Default is False. This should be set to True if T does not satisfy the marginal constraints.</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Whether to use symmetric version. Default is True.</p></li>
<li><p><strong>nx</strong> (<em>module</em><em>, </em><em>optional</em>) ‚Äì Backend to use. Default is None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ot.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">loss_quadratic_samples_batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create batch of cost matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># 3 problems, 5x5 source matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># 3 problems, 4x4 target matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">5</span>  <span class="c1"># Uniform source distributions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">/</span> <span class="mi">4</span>  <span class="c1"># Uniform target distributions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use the uniform transport plan for testing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span> <span class="o">=</span> <span class="n">loss_quadratic_samples_batch</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">recompute_const</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loss</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.tensor_batch" title="ot.batch.tensor_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.tensor_batch</span></code></a></dt><dd><p>From computing the cost tensor L.</p>
</dd>
<dt><a class="reference internal" href="#ot.batch.solve_gromov_batch" title="ot.batch.solve_gromov_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.solve_gromov_batch</span></code></a></dt><dd><p>For finding the optimal transport plan T.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.solve_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">solve_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'log_sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'entropy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'envelope'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_linear.html#solve_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.solve_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Batched version of ot.solve, use it to solve many entropic OT problems in parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>ns</em><em>, </em><em>nt</em><em>)</em>) ‚Äì Cost matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) ‚Äì Regularization parameter for entropic regularization</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>ns</em><em>)</em>) ‚Äì Source distribution (optional). If None, uniform distribution is used.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>nt</em><em>)</em>) ‚Äì Target distribution (optional). If None, uniform distribution is used.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) ‚Äì Maximum number of iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) ‚Äì Tolerance for convergence</p></li>
<li><p><strong>solver</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) ‚Äì Solver to use, either ‚Äòlog_sinkhorn‚Äô or ‚Äòsinkhorn‚Äô. Default is ‚Äúlog_sinkhorn‚Äù which is more stable.</p></li>
<li><p><strong>reg_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Type of regularization <span class="math notranslate nohighlight">\(R\)</span>  either ‚ÄúKL‚Äù, or ‚Äúentropy‚Äù. Default is ‚Äúentropy‚Äù.</p></li>
<li><p><strong>grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Type of gradient computation, either or ‚Äòautodiff‚Äô, ‚Äòenvelope‚Äô or ‚Äòlast_step‚Äô used only for
Sinkhorn solver. By default ‚Äòautodiff‚Äô provides gradients wrt all
outputs (<cite>plan, value, value_linear</cite>) but with important memory cost.
‚Äòenvelope‚Äô provides gradients only for <cite>value</cite> and and other outputs are
detached. This is useful for memory saving when only the value is needed. ‚Äòlast_step‚Äô provides
gradients only for the last iteration of the Sinkhorn solver, but provides gradient for both the OT plan and the objective values.
‚Äòdetach‚Äô does not compute the gradients for the Sinkhorn solver.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>res</strong> ‚Äì Result of the optimization problem. The information can be obtained as follows:</p>
<ul class="simple">
<li><p>res.plan : OT plan <span class="math notranslate nohighlight">\(\mathbf{T}\)</span></p></li>
<li><p>res.potentials : OT dual potentials</p></li>
<li><p>res.value : Optimal value of the optimization problem</p></li>
<li><p>res.value_linear : Linear OT loss with the optimal OT plan</p></li>
</ul>
<p>See <a class="reference internal" href="ot.utils.html#id17" title="ot.utils.OTResult"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OTResult</span></code></a> for more information.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="ot.utils.html#id17" title="ot.utils.OTResult">OTResult</a>()</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ot.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_batch</span><span class="p">,</span> <span class="n">dist_batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 5 batches of 10 samples in 3D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 5 batches of 15 samples in 3D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">dist_batch</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>  <span class="c1"># Compute cost matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">solve_batch</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">plan</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># Optimal transport plans for each batch</span>
<span class="go">(5, 10, 15)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># Optimal transport values for each batch</span>
<span class="go">(5,)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.dist_batch" title="ot.batch.dist_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.dist_batch</span></code></a></dt><dd><p>batched cost matrix computation for computing M.</p>
</dd>
<dt><a class="reference internal" href="../all.html#ot.solve" title="ot.solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.solve</span></code></a></dt><dd><p>non-batched version of the OT solver.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.solve_gromov_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">solve_gromov_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter_inner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_inner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'envelope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_quadratic.html#solve_gromov_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.solve_gromov_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Solves a batch of Gromov-Wasserstein optimal transport problems using proximal gradient [12, 81].
For each problem in the batch, solves:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \min_{\mathbf{T} \geq 0} \quad &amp; \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l} \\
    \text{s.t.} \quad &amp; \mathbf{T} \mathbf{1} = \mathbf{a} \\
    &amp; \mathbf{T}^T \mathbf{1} = \mathbf{b} \\
    &amp; \mathbf{T} \geq 0
\end{aligned}\end{split}\]</div>
<p>If <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> are given, solves the more general fused Gromov-Wasserstein problem:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \min_{\mathbf{T} \geq 0} \quad &amp; (1-\alpha) \sum_{i,j} M_{i,j} \mathbf{T}_{i,j} + \alpha \sum_{i,j,k,l} L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l} \\
    \text{s.t.} \quad &amp; \mathbf{T} \mathbf{1} = \mathbf{a} \\
    &amp; \mathbf{T}^T \mathbf{1} = \mathbf{b} \\
    &amp; \mathbf{T} \geq 0
\end{aligned}\end{split}\]</div>
<p>Writing the objective as <span class="math notranslate nohighlight">\((1-\alpha) \langle \mathbf{M}, \mathbf{T} \rangle + \alpha \langle \mathcal{L} \otimes \mathbf{T}, \mathbf{T} \rangle\)</span>,
the solver uses proximal gradient descent where each iteration is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \mathbf{T}_{k+1} = \mathop{\arg \min}_{\mathbf{T} \geq 0} \quad &amp; \langle \mathbf{M}_k, \mathbf{T} \rangle + \epsilon \, \text{KL}(\mathbf{T} \| \mathbf{T}_k) \\
    \text{where} \quad &amp; \mathbf{M}_k = (1 - \alpha) \mathbf{M} + 2 \alpha \mathcal{L} \otimes \mathbf{T}_k
\end{aligned}\end{split}\]</div>
<p>This can be rewritten as:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
    \mathbf{T}_{k+1} = \mathop{\arg \min}_{\mathbf{T} \geq 0} \quad &amp; \langle \mathbf{M}_k - \epsilon \log(\mathbf{T}_k), \mathbf{T} \rangle - \epsilon H(\mathbf{T})
\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(H(\mathbf{T})\)</span> is the entropy of <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>. Thus each iteration can be solved using the Bregman projection solver implemented in <cite>bregman_log_projection_batch</cite>.</p>
<p>Note that the inner optimization problem does not need to be solved exactly. In practice it sufficient to set <cite>max_iter_inner</cite> to a low value (e.g. 20) and/or <cite>tol_inner</cite> to a high value (e.g. 1e-2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>, </em><em>d</em><em>) or </em><em>(</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>)</em>) ‚Äì Samples affinity matrices from source distribution</p></li>
<li><p><strong>C2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>, </em><em>d</em><em>) or </em><em>(</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>)</em>) ‚Äì Samples affinity matrices from target distribution</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Marginal distribution of the source samples. If None, uniform distribution is used.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>m</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Marginal distribution of the target samples. If None, uniform distribution is used.</p></li>
<li><p><strong>loss</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Type of loss function, can be ‚Äòsqeuclidean‚Äô or ‚Äòkl‚Äô or a QuadraticMetric instance.</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Either C1 and C2 are to be assumed symmetric or not.
If let to its default None value, a symmetry test will be conducted.
Else if set to True (resp. False), C1 and C2 will be assumed symmetric (resp. asymmetric).</p></li>
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>dim_a</em><em>, </em><em>dim_b</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Linear cost matrix for Fused Gromov-Wasserstein (default is None).</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Weight the quadratic term (alpha*Gromov) and the linear term
((1-alpha)*Wass) in the Fused Gromov-Wasserstein problem. Not used for
Gromov problem (when M is not provided). By default <code class="docutils literal notranslate"><span class="pre">alpha=None</span></code>
corresponds to <code class="docutils literal notranslate"><span class="pre">alpha=1</span></code> for Gromov problem (<code class="docutils literal notranslate"><span class="pre">M==None</span></code>) and
<code class="docutils literal notranslate"><span class="pre">alpha=0.5</span></code> for Fused Gromov-Wasserstein problem (<code class="docutils literal notranslate"><span class="pre">M!=None</span></code>)</p></li>
<li><p><strong>epsilon</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Regularization parameter for proximal gradient descent. Default is 1e-2.</p></li>
<li><p><strong>T_init</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>m</em><em>)</em><em>, </em><em>optional</em>) ‚Äì Initial transport plan. If None, it is initialized to uniform distribution.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Maximum number of iterations for the proximal gradient descent. Default is 50.</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Tolerance for convergence of the proximal gradient descent. Default is 1e-5.</p></li>
<li><p><strong>max_iter_inner</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) ‚Äì Maximum number of iterations for the inner Bregman projection. Default is 50.</p></li>
<li><p><strong>tol_inner</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì Tolerance for convergence of the inner Bregman projection. Default is 1e-5.</p></li>
<li><p><strong>grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Type of gradient computation, either or ‚Äòautodiff‚Äô, ‚Äòenvelope‚Äô or ‚Äòdetach‚Äô. ‚Äòautodiff‚Äô provides gradients wrt all
outputs (<cite>plan, value, value_linear</cite>) but with important memory cost.
‚Äòenvelope‚Äô provides gradients only for (<cite>value, value_linear</cite>)`.  <cite>detach`</cite> is the fastest option but
provides no gradients. Default is ‚Äòdetach‚Äô.</p></li>
<li><p><strong>assume_inner_convergence</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì If True, assumes that the inner Bregman projection always converged i.e. the transport plan satisfies the marginal constraints.
This enables faster computations of the tensor product but might results in inaccurate results (e.g. negative values of the loss).
Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>res</strong> ‚Äì Result of the optimization problem. The information can be obtained as follows:</p>
<ul class="simple">
<li><p>res.plan : OT plan <span class="math notranslate nohighlight">\(\mathbf{T}\)</span></p></li>
<li><p>res.potentials : OT dual potentials</p></li>
<li><p>res.value : Optimal value of the optimization problem</p></li>
<li><p>res.value_linear : Linear OT loss with the optimal OT plan</p></li>
<li><p>res.value_quad : Quadratic OT loss with the optimal OT plan</p></li>
</ul>
<p>See <a class="reference internal" href="ot.utils.html#id17" title="ot.utils.OTResult"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OTResult</span></code></a> for more information.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="ot.utils.html#id17" title="ot.utils.OTResult">OTResult</a>()</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.tensor_batch" title="ot.batch.tensor_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.tensor_batch</span></code></a></dt><dd><p>From computing the cost tensor L.</p>
</dd>
<dt><a class="reference internal" href="../all.html#ot.solve_gromov" title="ot.solve_gromov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.solve_gromov</span></code></a></dt><dd><p>Non-batched solver for Gromov-Wasserstein. Note that the non-batched solver uses a different algorithm (conditional gradient) and might not give the same results.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<p>Gabriel Peyr√©, Marco Cuturi, and Justin Solomon,
‚ÄúGromov-Wasserstein averaging of kernel and distance matrices.‚Äù
International Conference on Machine Learning (ICML). 2016.</p>
</aside>
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>81<span class="fn-bracket">]</span></span>
<p>Xu, H., Luo, D., &amp; Carin, L. (2019). ‚ÄúScalable Gromov-Wasserstein learning for graph partitioning and matching.‚Äù
Advances in neural information processing systems (NeurIPS). 2019.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.solve_sample_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">solve_sample_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'log_sinkhorn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'entropy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'envelope'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_linear.html#solve_sample_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.solve_sample_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Batched version of ot.solve, use it to solve many entropic OT problems in parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>ns</em><em>, </em><em>nt</em><em>)</em>) ‚Äì Cost matrix</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) ‚Äì Regularization parameter for entropic regularization</p></li>
<li><p><strong>metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì ‚Äòsqeuclidean‚Äô, ‚Äòeuclidean‚Äô, ‚Äòminkowski‚Äô or ‚Äòkl‚Äô</p></li>
<li><p><strong>p</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) ‚Äì p-norm for the Minkowski metrics. Default value is 2.</p></li>
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>ns</em><em>)</em>) ‚Äì Source distribution (optional). If None, uniform distribution is used.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>nt</em><em>)</em>) ‚Äì Target distribution (optional). If None, uniform distribution is used.</p></li>
<li><p><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) ‚Äì Maximum number of iterations</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) ‚Äì Tolerance for convergence</p></li>
<li><p><strong>solver</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) ‚Äì Solver to use, either ‚Äòlog_sinkhorn‚Äô or ‚Äòsinkhorn‚Äô. Default is ‚Äúlog_sinkhorn‚Äù which is more stable.</p></li>
<li><p><strong>reg_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Type of regularization <span class="math notranslate nohighlight">\(R\)</span>  either ‚ÄúKL‚Äù, or ‚Äúentropy‚Äù. Default is ‚Äúentropy‚Äù.</p></li>
<li><p><strong>grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Type of gradient computation, either or ‚Äòautodiff‚Äô, ‚Äòenvelope‚Äô or ‚Äòlast_step‚Äô used only for
Sinkhorn solver. By default ‚Äòautodiff‚Äô provides gradients wrt all
outputs (<cite>plan, value, value_linear</cite>) but with important memory cost.
‚Äòenvelope‚Äô provides gradients only for <cite>value</cite> and and other outputs are
detached. This is useful for memory saving when only the value is needed. ‚Äòlast_step‚Äô provides
gradients only for the last iteration of the Sinkhorn solver, but provides gradient for both the OT plan and the objective values.
‚Äòdetach‚Äô does not compute the gradients for the Sinkhorn solver.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>res</strong> ‚Äì Result of the optimization problem. The information can be obtained as follows:</p>
<ul class="simple">
<li><p>res.plan : OT plan <span class="math notranslate nohighlight">\(\mathbf{T}\)</span></p></li>
<li><p>res.potentials : OT dual potentials</p></li>
<li><p>res.value : Optimal value of the optimization problem</p></li>
<li><p>res.value_linear : Linear OT loss with the optimal OT plan</p></li>
</ul>
<p>See <a class="reference internal" href="ot.utils.html#id17" title="ot.utils.OTResult"><code class="xref any py py-class docutils literal notranslate"><span class="pre">OTResult</span></code></a> for more information.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="ot.utils.html#id17" title="ot.utils.OTResult">OTResult</a>()</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#ot.batch.solve_batch" title="ot.batch.solve_batch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ot.batch.solve_batch</span></code></a></dt><dd><p>solver for computing the optimal T from arbitrary cost matrix M.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ot.batch.tensor_batch">
<span class="sig-prename descclassname"><span class="pre">ot.batch.</span></span><span class="sig-name descname"><span class="pre">tensor_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sqeuclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/batch/_quadratic.html#tensor_batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.batch.tensor_batch" title="Link to this definition">ÔÉÅ</a></dt>
<dd><p>Compute the Gromov-Wasserstein cost tensor for a batch of problems.</p>
<p>The Gromov-Wasserstein distance can be expressed as:</p>
<div class="math notranslate nohighlight">
\[\text{GW}(\mathbf{T}, \mathbf{C}_1, \mathbf{C}_2) = \sum_{ijkl} T_{ik} T_{jl} \ell(C_{1,ij}, C_{2,kl}) = \langle \mathcal{L} \times \mathbf{T}, \mathbf{T} \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> is a 4D tensor with elements <span class="math notranslate nohighlight">\(\mathcal{L}[i,j,k,l] = \ell(C_{1,ij}, C_{2,kl})\)</span>.</p>
<p>For loss functions of the form <span class="math notranslate nohighlight">\(\ell(a,b) = f_1(a) + f_2(b) - \langle h_1(a), h_2(b) \rangle\)</span>,
the tensor product <span class="math notranslate nohighlight">\(\mathcal{L} \times \mathbf{T}\)</span> can be computed efficiently without explicitly computing <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> [12].</p>
<p>This function precomputes all matrices that implicitly define <cite>mathcal{L}</cite> for various loss functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>)</em>) ‚Äì Source distributions for each problem in the batch.</p></li>
<li><p><strong>b</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>m</em><em>)</em>) ‚Äì Target distributions for each problem in the batch.</p></li>
<li><p><strong>C1</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>) or </em><em>(</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>, </em><em>d</em><em>)</em>) ‚Äì Source cost matrices for each problem. Can be a 3D array for scalar costs or a 4D array for vector-valued costs (edge features).</p></li>
<li><p><strong>C2</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>B</em><em>, </em><em>m</em><em>, </em><em>m</em><em>) or </em><em>(</em><em>B</em><em>, </em><em>n</em><em>, </em><em>n</em><em>, </em><em>d</em><em>)</em>) ‚Äì Target cost matrices for each problem. Can be a 3D array for scalar costs or a 4D array for vector-valued costs (edge features).</p></li>
<li><p><strong>symmetric</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì Whether the cost matrices are symmetric. Default is True.</p></li>
<li><p><strong>nx</strong> (<em>backend object</em><em>, </em><em>optional</em>) ‚Äì Numerical backend to use for computations. If None, the default backend is used.</p></li>
<li><p><strong>loss</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) ‚Äì Loss function to use. Supported values: ‚Äòsqeuclidean‚Äô, ‚Äòkl‚Äô.
Default is ‚Äòsqeuclidean‚Äô.</p></li>
<li><p><strong>logits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) ‚Äì For KL divergence, whether inputs are logits (unnormalized log probabilities).
If True, inputs are treated as logits. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Dictionary containing:
- constC : array-like, shape (B, n, m)</p>
<blockquote>
<div><p>Constant term in the tensor product.</p>
</div></blockquote>
<ul class="simple">
<li><p>hC1 : array-like, shape (B, n, n, d) or (B, n, n)</p></li>
<li><p>hC2 : array-like, shape (B, m, m, d) or (B, m, m)</p></li>
<li><p>fC1 : array-like, shape (B, n, n)</p></li>
<li><p>fC2 : array-like, shape (B, m, m)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)">dict</a></p>
</dd>
</dl>
<section id="supported-loss-functions">
<h2>Supported loss functions:<a class="headerlink" href="#supported-loss-functions" title="Link to this heading">ÔÉÅ</a></h2>
<p><strong>Squared Euclidean loss</strong>:</p>
<div class="math notranslate nohighlight">
\[\ell(a, b) = \|a - b\|_2^2 = \sum_i (a_i - b_i)^2\]</div>
<p><strong>KL divergence</strong>:</p>
<div class="math notranslate nohighlight">
\[\ell(a, b) = \sum_i a_i \log\left(\frac{a_i}{b_i}\right)\]</div>
<p>If <code class="docutils literal notranslate"><span class="pre">logits=True</span></code>, the entries of C1 are treated as logits (unnormalized log probabilities)
and the loss becomes:</p>
<div class="math notranslate nohighlight">
\[\ell(x, y) = \sum_i y_i (\log(y_i) - x_i)\]</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ot.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">tensor_batch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create batch of cost matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># 3 problems, 5x5 source matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># 3 problems, 4x4 target matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">5</span>  <span class="c1"># Uniform source distributions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">/</span> <span class="mi">4</span>  <span class="c1"># Uniform target distributions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">tensor_batch</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;sqeuclidean&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<p>Gabriel Peyr√©, Marco Cuturi, and Justin Solomon,
‚ÄúGromov-Wasserstein averaging of kernel and distance matrices.‚Äù
International Conference on Machine Learning (ICML). 2016.</p>
</aside>
</aside>
</section>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.backend.html" class="btn btn-neutral float-left" title="ot.backend" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.bregman.html" class="btn btn-neutral float-right" title="ot.bregman" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2025, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span> 0.9.6dev0
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>