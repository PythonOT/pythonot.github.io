

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.gaussian &mdash; POT Python Optimal Transport 0.9.6dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=6e3d2238"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ot.gmm" href="ot.gmm.html" />
    <link rel="prev" title="ot.factored" href="ot.factored.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/plot_quickstart_guide.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../all.html">API and modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ot.backend.html">ot.backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.batch.html">ot.batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.bregman.html">ot.bregman</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.coot.html">ot.coot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.da.html">ot.da</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.datasets.html">ot.datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.dr.html">ot.dr</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.factored.html">ot.factored</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">ot.gaussian</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ot.gaussian.bures_barycenter_fixpoint"><code class="docutils literal notranslate"><span class="pre">bures_barycenter_fixpoint()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.gaussian.bures_barycenter_gradient_descent"><code class="docutils literal notranslate"><span class="pre">bures_barycenter_gradient_descent()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.gaussian.bures_distance"><code class="docutils literal notranslate"><span class="pre">bures_distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ot.gaussian.bures_wasserstein_barycenter"><code class="docutils literal notranslate"><span class="pre">bures_wasserstein_barycenter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-gaussian-bures-wasserstein-barycenter">Examples using <code class="docutils literal notranslate"><span class="pre">ot.gaussian.bures_wasserstein_barycenter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-gaussian-empirical-bures-wasserstein-distance">Examples using <code class="docutils literal notranslate"><span class="pre">ot.gaussian.empirical_bures_wasserstein_distance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-gaussian-empirical-bures-wasserstein-mapping">Examples using <code class="docutils literal notranslate"><span class="pre">ot.gaussian.empirical_bures_wasserstein_mapping</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples-using-ot-gaussian-empirical-gaussian-gromov-wasserstein-mapping">Examples using <code class="docutils literal notranslate"><span class="pre">ot.gaussian.empirical_gaussian_gromov_wasserstein_mapping</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ot.gmm.html">ot.gmm</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gnn.html">ot.gnn</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.gromov.html">ot.gromov</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lowrank.html">ot.lowrank</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.lp.html">ot.lp</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.mapping.html">ot.mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.optim.html">ot.optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.partial.html">ot.partial</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.plot.html">ot.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.regpath.html">ot.regpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.sliced.html">ot.sliced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.smooth.html">ot.smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.stochastic.html">ot.stochastic</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.unbalanced.html">ot.unbalanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.utils.html">ot.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="ot.weak.html">ot.weak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../all.html#module-ot">Main <code class="xref py py-mod docutils literal notranslate"><span class="pre">ot</span></code> functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../all.html">API and modules</a></li>
      <li class="breadcrumb-item active">ot.gaussian</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/gen_modules/ot.gaussian.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ot.gaussian">
<span id="ot-gaussian"></span><h1>ot.gaussian<a class="headerlink" href="#module-ot.gaussian" title="Link to this heading"></a></h1>
<p>Optimal transport for Gaussian distributions</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.bures_barycenter_fixpoint">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_barycenter_fixpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_barycenter_fixpoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.bures_barycenter_fixpoint" title="Link to this definition"></a></dt>
<dd><p>Return the (Bures-)Wasserstein barycenter between centered Gaussian distributions.</p>
<p>The function estimates the (Bures)-Wasserstein barycenter between centered Gaussian distributions <span class="math notranslate nohighlight">\(\big(\mathcal{N}(0,\Sigma_i)\big)_{i=1}^n\)</span>
<span class="xref std std-ref">[16]</span> by solving</p>
<div class="math notranslate nohighlight">
\[\Sigma_b = \mathrm{argmin}_{\Sigma \in S_d^{++}(\mathbb{R})}\ \sum_{i=1}^n w_i W_2^2\big(\mathcal{N}(0,\Sigma), \mathcal{N}(0, \Sigma_i)\big).\]</div>
<p>The barycenter still follows a Gaussian distribution <span class="math notranslate nohighlight">\(\mathcal{N}(0,\Sigma_b)\)</span>
where <span class="math notranslate nohighlight">\(\Sigma_b\)</span> is solution of the following fixed-point algorithm:</p>
<div class="math notranslate nohighlight">
\[\Sigma_b = \sum_{i=1}^n w_i \left(\Sigma_b^{1/2}\Sigma_i^{1/2}\Sigma_b^{1/2}\right)^{1/2}.\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>array-like</em><em> (</em><em>k</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of k distributions</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>k</em><em>)</em><em>, </em><em>optional</em>) – weights for each distribution</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver, either ‘fixed_point’ or ‘gradient_descent’</p></li>
<li><p><strong>num_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iteration for the fixed point algorithm</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for the fixed point algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>nx</strong> (<em>module</em><em>, </em><em>optional</em>) – The numerical backend module to use. If not provided, the backend will
be fetched from the input matrices <cite>C</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Cb</strong> (<em>(d, d) array-like</em>) – covariance of the barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-ot-bures-barycenter-fixed-point">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<p>M. Agueh and G. Carlier, “Barycenters in the Wasserstein space”,
SIAM Journal on Mathematical Analysis, vol. 43, no. 2, pp. 904-924,
2011.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.bures_barycenter_gradient_descent">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_barycenter_gradient_descent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">averaged</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_barycenter_gradient_descent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.bures_barycenter_gradient_descent" title="Link to this definition"></a></dt>
<dd><p>Return the (Bures-)Wasserstein barycenter between centered Gaussian distributions.</p>
<p>The function estimates the (Bures)-Wasserstein barycenter between centered Gaussian distributions <span class="math notranslate nohighlight">\(\big(\mathcal{N}(0,\Sigma_i)\big)_{i=1}^n\)</span>
by using a gradient descent in the Wasserstein space <span class="xref std std-ref">[74, 75]</span>
on the objective</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\Sigma) = \sum_{i=1}^n w_i W_2^2\big(\mathcal{N}(0,\Sigma), \mathcal{N}(0,\Sigma_i)\big).\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>array-like</em><em> (</em><em>k</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of k distributions</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>k</em><em>)</em><em>, </em><em>optional</em>) – weights for each distribution</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver, either ‘fixed_point’ or ‘gradient_descent’</p></li>
<li><p><strong>num_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iteration for the fixed point algorithm</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for the fixed point algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>step_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – step size for the gradient descent, 1 by default</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – batch size if use a stochastic gradient descent</p></li>
<li><p><strong>averaged</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, use the averaged procedure of <span class="xref std std-ref">[74]</span></p></li>
<li><p><strong>nx</strong> (<em>module</em><em>, </em><em>optional</em>) – The numerical backend module to use. If not provided, the backend will
be fetched from the input matrices <cite>C</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Cb</strong> (<em>(d, d) array-like</em>) – covariance of the barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-ot-bures-barycenter-gradient-descent">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>74<span class="fn-bracket">]</span></span>
<p>Chewi, S., Maunu, T., Rigollet, P., &amp; Stromme, A. J. (2020).
Gradient descent algorithms for Bures-Wasserstein barycenters.
In Conference on Learning Theory (pp. 1276-1304). PMLR.</p>
</aside>
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>75<span class="fn-bracket">]</span></span>
<p>Altschuler, J., Chewi, S., Gerber, P. R., &amp; Stromme, A. (2021).
Averaging on the Bures-Wasserstein manifold: dimension-free convergence
of gradient descent. Advances in Neural Information Processing Systems, 34, 22132-22145.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.bures_distance">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Cs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paired</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.bures_distance" title="Link to this definition"></a></dt>
<dd><p>Return Bures distance.</p>
<p>The function computes the Bures distance between <span class="math notranslate nohighlight">\(\mu_s=\mathcal{N}(0,\Sigma_s)\)</span> and <span class="math notranslate nohighlight">\(\mu_t=\mathcal{N}(0,\Sigma_t)\)</span>,
given by (see e.g. Remark 2.31 <span class="xref std std-ref">[15]</span>):</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}(\Sigma_s, \Sigma_t)^{2} = \text{Tr}\left(\Sigma_s + \Sigma_t - 2 \sqrt{\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2}} \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Cs</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>) or </em><em>(</em><em>n</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Ct</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>) or </em><em>(</em><em>m</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the target distribution</p></li>
<li><p><strong>paired</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – if True and n==m, return the paired distances and crossed distance otherwise</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>nx</strong> (<em>module</em><em>, </em><em>optional</em>) – The numerical backend module to use. If not provided, the backend will
be fetched from the input matrices <cite>Cs, Ct</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float if Cs and Cd of shape (d,d), array-like (n,m) if Cs of shape (n,d,d) and Ct of shape (m,d,d), array-like (n,) if Cs and Ct of shape (n, d, d) and paired is True</em>) – Bures Wasserstein distance</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-bures-wasserstein-distance">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2019). Computational optimal transport: With applications to data science.
Foundations and Trends® in Machine Learning, 11(5-6), 355-607.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.bures_wasserstein_barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_wasserstein_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fixed_point'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_wasserstein_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.bures_wasserstein_barycenter" title="Link to this definition"></a></dt>
<dd><p>Return the (Bures-)Wasserstein barycenter between Gaussian distributions.</p>
<p>The function estimates the (Bures)-Wasserstein barycenter between Gaussian distributions <span class="math notranslate nohighlight">\(\big(\mathcal{N}(\mu_i,\Sigma_i)\big)_{i=1}^n\)</span>
<span class="xref std std-ref">[16, 74, 75]</span> by solving</p>
<div class="math notranslate nohighlight">
\[(\mu_b, \Sigma_b) = \mathrm{argmin}_{\mu,\Sigma}\ \sum_{i=1}^n w_i W_2^2\big(\mathcal{N}(\mu,\Sigma), \mathcal{N}(\mu_i, \Sigma_i)\big)\]</div>
<p>The barycenter still follows a Gaussian distribution <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_b,\Sigma_b)\)</span>
where:</p>
<div class="math notranslate nohighlight">
\[\mu_b = \sum_{i=1}^n w_i \mu_i,\]</div>
<p>and the barycentric covariance is the solution of the following fixed-point algorithm:</p>
<div class="math notranslate nohighlight">
\[\Sigma_b = \sum_{i=1}^n w_i \left(\Sigma_b^{1/2}\Sigma_i^{1/2}\Sigma_b^{1/2}\right)^{1/2}\]</div>
<p>We propose two solvers: one based on solving the previous fixed-point problem [16]. Another based on
gradient descent in the Bures-Wasserstein space [74,75].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>array-like</em><em> (</em><em>k</em><em>,</em><em>d</em><em>)</em>) – mean of k distributions</p></li>
<li><p><strong>C</strong> (<em>array-like</em><em> (</em><em>k</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of k distributions</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>k</em><em>)</em><em>, </em><em>optional</em>) – weights for each distribution</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver, either ‘fixed_point’, ‘gradient_descent’, ‘stochastic_gradient_descent’ or
‘averaged_stochastic_gradient_descent’</p></li>
<li><p><strong>num_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iteration for the fixed point algorithm</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for the fixed point algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>step_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – step size for the gradient descent, 1 by default</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – batch size if use a stochastic gradient descent. If not None, use method=’gradient_descent’</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mb</strong> (<em>(d,) array-like</em>) – mean of the barycenter</p></li>
<li><p><strong>Cb</strong> (<em>(d, d) array-like</em>) – covariance of the barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-ot-bures-wasserstein-barycenter">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<p>M. Agueh and G. Carlier, “Barycenters in the Wasserstein space”,
SIAM Journal on Mathematical Analysis, vol. 43, no. 2, pp. 904-924,
2011.</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>74<span class="fn-bracket">]</span></span>
<p>Chewi, S., Maunu, T., Rigollet, P., &amp; Stromme, A. J. (2020).
Gradient descent algorithms for Bures-Wasserstein barycenters.
In Conference on Learning Theory (pp. 1276-1304). PMLR.</p>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>75<span class="fn-bracket">]</span></span>
<p>Altschuler, J., Chewi, S., Gerber, P. R., &amp; Stromme, A. (2021).
Averaging on the Bures-Wasserstein manifold: dimension-free convergence
of gradient descent. Advances in Neural Information Processing Systems, 34, 22132-22145.</p>
</aside>
</aside>
</dd></dl>

<section id="examples-using-ot-gaussian-bures-wasserstein-barycenter">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.gaussian.bures_wasserstein_barycenter</span></code><a class="headerlink" href="#examples-using-ot-gaussian-bures-wasserstein-barycenter" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Illustration of Gaussian Bures-Wasserstein barycenters."><img alt="" src="../_images/sphx_glr_plot_gaussian_barycenter_thumb.png" />
<p><a class="reference internal" href="../auto_examples/barycenters/plot_gaussian_barycenter.html#sphx-glr-auto-examples-barycenters-plot-gaussian-barycenter-py"><span class="std std-ref">Gaussian Bures-Wasserstein barycenters</span></a></p>
  <div class="sphx-glr-thumbnail-title">Gaussian Bures-Wasserstein barycenters</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.bures_wasserstein_distance">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paired</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.bures_wasserstein_distance" title="Link to this definition"></a></dt>
<dd><p>Return Bures Wasserstein distance between samples.</p>
<p>The function computes the Bures-Wasserstein distance between <span class="math notranslate nohighlight">\(\mu_s=\mathcal{N}(m_s,\Sigma_s)\)</span> and <span class="math notranslate nohighlight">\(\mu_t=\mathcal{N}(m_t,\Sigma_t)\)</span>,
as discussed in remark 2.31 <span class="xref std std-ref">[15]</span>.</p>
<div class="math notranslate nohighlight">
\[\mathcal{W}(\mu_s, \mu_t)_2^2= \left\lVert \mathbf{m}_s - \mathbf{m}_t \right\rVert^2 + \mathcal{B}(\Sigma_s, \Sigma_t)^{2}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}(\Sigma_s, \Sigma_t)^{2} = \text{Tr}\left(\Sigma_s + \Sigma_t - 2 \sqrt{\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2}} \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ms</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>) or </em><em>(</em><em>n</em><em>,</em><em>d</em><em>)</em>) – mean of the source distribution</p></li>
<li><p><strong>mt</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>) or </em><em>(</em><em>m</em><em>,</em><em>d</em><em>)</em>) – mean of the target distribution</p></li>
<li><p><strong>Cs</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>) or </em><em>(</em><em>n</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Ct</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>) or </em><em>(</em><em>m</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the target distribution</p></li>
<li><p><strong>paired</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – if True and n==m, return the paired distances and crossed distance otherwise</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float if ms and md of shape (d,), array-like (n,m) if ms of shape (n,d) and mt of shape (m,d), array-like (n,) if ms and mt of shape (n,d) and paired is True</em>) – Bures Wasserstein distance</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id8">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2019). Computational optimal transport: With applications to data science.
Foundations and Trends® in Machine Learning, 11(5-6), 355-607.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.bures_wasserstein_mapping">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_wasserstein_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_wasserstein_mapping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.bures_wasserstein_mapping" title="Link to this definition"></a></dt>
<dd><p>Return OT linear operator between samples.</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[1]</span> and discussed in remark 2.29 in
<span class="xref std std-ref">[2]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ms</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>)</em>) – mean of the source distribution</p></li>
<li><p><strong>mt</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>)</em>) – mean of the target distribution</p></li>
<li><p><strong>Cs</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Ct</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the target distribution</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(d, d) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, d) array-like</em>) – bias</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-ot-mapping-linear">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.empirical_bures_wasserstein_barycenter">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_bures_wasserstein_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_bures_wasserstein_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.empirical_bures_wasserstein_barycenter" title="Link to this definition"></a></dt>
<dd><p>Return OT linear operator between samples.</p>
<p>The function estimates the optimal barycenter of the
empirical distributions. This is equivalent to resolving the fixed point
algorithm for multiple Gaussian distributions <span class="math notranslate nohighlight">\(\left\{\mathcal{N}(\mu,\Sigma)\right\}_{i=1}^n\)</span>
<span class="xref std std-ref">[1]</span>.</p>
<p>The barycenter still following a Gaussian distribution <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_b,\Sigma_b)\)</span>
where :</p>
<div class="math notranslate nohighlight">
\[\mu_b = \sum_{i=1}^n w_i \mu_i\]</div>
<p>And the barycentric covariance is the solution of the following fixed-point algorithm:</p>
<div class="math notranslate nohighlight">
\[\Sigma_b = \sum_{i=1}^n w_i \left(\Sigma_b^{1/2}\Sigma_i^{1/2}\Sigma_b^{1/2}\right)^{1/2}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>array-like</em><em> (</em><em>n</em><em>,</em><em>d</em><em>)</em>) – samples in each distribution</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the diagonals of covariances (&gt;0)</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>n</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – weights for each distribution</p></li>
<li><p><strong>num_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iteration for the fixed point algorithm</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for the fixed point algorithm</p></li>
<li><p><strong>w</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>array-like</em><em> (</em><em>n</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – weights for each sample in each distribution</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mb</strong> (<em>(d,) array-like</em>) – mean of the barycenter</p></li>
<li><p><strong>Cb</strong> (<em>(d, d) array-like</em>) – covariance of the barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-ot-mapping-linear-barycenter">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>M. Agueh and G. Carlier, “Barycenters in the Wasserstein space”,
SIAM Journal on Mathematical Analysis, vol. 43, no. 2, pp. 904-924,
2011.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.empirical_bures_wasserstein_distance">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_bures_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_bures_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.empirical_bures_wasserstein_distance" title="Link to this definition"></a></dt>
<dd><p>Return Bures Wasserstein distance from mean and covariance of distribution.</p>
<p>The function estimates the Bures-Wasserstein distance between two
empirical distributions source <span class="math notranslate nohighlight">\(\mu_s\)</span> and target <span class="math notranslate nohighlight">\(\mu_t\)</span>,
discussed in remark 2.31 <span class="xref std std-ref">[1]</span>.</p>
<p>The Bures Wasserstein distance between source and target distribution <span class="math notranslate nohighlight">\(\mathcal{W}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathcal{W}(\mu_s, \mu_t)_2^2= \left\lVert \mathbf{m}_s - \mathbf{m}_t \right\rVert^2 + \mathcal{B}(\Sigma_s, \Sigma_t)^{2}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}(\Sigma_s, \Sigma_t)^{2} = \text{Tr}\left(\Sigma_s + \Sigma_t - 2 \sqrt{\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2}} \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the diagonals of covariances (&gt;0)</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float</em>) – Bures Wasserstein distance</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id13">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
</dd></dl>

</section>
<section id="examples-using-ot-gaussian-empirical-bures-wasserstein-distance">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.gaussian.empirical_bures_wasserstein_distance</span></code><a class="headerlink" href="#examples-using-ot-gaussian-empirical-bures-wasserstein-distance" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Quickstart guide to the POT toolbox."><img alt="" src="../_images/sphx_glr_plot_quickstart_guide_thumb.png" />
<p><a class="reference internal" href="../auto_examples/plot_quickstart_guide.html#sphx-glr-auto-examples-plot-quickstart-guide-py"><span class="std std-ref">Quickstart Guide</span></a></p>
  <div class="sphx-glr-thumbnail-title">Quickstart Guide</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.empirical_bures_wasserstein_mapping">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_bures_wasserstein_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_bures_wasserstein_mapping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.empirical_bures_wasserstein_mapping" title="Link to this definition"></a></dt>
<dd><p>Return OT linear operator between samples.</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[1]</span> and discussed in remark 2.29 in
<span class="xref std std-ref">[2]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the diagonals of covariances (&gt;0)</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(d, d) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, d) array-like</em>) – bias</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id15">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</aside>
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
</dd></dl>

</section>
<section id="examples-using-ot-gaussian-empirical-bures-wasserstein-mapping">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.gaussian.empirical_bures_wasserstein_mapping</span></code><a class="headerlink" href="#examples-using-ot-gaussian-empirical-bures-wasserstein-mapping" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><img alt="" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Linear OT mapping estimation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.empirical_gaussian_gromov_wasserstein_distance">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_gaussian_gromov_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_gaussian_gromov_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.empirical_gaussian_gromov_wasserstein_distance" title="Link to this definition"></a></dt>
<dd><p>Return Gaussian Gromov-Wasserstein distance between samples.</p>
<p>The function estimates the Gaussian Gromov-Wasserstein distance between two
Gaussien distributions source <span class="math notranslate nohighlight">\(\mu_s\)</span> and target <span class="math notranslate nohighlight">\(\mu_t\)</span>, whose
parameters are estimated from the provided samples <span class="math notranslate nohighlight">\(\mathcal{X}_s\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{X}_t\)</span>. See [57] Theorem 4.1 for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G</strong> – Gaussian Gromov-Wasserstein distance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<p class="rubric" id="references-gaussien-gromov-wasserstein">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022).
Gromov–Wasserstein distances between Gaussian distributions.
Journal of Applied Probability, 59(4), 1178-1198.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.empirical_gaussian_gromov_wasserstein_mapping">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_gaussian_gromov_wasserstein_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_eigs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_gaussian_gromov_wasserstein_mapping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.empirical_gaussian_gromov_wasserstein_mapping" title="Link to this definition"></a></dt>
<dd><p>Return Gaussian Gromov-Wasserstein mapping between samples.</p>
<p>The function estimates the Gaussian Gromov-Wasserstein mapping between two
Gaussian distributions source <span class="math notranslate nohighlight">\(\mu_s\)</span> and target <span class="math notranslate nohighlight">\(\mu_t\)</span>, whose
parameters are estimated from the provided samples <span class="math notranslate nohighlight">\(\mathcal{X}_s\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{X}_t\)</span>. See [57] Theorem 4.1 for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>ds</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>dt</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>sign_eigs</strong> (<em>array-like</em><em> (</em><em>min</em><em>(</em><em>ds</em><em>,</em><em>dt</em><em>)</em><em>,</em><em>) or </em><em>string</em><em>, </em><em>optional</em>) – sign of the eigenvalues of the mapping matrix, by default all signs will
be positive. If ‘skewness’ is provided, the sign of the eigenvalues is
selected as the product of the sign of the skewness of the projected data.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(dt, ds) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, dt) array-like</em>) – bias</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-empirical-gaussian-gromov-wasserstein-mapping">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022).
Gromov–Wasserstein distances between Gaussian distributions.
Journal of Applied Probability, 59(4), 1178-1198.</p>
</aside>
</aside>
</dd></dl>

</section>
<section id="examples-using-ot-gaussian-empirical-gaussian-gromov-wasserstein-mapping">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">ot.gaussian.empirical_gaussian_gromov_wasserstein_mapping</span></code><a class="headerlink" href="#examples-using-ot-gaussian-empirical-gaussian-gromov-wasserstein-mapping" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Linear OT mapping estimation"><img alt="" src="../_images/sphx_glr_plot_otda_linear_mapping_thumb.png" />
<p><a class="reference internal" href="../auto_examples/domain-adaptation/plot_otda_linear_mapping.html#sphx-glr-auto-examples-domain-adaptation-plot-otda-linear-mapping-py"><span class="std std-ref">Linear OT mapping estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Linear OT mapping estimation</div>
</div></div><div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.gaussian_gromov_wasserstein_distance">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">gaussian_gromov_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Cov_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cov_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#gaussian_gromov_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.gaussian_gromov_wasserstein_distance" title="Link to this definition"></a></dt>
<dd><p>Return the Gaussian Gromov-Wasserstein value from [57].</p>
<p>This function return the closed form value of the Gaussian Gromov-Wasserstein
distance between two Gaussian distributions
<span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span> and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span>
when the OT plan is assumed to be also Gaussian. See [57] Theorem 4.1 for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Cov_s</strong> (<em>array-like</em><em> (</em><em>ds</em><em>,</em><em>ds</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Cov_t</strong> (<em>array-like</em><em> (</em><em>dt</em><em>,</em><em>dt</em><em>)</em>) – covariance of the target distribution</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G</strong> – Gaussian Gromov-Wasserstein distance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<p class="rubric" id="references-gaussien-gromov-wasserstein-distance">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022). Gromov–Wasserstein distances between Gaussian distributions.
Journal of Applied Probability, 59(4), 1178-1198.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="ot.gaussian.gaussian_gromov_wasserstein_mapping">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">gaussian_gromov_wasserstein_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cov_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cov_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_eigs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#gaussian_gromov_wasserstein_mapping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ot.gaussian.gaussian_gromov_wasserstein_mapping" title="Link to this definition"></a></dt>
<dd><p>Return the Gaussian Gromov-Wasserstein mapping from [57].</p>
<p>This function return the closed form value of the Gaussian
Gromov-Wasserstein mapping between two Gaussian distributions
<span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span> and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span>
when the OT plan is assumed to be also Gaussian. See [57] Theorem 4.1 for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu_s</strong> (<em>array-like</em><em> (</em><em>ds</em><em>,</em><em>)</em>) – mean of the source distribution</p></li>
<li><p><strong>mu_t</strong> (<em>array-like</em><em> (</em><em>dt</em><em>,</em><em>)</em>) – mean of the target distribution</p></li>
<li><p><strong>Cov_s</strong> (<em>array-like</em><em> (</em><em>ds</em><em>,</em><em>ds</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Cov_t</strong> (<em>array-like</em><em> (</em><em>dt</em><em>,</em><em>dt</em><em>)</em>) – covariance of the target distribution</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(dt, ds) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, dt) array-like</em>) – bias</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="references-gaussien-gromov-wasserstein-mapping">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022).
Gromov–Wasserstein distances between Gaussian distributions.
Journal of Applied Probability, 59(4), 1178-1198.</p>
</aside>
</aside>
</dd></dl>

<div class="sphx-glr-clear"></div><dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_barycenter_fixpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_barycenter_fixpoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Link to this definition"></a></dt>
<dd><p>Return the (Bures-)Wasserstein barycenter between centered Gaussian distributions.</p>
<p>The function estimates the (Bures)-Wasserstein barycenter between centered Gaussian distributions <span class="math notranslate nohighlight">\(\big(\mathcal{N}(0,\Sigma_i)\big)_{i=1}^n\)</span>
<span class="xref std std-ref">[16]</span> by solving</p>
<div class="math notranslate nohighlight">
\[\Sigma_b = \mathrm{argmin}_{\Sigma \in S_d^{++}(\mathbb{R})}\ \sum_{i=1}^n w_i W_2^2\big(\mathcal{N}(0,\Sigma), \mathcal{N}(0, \Sigma_i)\big).\]</div>
<p>The barycenter still follows a Gaussian distribution <span class="math notranslate nohighlight">\(\mathcal{N}(0,\Sigma_b)\)</span>
where <span class="math notranslate nohighlight">\(\Sigma_b\)</span> is solution of the following fixed-point algorithm:</p>
<div class="math notranslate nohighlight">
\[\Sigma_b = \sum_{i=1}^n w_i \left(\Sigma_b^{1/2}\Sigma_i^{1/2}\Sigma_b^{1/2}\right)^{1/2}.\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>array-like</em><em> (</em><em>k</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of k distributions</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>k</em><em>)</em><em>, </em><em>optional</em>) – weights for each distribution</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver, either ‘fixed_point’ or ‘gradient_descent’</p></li>
<li><p><strong>num_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iteration for the fixed point algorithm</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for the fixed point algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>nx</strong> (<em>module</em><em>, </em><em>optional</em>) – The numerical backend module to use. If not provided, the backend will
be fetched from the input matrices <cite>C</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Cb</strong> (<em>(d, d) array-like</em>) – covariance of the barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id22">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<p>M. Agueh and G. Carlier, “Barycenters in the Wasserstein space”,
SIAM Journal on Mathematical Analysis, vol. 43, no. 2, pp. 904-924,
2011.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id24">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_barycenter_gradient_descent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">averaged</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_barycenter_gradient_descent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id24" title="Link to this definition"></a></dt>
<dd><p>Return the (Bures-)Wasserstein barycenter between centered Gaussian distributions.</p>
<p>The function estimates the (Bures)-Wasserstein barycenter between centered Gaussian distributions <span class="math notranslate nohighlight">\(\big(\mathcal{N}(0,\Sigma_i)\big)_{i=1}^n\)</span>
by using a gradient descent in the Wasserstein space <span class="xref std std-ref">[74, 75]</span>
on the objective</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\Sigma) = \sum_{i=1}^n w_i W_2^2\big(\mathcal{N}(0,\Sigma), \mathcal{N}(0,\Sigma_i)\big).\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>array-like</em><em> (</em><em>k</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of k distributions</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>k</em><em>)</em><em>, </em><em>optional</em>) – weights for each distribution</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver, either ‘fixed_point’ or ‘gradient_descent’</p></li>
<li><p><strong>num_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iteration for the fixed point algorithm</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for the fixed point algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>step_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – step size for the gradient descent, 1 by default</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – batch size if use a stochastic gradient descent</p></li>
<li><p><strong>averaged</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – if True, use the averaged procedure of <span class="xref std std-ref">[74]</span></p></li>
<li><p><strong>nx</strong> (<em>module</em><em>, </em><em>optional</em>) – The numerical backend module to use. If not provided, the backend will
be fetched from the input matrices <cite>C</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Cb</strong> (<em>(d, d) array-like</em>) – covariance of the barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id25">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>74<span class="fn-bracket">]</span></span>
<p>Chewi, S., Maunu, T., Rigollet, P., &amp; Stromme, A. J. (2020).
Gradient descent algorithms for Bures-Wasserstein barycenters.
In Conference on Learning Theory (pp. 1276-1304). PMLR.</p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>75<span class="fn-bracket">]</span></span>
<p>Altschuler, J., Chewi, S., Gerber, P. R., &amp; Stromme, A. (2021).
Averaging on the Bures-Wasserstein manifold: dimension-free convergence
of gradient descent. Advances in Neural Information Processing Systems, 34, 22132-22145.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id28">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Cs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paired</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id28" title="Link to this definition"></a></dt>
<dd><p>Return Bures distance.</p>
<p>The function computes the Bures distance between <span class="math notranslate nohighlight">\(\mu_s=\mathcal{N}(0,\Sigma_s)\)</span> and <span class="math notranslate nohighlight">\(\mu_t=\mathcal{N}(0,\Sigma_t)\)</span>,
given by (see e.g. Remark 2.31 <span class="xref std std-ref">[15]</span>):</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}(\Sigma_s, \Sigma_t)^{2} = \text{Tr}\left(\Sigma_s + \Sigma_t - 2 \sqrt{\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2}} \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Cs</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>) or </em><em>(</em><em>n</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Ct</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>) or </em><em>(</em><em>m</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the target distribution</p></li>
<li><p><strong>paired</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – if True and n==m, return the paired distances and crossed distance otherwise</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>nx</strong> (<em>module</em><em>, </em><em>optional</em>) – The numerical backend module to use. If not provided, the backend will
be fetched from the input matrices <cite>Cs, Ct</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float if Cs and Cd of shape (d,d), array-like (n,m) if Cs of shape (n,d,d) and Ct of shape (m,d,d), array-like (n,) if Cs and Ct of shape (n, d, d) and paired is True</em>) – Bures Wasserstein distance</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id29">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2019). Computational optimal transport: With applications to data science.
Foundations and Trends® in Machine Learning, 11(5-6), 355-607.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id31">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_wasserstein_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fixed_point'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_wasserstein_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id31" title="Link to this definition"></a></dt>
<dd><p>Return the (Bures-)Wasserstein barycenter between Gaussian distributions.</p>
<p>The function estimates the (Bures)-Wasserstein barycenter between Gaussian distributions <span class="math notranslate nohighlight">\(\big(\mathcal{N}(\mu_i,\Sigma_i)\big)_{i=1}^n\)</span>
<span class="xref std std-ref">[16, 74, 75]</span> by solving</p>
<div class="math notranslate nohighlight">
\[(\mu_b, \Sigma_b) = \mathrm{argmin}_{\mu,\Sigma}\ \sum_{i=1}^n w_i W_2^2\big(\mathcal{N}(\mu,\Sigma), \mathcal{N}(\mu_i, \Sigma_i)\big)\]</div>
<p>The barycenter still follows a Gaussian distribution <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_b,\Sigma_b)\)</span>
where:</p>
<div class="math notranslate nohighlight">
\[\mu_b = \sum_{i=1}^n w_i \mu_i,\]</div>
<p>and the barycentric covariance is the solution of the following fixed-point algorithm:</p>
<div class="math notranslate nohighlight">
\[\Sigma_b = \sum_{i=1}^n w_i \left(\Sigma_b^{1/2}\Sigma_i^{1/2}\Sigma_b^{1/2}\right)^{1/2}\]</div>
<p>We propose two solvers: one based on solving the previous fixed-point problem [16]. Another based on
gradient descent in the Bures-Wasserstein space [74,75].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>array-like</em><em> (</em><em>k</em><em>,</em><em>d</em><em>)</em>) – mean of k distributions</p></li>
<li><p><strong>C</strong> (<em>array-like</em><em> (</em><em>k</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of k distributions</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>k</em><em>)</em><em>, </em><em>optional</em>) – weights for each distribution</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – method used for the solver, either ‘fixed_point’, ‘gradient_descent’, ‘stochastic_gradient_descent’ or
‘averaged_stochastic_gradient_descent’</p></li>
<li><p><strong>num_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iteration for the fixed point algorithm</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for the fixed point algorithm</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
<li><p><strong>step_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – step size for the gradient descent, 1 by default</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – batch size if use a stochastic gradient descent. If not None, use method=’gradient_descent’</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mb</strong> (<em>(d,) array-like</em>) – mean of the barycenter</p></li>
<li><p><strong>Cb</strong> (<em>(d, d) array-like</em>) – covariance of the barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id32">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></span>
<p>M. Agueh and G. Carlier, “Barycenters in the Wasserstein space”,
SIAM Journal on Mathematical Analysis, vol. 43, no. 2, pp. 904-924,
2011.</p>
</aside>
<aside class="footnote brackets" id="id34" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>74<span class="fn-bracket">]</span></span>
<p>Chewi, S., Maunu, T., Rigollet, P., &amp; Stromme, A. J. (2020).
Gradient descent algorithms for Bures-Wasserstein barycenters.
In Conference on Learning Theory (pp. 1276-1304). PMLR.</p>
</aside>
<aside class="footnote brackets" id="id35" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>75<span class="fn-bracket">]</span></span>
<p>Altschuler, J., Chewi, S., Gerber, P. R., &amp; Stromme, A. (2021).
Averaging on the Bures-Wasserstein manifold: dimension-free convergence
of gradient descent. Advances in Neural Information Processing Systems, 34, 22132-22145.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id36">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paired</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id36" title="Link to this definition"></a></dt>
<dd><p>Return Bures Wasserstein distance between samples.</p>
<p>The function computes the Bures-Wasserstein distance between <span class="math notranslate nohighlight">\(\mu_s=\mathcal{N}(m_s,\Sigma_s)\)</span> and <span class="math notranslate nohighlight">\(\mu_t=\mathcal{N}(m_t,\Sigma_t)\)</span>,
as discussed in remark 2.31 <span class="xref std std-ref">[15]</span>.</p>
<div class="math notranslate nohighlight">
\[\mathcal{W}(\mu_s, \mu_t)_2^2= \left\lVert \mathbf{m}_s - \mathbf{m}_t \right\rVert^2 + \mathcal{B}(\Sigma_s, \Sigma_t)^{2}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}(\Sigma_s, \Sigma_t)^{2} = \text{Tr}\left(\Sigma_s + \Sigma_t - 2 \sqrt{\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2}} \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ms</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>) or </em><em>(</em><em>n</em><em>,</em><em>d</em><em>)</em>) – mean of the source distribution</p></li>
<li><p><strong>mt</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>) or </em><em>(</em><em>m</em><em>,</em><em>d</em><em>)</em>) – mean of the target distribution</p></li>
<li><p><strong>Cs</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>) or </em><em>(</em><em>n</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Ct</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>) or </em><em>(</em><em>m</em><em>,</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the target distribution</p></li>
<li><p><strong>paired</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – if True and n==m, return the paired distances and crossed distance otherwise</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float if ms and md of shape (d,), array-like (n,m) if ms of shape (n,d) and mt of shape (m,d), array-like (n,) if ms and mt of shape (n,d) and paired is True</em>) – Bures Wasserstein distance</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id37">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id38" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2019). Computational optimal transport: With applications to data science.
Foundations and Trends® in Machine Learning, 11(5-6), 355-607.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id39">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">bures_wasserstein_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#bures_wasserstein_mapping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id39" title="Link to this definition"></a></dt>
<dd><p>Return OT linear operator between samples.</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[1]</span> and discussed in remark 2.29 in
<span class="xref std std-ref">[2]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ms</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>)</em>) – mean of the source distribution</p></li>
<li><p><strong>mt</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>)</em>) – mean of the target distribution</p></li>
<li><p><strong>Cs</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Ct</strong> (<em>array-like</em><em> (</em><em>d</em><em>,</em><em>d</em><em>)</em>) – covariance of the target distribution</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(d, d) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, d) array-like</em>) – bias</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id40">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id41" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</aside>
<aside class="footnote brackets" id="id42" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id43">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_bures_wasserstein_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_bures_wasserstein_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id43" title="Link to this definition"></a></dt>
<dd><p>Return OT linear operator between samples.</p>
<p>The function estimates the optimal barycenter of the
empirical distributions. This is equivalent to resolving the fixed point
algorithm for multiple Gaussian distributions <span class="math notranslate nohighlight">\(\left\{\mathcal{N}(\mu,\Sigma)\right\}_{i=1}^n\)</span>
<span class="xref std std-ref">[1]</span>.</p>
<p>The barycenter still following a Gaussian distribution <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_b,\Sigma_b)\)</span>
where :</p>
<div class="math notranslate nohighlight">
\[\mu_b = \sum_{i=1}^n w_i \mu_i\]</div>
<p>And the barycentric covariance is the solution of the following fixed-point algorithm:</p>
<div class="math notranslate nohighlight">
\[\Sigma_b = \sum_{i=1}^n w_i \left(\Sigma_b^{1/2}\Sigma_i^{1/2}\Sigma_b^{1/2}\right)^{1/2}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>array-like</em><em> (</em><em>n</em><em>,</em><em>d</em><em>)</em>) – samples in each distribution</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the diagonals of covariances (&gt;0)</p></li>
<li><p><strong>weights</strong> (<em>array-like</em><em> (</em><em>n</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – weights for each distribution</p></li>
<li><p><strong>num_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – number of iteration for the fixed point algorithm</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for the fixed point algorithm</p></li>
<li><p><strong>w</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><em>array-like</em><em> (</em><em>n</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – weights for each sample in each distribution</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mb</strong> (<em>(d,) array-like</em>) – mean of the barycenter</p></li>
<li><p><strong>Cb</strong> (<em>(d, d) array-like</em>) – covariance of the barycenter</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id44">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id45" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>M. Agueh and G. Carlier, “Barycenters in the Wasserstein space”,
SIAM Journal on Mathematical Analysis, vol. 43, no. 2, pp. 904-924,
2011.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id46">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_bures_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_bures_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id46" title="Link to this definition"></a></dt>
<dd><p>Return Bures Wasserstein distance from mean and covariance of distribution.</p>
<p>The function estimates the Bures-Wasserstein distance between two
empirical distributions source <span class="math notranslate nohighlight">\(\mu_s\)</span> and target <span class="math notranslate nohighlight">\(\mu_t\)</span>,
discussed in remark 2.31 <span class="xref std std-ref">[1]</span>.</p>
<p>The Bures Wasserstein distance between source and target distribution <span class="math notranslate nohighlight">\(\mathcal{W}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathcal{W}(\mu_s, \mu_t)_2^2= \left\lVert \mathbf{m}_s - \mathbf{m}_t \right\rVert^2 + \mathcal{B}(\Sigma_s, \Sigma_t)^{2}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}(\Sigma_s, \Sigma_t)^{2} = \text{Tr}\left(\Sigma_s + \Sigma_t - 2 \sqrt{\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2}} \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the diagonals of covariances (&gt;0)</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>W</strong> (<em>float</em>) – Bures Wasserstein distance</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id47">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id48" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id49">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_bures_wasserstein_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_bures_wasserstein_mapping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id49" title="Link to this definition"></a></dt>
<dd><p>Return OT linear operator between samples.</p>
<p>The function estimates the optimal linear operator that aligns the two
empirical distributions. This is equivalent to estimating the closed
form mapping between two Gaussian distributions <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span>
and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span> as proposed in
<span class="xref std std-ref">[1]</span> and discussed in remark 2.29 in
<span class="xref std std-ref">[2]</span>.</p>
<p>The linear operator from source to target <span class="math notranslate nohighlight">\(M\)</span></p>
<div class="math notranslate nohighlight">
\[M(\mathbf{x})= \mathbf{A} \mathbf{x} + \mathbf{b}\]</div>
<p>where :</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mathbf{A} &amp;= \Sigma_s^{-1/2} \left(\Sigma_s^{1/2}\Sigma_t\Sigma_s^{1/2} \right)^{1/2}
\Sigma_s^{-1/2}\\\mathbf{b} &amp;= \mu_t - \mathbf{A} \mu_s\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>reg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>,</em><em>optional</em>) – regularization added to the diagonals of covariances (&gt;0)</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>bias</strong> (<em>boolean</em><em>, </em><em>optional</em>) – estimate bias <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> else <span class="math notranslate nohighlight">\(\mathbf{b} = 0\)</span> (default:True)</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(d, d) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, d) array-like</em>) – bias</p></li>
<li><p><strong>log</strong> (<em>dict</em>) – log dictionary return only if log==True in parameters</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id50">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id51" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Knott, M. and Smith, C. S. “On the optimal mapping of
distributions”, Journal of Optimization Theory and Applications
Vol 43, 1984</p>
</aside>
<aside class="footnote brackets" id="id52" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Peyré, G., &amp; Cuturi, M. (2017). “Computational Optimal
Transport”, 2018.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id53">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_gaussian_gromov_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_gaussian_gromov_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id53" title="Link to this definition"></a></dt>
<dd><p>Return Gaussian Gromov-Wasserstein distance between samples.</p>
<p>The function estimates the Gaussian Gromov-Wasserstein distance between two
Gaussien distributions source <span class="math notranslate nohighlight">\(\mu_s\)</span> and target <span class="math notranslate nohighlight">\(\mu_t\)</span>, whose
parameters are estimated from the provided samples <span class="math notranslate nohighlight">\(\mathcal{X}_s\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{X}_t\)</span>. See [57] Theorem 4.1 for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>d</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>d</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G</strong> – Gaussian Gromov-Wasserstein distance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<p class="rubric" id="id54">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id55" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022).
Gromov–Wasserstein distances between Gaussian distributions.
Journal of Applied Probability, 59(4), 1178-1198.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id56">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">empirical_gaussian_gromov_wasserstein_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_eigs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#empirical_gaussian_gromov_wasserstein_mapping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id56" title="Link to this definition"></a></dt>
<dd><p>Return Gaussian Gromov-Wasserstein mapping between samples.</p>
<p>The function estimates the Gaussian Gromov-Wasserstein mapping between two
Gaussian distributions source <span class="math notranslate nohighlight">\(\mu_s\)</span> and target <span class="math notranslate nohighlight">\(\mu_t\)</span>, whose
parameters are estimated from the provided samples <span class="math notranslate nohighlight">\(\mathcal{X}_s\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{X}_t\)</span>. See [57] Theorem 4.1 for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xs</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>ds</em><em>)</em>) – samples in the source domain</p></li>
<li><p><strong>xt</strong> (<em>array-like</em><em> (</em><em>nt</em><em>,</em><em>dt</em><em>)</em>) – samples in the target domain</p></li>
<li><p><strong>ws</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the source samples</p></li>
<li><p><strong>wt</strong> (<em>array-like</em><em> (</em><em>ns</em><em>,</em><em>1</em><em>)</em><em>, </em><em>optional</em>) – weights for the target samples</p></li>
<li><p><strong>sign_eigs</strong> (<em>array-like</em><em> (</em><em>min</em><em>(</em><em>ds</em><em>,</em><em>dt</em><em>)</em><em>,</em><em>) or </em><em>string</em><em>, </em><em>optional</em>) – sign of the eigenvalues of the mapping matrix, by default all signs will
be positive. If ‘skewness’ is provided, the sign of the eigenvalues is
selected as the product of the sign of the skewness of the projected data.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(dt, ds) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, dt) array-like</em>) – bias</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id57">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id58" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022).
Gromov–Wasserstein distances between Gaussian distributions.
Journal of Applied Probability, 59(4), 1178-1198.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id59">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">gaussian_gromov_wasserstein_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Cov_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cov_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#gaussian_gromov_wasserstein_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id59" title="Link to this definition"></a></dt>
<dd><p>Return the Gaussian Gromov-Wasserstein value from [57].</p>
<p>This function return the closed form value of the Gaussian Gromov-Wasserstein
distance between two Gaussian distributions
<span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span> and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span>
when the OT plan is assumed to be also Gaussian. See [57] Theorem 4.1 for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Cov_s</strong> (<em>array-like</em><em> (</em><em>ds</em><em>,</em><em>ds</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Cov_t</strong> (<em>array-like</em><em> (</em><em>dt</em><em>,</em><em>dt</em><em>)</em>) – covariance of the target distribution</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G</strong> – Gaussian Gromov-Wasserstein distance</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<p class="rubric" id="id60">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id61" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022). Gromov–Wasserstein distances between Gaussian distributions.
Journal of Applied Probability, 59(4), 1178-1198.</p>
</aside>
</aside>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id62">
<span class="sig-prename descclassname"><span class="pre">ot.gaussian.</span></span><span class="sig-name descname"><span class="pre">gaussian_gromov_wasserstein_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cov_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cov_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_eigs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/ot/gaussian.html#gaussian_gromov_wasserstein_mapping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id62" title="Link to this definition"></a></dt>
<dd><p>Return the Gaussian Gromov-Wasserstein mapping from [57].</p>
<p>This function return the closed form value of the Gaussian
Gromov-Wasserstein mapping between two Gaussian distributions
<span class="math notranslate nohighlight">\(\mathcal{N}(\mu_s,\Sigma_s)\)</span> and <span class="math notranslate nohighlight">\(\mathcal{N}(\mu_t,\Sigma_t)\)</span>
when the OT plan is assumed to be also Gaussian. See [57] Theorem 4.1 for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu_s</strong> (<em>array-like</em><em> (</em><em>ds</em><em>,</em><em>)</em>) – mean of the source distribution</p></li>
<li><p><strong>mu_t</strong> (<em>array-like</em><em> (</em><em>dt</em><em>,</em><em>)</em>) – mean of the target distribution</p></li>
<li><p><strong>Cov_s</strong> (<em>array-like</em><em> (</em><em>ds</em><em>,</em><em>ds</em><em>)</em>) – covariance of the source distribution</p></li>
<li><p><strong>Cov_t</strong> (<em>array-like</em><em> (</em><em>dt</em><em>,</em><em>dt</em><em>)</em>) – covariance of the target distribution</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – record log if True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>(dt, ds) array-like</em>) – Linear operator</p></li>
<li><p><strong>b</strong> (<em>(1, dt) array-like</em>) – bias</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric" id="id63">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id64" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>57<span class="fn-bracket">]</span></span>
<p>Delon, J., Desolneux, A., &amp; Salmona, A. (2022).
Gromov–Wasserstein distances between Gaussian distributions.
Journal of Applied Probability, 59(4), 1178-1198.</p>
</aside>
</aside>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ot.factored.html" class="btn btn-neutral float-left" title="ot.factored" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ot.gmm.html" class="btn btn-neutral float-right" title="ot.gmm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2025, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span> 0.9.6dev0
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>