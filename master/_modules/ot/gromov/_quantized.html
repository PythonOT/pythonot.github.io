

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.gromov._quantized &mdash; POT Python Optimal Transport 0.9.6dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=6e3d2238"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../../../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_quickstart_guide.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../all.html">API and modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ot.gromov._quantized</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ot.gromov._quantized</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Quantized (Fused) Gromov-Wasserstein solvers.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Author: CÃ©dric Vincent-Cuaz &lt;cedvincentcuaz@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: MIT License</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">networkx.algorithms.community</span><span class="w"> </span><span class="kn">import</span> <span class="n">asyn_fluidc</span><span class="p">,</span> <span class="n">louvain_communities</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_numpy_array</span><span class="p">,</span> <span class="n">pagerank</span>

    <span class="n">networkx_import</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">networkx_import</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralClustering</span><span class="p">,</span> <span class="n">KMeans</span>

    <span class="n">sklearn_import</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">sklearn_import</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">list_to_array</span><span class="p">,</span> <span class="n">unif</span><span class="p">,</span> <span class="n">dist</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..backend</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_backend</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..lp</span><span class="w"> </span><span class="kn">import</span> <span class="n">emd_1d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._gw</span><span class="w"> </span><span class="kn">import</span> <span class="n">gromov_wasserstein</span><span class="p">,</span> <span class="n">fused_gromov_wasserstein</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">init_matrix</span><span class="p">,</span> <span class="n">gwloss</span>


<div class="viewcode-block" id="quantized_fused_gromov_wasserstein_partitioned">
<a class="viewcode-back" href="../../../gen_modules/ot.gromov.html#ot.gromov.quantized_fused_gromov_wasserstein_partitioned">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">quantized_fused_gromov_wasserstein_partitioned</span><span class="p">(</span>
    <span class="n">CR1</span><span class="p">,</span>
    <span class="n">CR2</span><span class="p">,</span>
    <span class="n">list_R1</span><span class="p">,</span>
    <span class="n">list_R2</span><span class="p">,</span>
    <span class="n">list_p1</span><span class="p">,</span>
    <span class="n">list_p2</span><span class="p">,</span>
    <span class="n">MR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">build_OT</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">armijo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span>
    <span class="n">tol_rel</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
    <span class="n">tol_abs</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
    <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the quantized Fused Gromov-Wasserstein transport between</span>
<span class="sd">    :math:`(\mathbf{C_1}, \mathbf{F_1}, \mathbf{p})` and :math:`(\mathbf{C_2},</span>
<span class="sd">    \mathbf{F_2}, \mathbf{q})`, whose samples are assigned to partitions and representants</span>
<span class="sd">    :math:`\mathcal{P_1} = \{(\mathbf{P_{1, i}}, \mathbf{r_{1, i}})\}_{i \leq npart1}`</span>
<span class="sd">    and :math:`\mathcal{P_2} = \{(\mathbf{P_{2, j}}, \mathbf{r_{2, j}})\}_{j \leq npart2}`.</span>
<span class="sd">    The latter must be precomputed and encoded e.g for the source as: :math:`\mathbf{CR_1}`</span>
<span class="sd">    structure matrix between representants; `list_R1` a list of relations between</span>
<span class="sd">    representants and their associated samples; `list_p1` a list of nodes</span>
<span class="sd">    distribution within each partition; :math:`\mathbf{FR_1}` feature matrix</span>
<span class="sd">    of representants.</span>

<span class="sd">    The function estimates the following optimization problem:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{T}^* \in \mathop{\arg \min}_\mathbf{T} \quad \alpha \sum_{i,j,k,l}</span>
<span class="sd">        L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l}</span>
<span class="sd">        + (1-\alpha) \langle \mathbf{T}, M\rangle_F</span>
<span class="sd">        s.t. \ \mathbf{T} \mathbf{1} &amp;= \mathbf{p}</span>

<span class="sd">             \mathbf{T}^T \mathbf{1} &amp;= \mathbf{q}</span>

<span class="sd">             \mathbf{T} &amp;\geq 0</span>

<span class="sd">             \mathbf{T}_{|\mathbf{P_{1, i}}, \mathbf{P_{2, j}}} &amp;= T^{g}_{ij} \mathbf{T}^{(i,j)}</span>

<span class="sd">    using a two-step strategy computing: i) a global alignment :math:`\mathbf{T}^{g}`</span>
<span class="sd">    between representants joint structure and feature spaces; ii) local alignments</span>
<span class="sd">    :math:`\mathbf{T}^{(i, j)}` between partitions :math:`\mathbf{P_{1, i}}`</span>
<span class="sd">    and :math:`\mathbf{P_{2, j}}` seen as 1D measures.</span>

<span class="sd">    Where :</span>

<span class="sd">    - :math:`\mathbf{C_1}`: Metric cost matrix in the source space</span>
<span class="sd">    - :math:`\mathbf{C_2}`: Metric cost matrix in the target space</span>
<span class="sd">    - :math:`\mathbf{F_1}`: Feature matrix in the source space</span>
<span class="sd">    - :math:`\mathbf{F_2}`: Feature matrix in the target space</span>
<span class="sd">    - :math:`\mathbf{M}`: Pairwise similarity matrix between features</span>
<span class="sd">    - :math:`\mathbf{p}`: distribution in the source space</span>
<span class="sd">    - :math:`\mathbf{q}`: distribution in the target space</span>
<span class="sd">    - :math:`L`: quadratic loss function to account for the misfit between the similarity matrices</span>

<span class="sd">    .. note:: This function is backend-compatible and will work on arrays</span>
<span class="sd">        from all compatible backends. But the algorithm uses the C++ CPU backend</span>
<span class="sd">        which can lead to copy overhead on GPU arrays.</span>
<span class="sd">    .. note:: All computations in the Gromov-Wasserstein conjugate gradient solver</span>
<span class="sd">        are done with numpy to limit memory overhead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    CR1 : array-like, shape (npart1, npart1)</span>
<span class="sd">        Structure matrix between partition representants in the source space.</span>
<span class="sd">    CR2 : array-like, shape (npart2, npart2)</span>
<span class="sd">        Structure matrix between partition representants in the target space.</span>
<span class="sd">    list_R1 : list of npart1 arrays,</span>
<span class="sd">        List of relations between representants and their associated samples in the source space.</span>
<span class="sd">    list_R2 : list of npart2 arrays,</span>
<span class="sd">        List of relations between representants and their associated samples in the target space.</span>
<span class="sd">    list_p1 : list of npart1 arrays,</span>
<span class="sd">        List of node distributions within each partition of the source space.</span>
<span class="sd">    list_p : list of npart2 arrays,</span>
<span class="sd">        List of node distributions within each partition of the target space.</span>
<span class="sd">    MR : array-like, shape (npart1, npart2), optional. (Default is None)</span>
<span class="sd">        Metric cost matrix between features of representants across spaces.</span>
<span class="sd">    alpha: float, optional. Default is None.</span>
<span class="sd">        FGW trade-off parameter in :math:`]0, 1]` between structure and features.</span>
<span class="sd">        If `alpha = 1` features are ignored hence computing qGW.</span>
<span class="sd">    build_OT: bool, optional. Default is False</span>
<span class="sd">        Either to build or not the OT between non-partitioned structures.</span>
<span class="sd">    log : bool, optional. Default is False</span>
<span class="sd">        record log if True</span>
<span class="sd">    armijo : bool, optional</span>
<span class="sd">        If True the step of the line-search is found via an armijo research. Else closed form is used.</span>
<span class="sd">        If there are convergence issues use False.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Max number of iterations</span>
<span class="sd">    tol_rel : float, optional</span>
<span class="sd">        Stop threshold on relative error (&gt;0)</span>
<span class="sd">    tol_abs : float, optional</span>
<span class="sd">        Stop threshold on absolute error (&gt;0)</span>
<span class="sd">    nx : backend, optional</span>
<span class="sd">        POT backend</span>

<span class="sd">    **kwargs : dict</span>
<span class="sd">        parameters can be directly passed to the ot.optim.cg solver</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T_global: array-like, shape (`npart1`, `npart2`)</span>
<span class="sd">        Gromov-Wasserstein alignment :math:`\mathbf{T}^{g}` between representants.</span>
<span class="sd">    Ts_local: dict of local OT matrices.</span>
<span class="sd">        Dictionary with keys :math:`(i, j)` corresponding to 1D OT between</span>
<span class="sd">        :math:`\mathbf{P_{1, i}}` and :math:`\mathbf{P_{2, j}}` if :math:`T^{g}_{ij} \neq 0`.</span>
<span class="sd">    T: array-like, shape `(ns, nt)`</span>
<span class="sd">        Coupling between the two spaces if `build_OT=True` else None.</span>
<span class="sd">    log : dict, if `log=True`.</span>
<span class="sd">        Convergence information and losses of inner OT problems.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [68] Chowdhury, S., Miller, D., &amp; Needham, T. (2021).</span>
<span class="sd">        Quantized gromov-wasserstein. ECML PKDD 2021. Springer International Publishing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">CR1</span><span class="p">,</span> <span class="n">CR2</span><span class="p">,</span> <span class="o">*</span><span class="n">list_R1</span><span class="p">,</span> <span class="o">*</span><span class="n">list_R2</span><span class="p">,</span> <span class="o">*</span><span class="n">list_p1</span><span class="p">,</span> <span class="o">*</span><span class="n">list_p2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">MR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MR</span><span class="p">)</span>

        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">npart1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_R1</span><span class="p">)</span>
    <span class="n">npart2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_R2</span><span class="p">)</span>

    <span class="c1"># compute marginals for global alignment</span>
    <span class="n">pR1</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">list_to_array</span><span class="p">([</span><span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_p1</span><span class="p">]))</span>
    <span class="n">pR2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">list_to_array</span><span class="p">([</span><span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">list_p2</span><span class="p">]))</span>

    <span class="c1"># compute global alignment</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">res_global</span> <span class="o">=</span> <span class="n">gromov_wasserstein</span><span class="p">(</span>
            <span class="n">CR1</span><span class="p">,</span>
            <span class="n">CR2</span><span class="p">,</span>
            <span class="n">pR1</span><span class="p">,</span>
            <span class="n">pR2</span><span class="p">,</span>
            <span class="n">loss_fun</span><span class="o">=</span><span class="s2">&quot;square_loss&quot;</span><span class="p">,</span>
            <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
            <span class="n">armijo</span><span class="o">=</span><span class="n">armijo</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">tol_rel</span><span class="o">=</span><span class="n">tol_rel</span><span class="p">,</span>
            <span class="n">tol_abs</span><span class="o">=</span><span class="n">tol_abs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">T_global</span><span class="p">,</span> <span class="n">dist_global</span> <span class="o">=</span> <span class="n">res_global</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res_global</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;gw_dist&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T_global</span> <span class="o">=</span> <span class="n">res_global</span>

    <span class="k">elif</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="n">res_global</span> <span class="o">=</span> <span class="n">fused_gromov_wasserstein</span><span class="p">(</span>
            <span class="n">MR</span><span class="p">,</span>
            <span class="n">CR1</span><span class="p">,</span>
            <span class="n">CR2</span><span class="p">,</span>
            <span class="n">pR1</span><span class="p">,</span>
            <span class="n">pR2</span><span class="p">,</span>
            <span class="s2">&quot;square_loss&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
            <span class="n">armijo</span><span class="o">=</span><span class="n">armijo</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">tol_rel</span><span class="o">=</span><span class="n">tol_rel</span><span class="p">,</span>
            <span class="n">tol_abs</span><span class="o">=</span><span class="n">tol_abs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">T_global</span><span class="p">,</span> <span class="n">dist_global</span> <span class="o">=</span> <span class="n">res_global</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res_global</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;fgw_dist&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T_global</span> <span class="o">=</span> <span class="n">res_global</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            `alpha=&#39;</span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s2">&#39;` should be in ]0, 1].</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">log_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">log_</span><span class="p">[</span><span class="s2">&quot;global dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_global</span>

    <span class="c1"># compute local alignments</span>
    <span class="n">Ts_local</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">list_p1_norm</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="o">/</span> <span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_p1</span><span class="p">]</span>
    <span class="n">list_p2_norm</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span> <span class="o">/</span> <span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">list_p2</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npart1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npart2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">T_global</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">res_1d</span> <span class="o">=</span> <span class="n">emd_1d</span><span class="p">(</span>
                    <span class="n">list_R1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">list_R2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                    <span class="n">list_p1_norm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">list_p2_norm</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;sqeuclidean&quot;</span><span class="p">,</span>
                    <span class="n">p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                    <span class="n">T_local</span><span class="p">,</span> <span class="n">log_local</span> <span class="o">=</span> <span class="n">res_1d</span>
                    <span class="n">Ts_local</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">T_local</span>
                    <span class="n">log_</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;local dist (</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_local</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Ts_local</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res_1d</span>

    <span class="k">if</span> <span class="n">build_OT</span><span class="p">:</span>
        <span class="n">T_rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npart1</span><span class="p">):</span>
            <span class="n">list_Ti</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npart2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">T_global</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">T_local</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">list_R1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">list_R2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">type_as</span><span class="o">=</span><span class="n">T_global</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">T_local</span> <span class="o">=</span> <span class="n">T_global</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ts_local</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
                <span class="n">list_Ti</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T_local</span><span class="p">)</span>

            <span class="n">Ti</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">list_Ti</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">T_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ti</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">T_rows</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">log_</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span></div>



<div class="viewcode-block" id="get_graph_partition">
<a class="viewcode-back" href="../../../gen_modules/ot.gromov.html#ot.gromov.get_graph_partition">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_graph_partition</span><span class="p">(</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">npart</span><span class="p">,</span> <span class="n">part_method</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Partitioning a given graph with structure matrix :math:`\mathbf{C} \in R^{n \times n}`</span>
<span class="sd">    into `npart` partitions either &#39;random&#39;, or using one of {&#39;louvain&#39;, &#39;fluid&#39;}</span>
<span class="sd">    algorithms from networkx, or &#39;spectral&#39; clustering from scikit-learn,</span>
<span class="sd">    or (Fused) Gromov-Wasserstein projections from POT.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : array-like, shape (n, n)</span>
<span class="sd">        Structure matrix.</span>
<span class="sd">    npart : int,</span>
<span class="sd">        number of partitions/clusters smaller than the number of nodes in</span>
<span class="sd">        :math:`\mathbf{C}`.</span>
<span class="sd">    part_method : str, optional. Default is &#39;random&#39;.</span>
<span class="sd">        Partitioning algorithm to use among {&#39;random&#39;, &#39;louvain&#39;, &#39;fluid&#39;, &#39;spectral&#39;, &#39;GW&#39;, &#39;FGW&#39;}.</span>
<span class="sd">        &#39;random&#39; for random sampling of points; &#39;louvain&#39; and &#39;fluid&#39; for graph</span>
<span class="sd">        partitioning algorithm that works well on adjacency matrix, If the</span>
<span class="sd">        louvain algorithm is used, `npart` is ignored; &#39;spectral&#39; for spectral</span>
<span class="sd">        clustering; &#39;(F)GW&#39; for (F)GW projection using sr(F)GW solvers.</span>
<span class="sd">    F : array-like, shape (n, d), optional. (Default is None)</span>
<span class="sd">        Optional feature matrix aligned with the graph structure. Only used if</span>
<span class="sd">        `part_method=&quot;FGW&quot;`.</span>
<span class="sd">    alpha : float, optional. (Default is 1.)</span>
<span class="sd">        Trade-off parameter between feature and structure matrices, taking</span>
<span class="sd">        values in [0, 1] and only used if `F != None` and `part_method=&quot;FGW&quot;`.</span>
<span class="sd">    random_state: int, optional</span>
<span class="sd">        Random seed for the partitioning algorithm.</span>
<span class="sd">    nx : backend, optional</span>
<span class="sd">        POT backend.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    part : array-like, shape (npart,)</span>
<span class="sd">        Array of partition assignment for each node.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [68] Chowdhury, S., Miller, D., &amp; Needham, T. (2021).</span>
<span class="sd">        Quantized gromov-wasserstein. ECML PKDD 2021. Springer International Publishing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">C0</span> <span class="o">=</span> <span class="n">C</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">F</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`alpha != 1` but node features are not provided.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">npart</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Requested number of partitions higher than the number of nodes&quot;</span>
            <span class="s2">&quot;hence we enforce each node to be a partition.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">npart</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">part_method</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
        <span class="c1"># randomly partition the space</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">list_to_array</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npart</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">elif</span> <span class="n">part_method</span> <span class="o">==</span> <span class="s2">&quot;louvain&quot;</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">C0</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">from_numpy_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">part_sets</span> <span class="o">=</span> <span class="n">louvain_communities</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iset_</span><span class="p">,</span> <span class="n">set_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_sets</span><span class="p">):</span>
            <span class="n">set_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span>
            <span class="n">part</span><span class="p">[</span><span class="n">set_</span><span class="p">]</span> <span class="o">=</span> <span class="n">iset_</span>

    <span class="k">elif</span> <span class="n">part_method</span> <span class="o">==</span> <span class="s2">&quot;fluid&quot;</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">C0</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">from_numpy_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">part_sets</span> <span class="o">=</span> <span class="n">asyn_fluidc</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">npart</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iset_</span><span class="p">,</span> <span class="n">set_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_sets</span><span class="p">):</span>
            <span class="n">set_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span>
            <span class="n">part</span><span class="p">[</span><span class="n">set_</span><span class="p">]</span> <span class="o">=</span> <span class="n">iset_</span>

    <span class="k">elif</span> <span class="n">part_method</span> <span class="o">==</span> <span class="s2">&quot;spectral&quot;</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">C0</span><span class="p">)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">SpectralClustering</span><span class="p">(</span>
            <span class="n">n_clusters</span><span class="o">=</span><span class="n">npart</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">affinity</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">labels_</span>

    <span class="k">elif</span> <span class="n">part_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;GW&quot;</span><span class="p">,</span> <span class="s2">&quot;FGW&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`part_method == </span><span class="si">{</span><span class="n">part_method</span><span class="si">}</span><span class="s2">` not implemented yet.&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            Unknown `part_method=&#39;</span><span class="si">{</span><span class="n">part_method</span><span class="si">}</span><span class="s2">&#39;`. Use one of:</span>
<span class="s2">            </span><span class="si">{</span><span class="s2">&quot;random&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;louvain&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;fluid&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;spectral&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;GW&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;FGW&quot;</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">C0</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_graph_representants">
<a class="viewcode-back" href="../../../gen_modules/ot.gromov.html#ot.gromov.get_graph_representants">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_graph_representants</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">rep_method</span><span class="o">=</span><span class="s2">&quot;pagerank&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get representative node for each partition given by :math:`\mathbf{part} \in R^{n}`</span>
<span class="sd">    of a graph with structure matrix :math:`\mathbf{C} \in R^{n \times n}`.</span>
<span class="sd">    Selection is either done randomly or using &#39;pagerank&#39; algorithm from networkx.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : array-like, shape (n, n)</span>
<span class="sd">        structure matrix.</span>
<span class="sd">    part : array-like, shape (n,)</span>
<span class="sd">        Array of partition assignment for each node.</span>
<span class="sd">    rep_method : str, optional. Default is &#39;pagerank&#39;.</span>
<span class="sd">        Selection method for representant in each partition. Can be either &#39;random&#39;</span>
<span class="sd">        i.e random sampling within each partition, or &#39;pagerank&#39; to select a</span>
<span class="sd">        node with maximal pagerank.</span>
<span class="sd">    random_state: int, optional</span>
<span class="sd">        Random seed for the partitioning algorithm</span>
<span class="sd">    nx : backend, optional</span>
<span class="sd">        POT backend</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rep_indices : list, shape (npart,)</span>
<span class="sd">        indices for representative node of each partition sorted</span>
<span class="sd">        according to partition identifiers.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [68] Chowdhury, S., Miller, D., &amp; Needham, T. (2021).</span>
<span class="sd">        Quantized gromov-wasserstein. ECML PKDD 2021. Springer International Publishing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>

    <span class="n">rep_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">part_ids</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">n_part_ids</span> <span class="o">=</span> <span class="n">part_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n_part_ids</span> <span class="o">==</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">rep_indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_part_ids</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">rep_method</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">part_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_ids</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">part</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rep_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">rep_method</span> <span class="o">==</span> <span class="s2">&quot;pagerank&quot;</span><span class="p">:</span>
        <span class="n">C0</span><span class="p">,</span> <span class="n">part0</span> <span class="o">=</span> <span class="n">C</span><span class="p">,</span> <span class="n">part</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">C0</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">part0</span><span class="p">)</span>
        <span class="n">part_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">part_ids</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">part</span> <span class="o">==</span> <span class="n">id_</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">C_id</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">indices</span><span class="p">]</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">from_numpy_array</span><span class="p">(</span><span class="n">C_id</span><span class="p">)</span>
            <span class="n">pagerank_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pagerank</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">rep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pagerank_values</span><span class="p">)</span>
            <span class="n">rep_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">rep_idx</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            Unknown `rep_method=&#39;</span><span class="si">{</span><span class="n">rep_method</span><span class="si">}</span><span class="s2">&#39;`. Use one of:</span>
<span class="s2">            </span><span class="si">{</span><span class="s2">&quot;random&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;pagerank&quot;</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">rep_indices</span></div>



<div class="viewcode-block" id="format_partitioned_graph">
<a class="viewcode-back" href="../../../gen_modules/ot.gromov.html#ot.gromov.format_partitioned_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">format_partitioned_graph</span><span class="p">(</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">rep_indices</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format an attributed graph :math:`(\mathbf{C}, \mathbf{F}, \mathbf{p})`</span>
<span class="sd">    with structure matrix :math:`(\mathbf{C} \in R^{n \times n}`, feature matrix</span>
<span class="sd">    :math:`(\mathbf{F} \in R^{n \times d}` and node relative importance</span>
<span class="sd">    :math:`(\mathbf{p} \in \Sigma_n`, into a partitioned attributed graph</span>
<span class="sd">    taking into account partitions and representants :math:`\mathcal{P} = \left{(\mathbf{P_{i}}, \mathbf{r_{i}})\right}_i`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : array-like, shape (n, n)</span>
<span class="sd">        Structure matrix.</span>
<span class="sd">    p : array-like, shape (n,),</span>
<span class="sd">        Node distribution.</span>
<span class="sd">    part : array-like, shape (n,)</span>
<span class="sd">        Array of partition assignment for each node.</span>
<span class="sd">    rep_indices : list of array-like of ints, shape (npart,)</span>
<span class="sd">        indices for representative node of each partition sorted according to</span>
<span class="sd">        partition identifiers.</span>
<span class="sd">    F : array-like, shape (n, d), optional. (Default is None)</span>
<span class="sd">        Optional feature matrix aligned with the graph structure.</span>
<span class="sd">    M : array-like, shape (n, n), optional. (Default is None)</span>
<span class="sd">        Optional pairwise similarity matrix between features.</span>
<span class="sd">    alpha: float, optional. Default is 1.</span>
<span class="sd">        Trade-off parameter in :math:`]0, 1]` between structure and features.</span>
<span class="sd">        If `alpha = 1` features are ignored. This trade-off is taken into account</span>
<span class="sd">        into the outputted relations between nodes and representants.</span>
<span class="sd">    nx : backend, optional</span>
<span class="sd">        POT backend</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    CR : array-like, shape (npart, npart)</span>
<span class="sd">        Structure matrix between partition representants.</span>
<span class="sd">    list_R : list of npart arrays,</span>
<span class="sd">        List of relations between a representant and nodes in its partition,</span>
<span class="sd">        for each partition.</span>
<span class="sd">    list_p : list of npart arrays,</span>
<span class="sd">        List of node distributions within each partition.</span>
<span class="sd">    FR : array-like, shape (npart, d), if `F != None`.</span>
<span class="sd">        Feature matrix of representants.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [68] Chowdhury, S., Miller, D., &amp; Needham, T. (2021).</span>
<span class="sd">        Quantized gromov-wasserstein. ECML PKDD 2021. Springer International Publishing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">part</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">F</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                `alpha == </span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s2"> != 1` but features information is not properly provided.</span>
<span class="s2">                &quot;&quot;&quot;</span>
            <span class="p">)</span>

    <span class="n">CR</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">rep_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">rep_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">C_new</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">C</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">M</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C_new</span> <span class="o">=</span> <span class="n">C</span>

    <span class="n">list_R</span><span class="p">,</span> <span class="n">list_p</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="n">part_ids</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">part_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_ids</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">part</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">list_R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C_new</span><span class="p">[</span><span class="n">rep_indices</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span> <span class="n">indices</span><span class="p">])</span>
        <span class="n">list_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CR</span><span class="p">,</span> <span class="n">list_R</span><span class="p">,</span> <span class="n">list_p</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">FR</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">rep_indices</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">CR</span><span class="p">,</span> <span class="n">list_R</span><span class="p">,</span> <span class="n">list_p</span><span class="p">,</span> <span class="n">FR</span></div>



<div class="viewcode-block" id="quantized_fused_gromov_wasserstein">
<a class="viewcode-back" href="../../../gen_modules/ot.gromov.html#ot.gromov.quantized_fused_gromov_wasserstein">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">quantized_fused_gromov_wasserstein</span><span class="p">(</span>
    <span class="n">C1</span><span class="p">,</span>
    <span class="n">C2</span><span class="p">,</span>
    <span class="n">npart1</span><span class="p">,</span>
    <span class="n">npart2</span><span class="p">,</span>
    <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">C1_aux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">C2_aux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">F1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">F2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">part_method</span><span class="o">=</span><span class="s2">&quot;fluid&quot;</span><span class="p">,</span>
    <span class="n">rep_method</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">armijo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span>
    <span class="n">tol_rel</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
    <span class="n">tol_abs</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the quantized Fused Gromov-Wasserstein transport between</span>
<span class="sd">    :math:`(\mathbf{C_1}, \mathbf{F_1}, \mathbf{p})` and :math:`(\mathbf{C_2},</span>
<span class="sd">    \mathbf{F_2}, \mathbf{q})`, whose samples are assigned to partitions and</span>
<span class="sd">    representants :math:`\mathcal{P_1} = \{(\mathbf{P_{1, i}}, \mathbf{r_{1, i}})\}_{i \leq npart1}`</span>
<span class="sd">    and :math:`\mathcal{P_2} = \{(\mathbf{P_{2, j}}, \mathbf{r_{2, j}})\}_{j \leq npart2}`.</span>

<span class="sd">    The function estimates the following optimization problem:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{T}^* \in \mathop{\arg \min}_\mathbf{T} \quad \alpha \sum_{i,j,k,l}</span>
<span class="sd">        L(\mathbf{C_1}_{i,k}, \mathbf{C_2}_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l}</span>
<span class="sd">        + (1-\alpha) \langle \mathbf{T}, \mathbf{D}(\mathbf{F_1}, \mathbf{F}_2) \rangle_F</span>
<span class="sd">        s.t. \ \mathbf{T} \mathbf{1} &amp;= \mathbf{p}</span>

<span class="sd">             \mathbf{T}^T \mathbf{1} &amp;= \mathbf{q}</span>

<span class="sd">             \mathbf{T} &amp;\geq 0</span>

<span class="sd">             \mathbf{T}_{|\mathbf{P_{1, i}}, \mathbf{P_{2, j}}} &amp;= T^{g}_{ij} \mathbf{T}^{(i,j)}</span>

<span class="sd">    using a two-step strategy computing: i) a global alignment :math:`\mathbf{T}^{g}`</span>
<span class="sd">    between representants across joint structure and feature spaces;</span>
<span class="sd">    ii) local alignments :math:`\mathbf{T}^{(i, j)}` between partitions</span>
<span class="sd">    :math:`\mathbf{P_{1, i}}` and :math:`\mathbf{P_{2, j}}` seen as 1D measures.</span>

<span class="sd">    Where :</span>

<span class="sd">    - :math:`\mathbf{C_1}`: Metric cost matrix in the source space</span>
<span class="sd">    - :math:`\mathbf{C_2}`: Metric cost matrix in the target space</span>
<span class="sd">    - :math:`\mathbf{F_1}`: Feature matrix in the source space</span>
<span class="sd">    - :math:`\mathbf{F_2}`: Feature matrix in the target space</span>
<span class="sd">    - :math:`\mathbf{D}(\mathbf{F_1}, \mathbf{F_2})`: Pairwise euclidean distance matrix between features</span>
<span class="sd">    - :math:`\mathbf{p}`: distribution in the source space</span>
<span class="sd">    - :math:`\mathbf{q}`: distribution in the target space</span>
<span class="sd">    - :math:`L`: quadratic loss function to account for the misfit between the similarity matrices</span>

<span class="sd">    .. note:: This function is backend-compatible and will work on arrays</span>
<span class="sd">        from all compatible backends. But the algorithm uses the C++ CPU backend</span>
<span class="sd">        which can lead to copy overhead on GPU arrays.</span>
<span class="sd">    .. note:: All computations in the conjugate gradient solver are done with</span>
<span class="sd">        numpy to limit memory overhead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C1 : array-like, shape (ns, ns)</span>
<span class="sd">        Structure matrix in the source space.</span>
<span class="sd">    C2 : array-like, shape (nt, nt)</span>
<span class="sd">        Structure matrix in the target space.</span>
<span class="sd">    npart1 : int,</span>
<span class="sd">        number of partition in the source space.</span>
<span class="sd">    npart2 : int,</span>
<span class="sd">        number of partition in the target space.</span>
<span class="sd">    p : array-like, shape (ns,), optional</span>
<span class="sd">        Distribution in the source space.</span>
<span class="sd">        If let to its default value None, uniform distribution is taken.</span>
<span class="sd">    q : array-like, shape (nt,), optional</span>
<span class="sd">        Distribution in the target space.</span>
<span class="sd">        If let to its default value None, uniform distribution is taken.</span>
<span class="sd">    C1_aux : array-like, shape (ns, ns), optional. Default is None.</span>
<span class="sd">        Auxiliary structure matrix in the source space to perform the partitioning</span>
<span class="sd">        and representant selection.</span>
<span class="sd">    C2_aux : array-like, shape (nt, nt), optional. Default is None.</span>
<span class="sd">        Auxiliary structure matrix in the target space to perform the partitioning</span>
<span class="sd">        and representant selection.</span>
<span class="sd">    F1 : array-like, shape (ns, d), optional. Default is None.</span>
<span class="sd">        Feature matrix in the source space.</span>
<span class="sd">    F2 : array-like, shape (nt, d), optional. Default is None.</span>
<span class="sd">        Feature matrix in the target space</span>
<span class="sd">    alpha: float, optional. Default is 1.</span>
<span class="sd">        FGW trade-off parameter in :math:`]0, 1]` between structure and features.</span>
<span class="sd">        If `alpha = 1` features are ignored hence computing qGW, if `alpha=0`</span>
<span class="sd">        structures are ignored and we compute the quantized Wasserstein transport.</span>
<span class="sd">    part_method : str, optional. Default is &#39;spectral&#39;.</span>
<span class="sd">        Partitioning algorithm to use among {&#39;random&#39;, &#39;louvain&#39;, &#39;fluid&#39;,</span>
<span class="sd">        &#39;spectral&#39;, &#39;louvain_fused&#39;, &#39;fluid_fused&#39;, &#39;spectral_fused&#39;, &#39;GW&#39;, &#39;FGW&#39;}.</span>
<span class="sd">        If part_method in {&#39;louvain_fused&#39;, &#39;fluid_fused&#39;, &#39;spectral_fused&#39;},</span>
<span class="sd">        corresponding graph partitioning algorithm {&#39;louvain&#39;, &#39;fluid&#39;, &#39;spectral&#39;}</span>
<span class="sd">        will be used on the modified structure matrix</span>
<span class="sd">        :math:`\alpha \mathbf{C} + (1 - \alpha) \mathbf{D}(\mathbf{F})` where</span>
<span class="sd">        :math:`\mathbf{D}(\mathbf{F})` is the pairwise euclidean matrix between features.</span>
<span class="sd">        If part_method in {&#39;GW&#39;, &#39;FGW&#39;}, a (F)GW projection is used.</span>
<span class="sd">        If the louvain algorithm is used, the requested number of partitions is</span>
<span class="sd">        ignored.</span>
<span class="sd">    rep_method : str, optional. Default is &#39;pagerank&#39;.</span>
<span class="sd">        Selection method for node representant in each partition.</span>
<span class="sd">        Can be either &#39;random&#39; i.e random sampling within each partition,</span>
<span class="sd">        {&#39;pagerank&#39;, &#39;pagerank_fused&#39;} to select a node with maximal pagerank w.r.t</span>
<span class="sd">        :math:`\mathbf{C}` or :math:`\alpha \mathbf{C} + (1 - \alpha) \mathbf{D}(\mathbf{F})`.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Print information along iterations</span>
<span class="sd">    log : bool, optional</span>
<span class="sd">        record log if True</span>
<span class="sd">    armijo : bool, optional</span>
<span class="sd">        If True the step of the line-search is found via an armijo research. Else closed form is used.</span>
<span class="sd">        If there are convergence issues use False.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Max number of iterations</span>
<span class="sd">    tol_rel : float, optional</span>
<span class="sd">        Stop threshold on relative error (&gt;0)</span>
<span class="sd">    tol_abs : float, optional</span>
<span class="sd">        Stop threshold on absolute error (&gt;0)</span>
<span class="sd">    random_state: int, optional</span>
<span class="sd">        Random seed for the partitioning algorithm</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        parameters can be directly passed to the ot.optim.cg solver</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T_global: array-like, shape (`npart1`, `npart2`)</span>
<span class="sd">        Fused Gromov-Wasserstein alignment :math:`\mathbf{T}^{g}` between representants.</span>
<span class="sd">    Ts_local: dict of local OT matrices.</span>
<span class="sd">        Dictionary with keys :math:`(i, j)` corresponding to 1D OT between</span>
<span class="sd">        :math:`\mathbf{P_{1, i}}` and :math:`\mathbf{P_{2, j}}` if :math:`T^{g}_{ij} \neq 0`.</span>
<span class="sd">    T: array-like, shape `(ns, nt)`</span>
<span class="sd">        Coupling between the two spaces.</span>
<span class="sd">    log : dict</span>
<span class="sd">        Convergence information for inner problems and qGW loss.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [68] Chowdhury, S., Miller, D., &amp; Needham, T. (2021).</span>
<span class="sd">        Quantized gromov-wasserstein. ECML PKDD 2021. Springer International Publishing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">part_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;fluid&quot;</span><span class="p">,</span> <span class="s2">&quot;louvain&quot;</span><span class="p">,</span> <span class="s2">&quot;fluid_fused&quot;</span><span class="p">,</span> <span class="s2">&quot;louvain_fused&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">rep_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pagerank&quot;</span><span class="p">,</span> <span class="s2">&quot;pagerank_fused&quot;</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">networkx_import</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                Networkx is not installed, so part_method=</span><span class="si">{</span><span class="n">part_method</span><span class="si">}</span><span class="s2"> and/or</span>
<span class="s2">                rep_method=</span><span class="si">{</span><span class="n">rep_method</span><span class="si">}</span><span class="s2"> cannot be used and are set to `random`</span>
<span class="s2">                default methods. Consider installing Networkx to fix this.</span>
<span class="s2">                &quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="n">part_method</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
        <span class="n">rep_method</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">part_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;spectral&quot;</span><span class="p">,</span> <span class="s2">&quot;spectral_fused&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sklearn_import</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            Scikit-learn is not installed, so part_method=</span><span class="si">{</span><span class="n">part_method</span><span class="si">}</span><span class="s2"> and/or</span>
<span class="s2">            rep_method=</span><span class="si">{</span><span class="n">rep_method</span><span class="si">}</span><span class="s2"> cannot be used and are set to `random`</span>
<span class="s2">            default methods. Consider installing Scikit-learn to fix this.</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>
        <span class="n">part_method</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
        <span class="n">rep_method</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;fused&quot;</span> <span class="ow">in</span> <span class="n">part_method</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;fused&quot;</span> <span class="ow">in</span> <span class="n">rep_method</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">part_method</span> <span class="o">==</span> <span class="s2">&quot;FGW&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">F1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">F2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                `part_method=&#39;</span><span class="si">{</span><span class="n">part_method</span><span class="si">}</span><span class="s2">&#39;` and/or `rep_method=&#39;</span><span class="si">{</span><span class="n">rep_method</span><span class="si">}</span><span class="s2">&#39;`</span>
<span class="s2">                require feature matrices which are not provided as inputs.</span>
<span class="s2">                &quot;&quot;&quot;</span>
            <span class="p">)</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">C1_aux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C1_aux</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C1_aux</span> <span class="o">=</span> <span class="n">C1</span>
    <span class="k">if</span> <span class="n">C2_aux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C2_aux</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C2_aux</span> <span class="o">=</span> <span class="n">C2</span>
    <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_to_array</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">unif</span><span class="p">(</span><span class="n">C1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">type_as</span><span class="o">=</span><span class="n">C1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_to_array</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">unif</span><span class="p">(</span><span class="n">C2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">type_as</span><span class="o">=</span><span class="n">C1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">F1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">F2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>

    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">DF1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">DF2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># compute attributed graph partitions potentially using the auxiliary structure</span>
    <span class="k">if</span> <span class="s2">&quot;fused&quot;</span> <span class="ow">in</span> <span class="n">part_method</span><span class="p">:</span>
        <span class="n">DF1</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F1</span><span class="p">)</span>
        <span class="n">DF2</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F2</span><span class="p">,</span> <span class="n">F2</span><span class="p">)</span>
        <span class="n">C1_new</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">C1_aux</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">DF1</span>
        <span class="n">C2_new</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">C2_aux</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">DF2</span>

        <span class="n">part_method_</span> <span class="o">=</span> <span class="n">part_method</span><span class="p">[:</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>
        <span class="n">part1</span> <span class="o">=</span> <span class="n">get_graph_partition</span><span class="p">(</span>
            <span class="n">C1_new</span><span class="p">,</span> <span class="n">npart1</span><span class="p">,</span> <span class="n">part_method_</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span>
        <span class="p">)</span>
        <span class="n">part2</span> <span class="o">=</span> <span class="n">get_graph_partition</span><span class="p">(</span>
            <span class="n">C2_new</span><span class="p">,</span> <span class="n">npart2</span><span class="p">,</span> <span class="n">part_method_</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">part1</span> <span class="o">=</span> <span class="n">get_graph_partition</span><span class="p">(</span>
            <span class="n">C1_aux</span><span class="p">,</span> <span class="n">npart1</span><span class="p">,</span> <span class="n">part_method</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>
        <span class="n">part2</span> <span class="o">=</span> <span class="n">get_graph_partition</span><span class="p">(</span>
            <span class="n">C2_aux</span><span class="p">,</span> <span class="n">npart2</span><span class="p">,</span> <span class="n">part_method</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;fused&quot;</span> <span class="ow">in</span> <span class="n">rep_method</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">DF1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">DF1</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F1</span><span class="p">)</span>
            <span class="n">DF2</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F2</span><span class="p">,</span> <span class="n">F2</span><span class="p">)</span>
            <span class="n">C1_new</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">C1_aux</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">DF1</span>
            <span class="n">C2_new</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">C2_aux</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">DF2</span>

        <span class="n">rep_method_</span> <span class="o">=</span> <span class="n">rep_method</span><span class="p">[:</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>

        <span class="n">rep_indices1</span> <span class="o">=</span> <span class="n">get_graph_representants</span><span class="p">(</span>
            <span class="n">C1_new</span><span class="p">,</span> <span class="n">part1</span><span class="p">,</span> <span class="n">rep_method_</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>
        <span class="n">rep_indices2</span> <span class="o">=</span> <span class="n">get_graph_representants</span><span class="p">(</span>
            <span class="n">C2_new</span><span class="p">,</span> <span class="n">part2</span><span class="p">,</span> <span class="n">rep_method_</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">rep_indices1</span> <span class="o">=</span> <span class="n">get_graph_representants</span><span class="p">(</span>
            <span class="n">C1_aux</span><span class="p">,</span> <span class="n">part1</span><span class="p">,</span> <span class="n">rep_method</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>
        <span class="n">rep_indices2</span> <span class="o">=</span> <span class="n">get_graph_representants</span><span class="p">(</span>
            <span class="n">C2_aux</span><span class="p">,</span> <span class="n">part2</span><span class="p">,</span> <span class="n">rep_method</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>

    <span class="c1"># format partitions over (C1, F1) and (C2, F2)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">F1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">F2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">CR1</span><span class="p">,</span> <span class="n">list_R1</span><span class="p">,</span> <span class="n">list_p1</span> <span class="o">=</span> <span class="n">format_partitioned_graph</span><span class="p">(</span>
            <span class="n">C1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">part1</span><span class="p">,</span> <span class="n">rep_indices1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span>
        <span class="p">)</span>
        <span class="n">CR2</span><span class="p">,</span> <span class="n">list_R2</span><span class="p">,</span> <span class="n">list_p2</span> <span class="o">=</span> <span class="n">format_partitioned_graph</span><span class="p">(</span>
            <span class="n">C2</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">part2</span><span class="p">,</span> <span class="n">rep_indices2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span>
        <span class="p">)</span>

        <span class="n">MR</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">DF1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">DF1</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F1</span><span class="p">)</span>
            <span class="n">DF2</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F2</span><span class="p">,</span> <span class="n">F2</span><span class="p">)</span>

        <span class="n">CR1</span><span class="p">,</span> <span class="n">list_R1</span><span class="p">,</span> <span class="n">list_p1</span><span class="p">,</span> <span class="n">FR1</span> <span class="o">=</span> <span class="n">format_partitioned_graph</span><span class="p">(</span>
            <span class="n">C1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">part1</span><span class="p">,</span> <span class="n">rep_indices1</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">DF1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>
        <span class="n">CR2</span><span class="p">,</span> <span class="n">list_R2</span><span class="p">,</span> <span class="n">list_p2</span><span class="p">,</span> <span class="n">FR2</span> <span class="o">=</span> <span class="n">format_partitioned_graph</span><span class="p">(</span>
            <span class="n">C2</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">part2</span><span class="p">,</span> <span class="n">rep_indices2</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">DF2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>

        <span class="n">MR</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">FR1</span><span class="p">,</span> <span class="n">FR2</span><span class="p">)</span>
    <span class="c1"># call to partitioned quantized fused gromov-wasserstein solver</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">quantized_fused_gromov_wasserstein_partitioned</span><span class="p">(</span>
        <span class="n">CR1</span><span class="p">,</span>
        <span class="n">CR2</span><span class="p">,</span>
        <span class="n">list_R1</span><span class="p">,</span>
        <span class="n">list_R2</span><span class="p">,</span>
        <span class="n">list_p1</span><span class="p">,</span>
        <span class="n">list_p2</span><span class="p">,</span>
        <span class="n">MR</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">build_OT</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
        <span class="n">armijo</span><span class="o">=</span><span class="n">armijo</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
        <span class="n">tol_rel</span><span class="o">=</span><span class="n">tol_rel</span><span class="p">,</span>
        <span class="n">tol_abs</span><span class="o">=</span><span class="n">tol_abs</span><span class="p">,</span>
        <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">log_</span> <span class="o">=</span> <span class="n">res</span>

        <span class="c1"># compute the transport cost on structures</span>
        <span class="n">constC</span><span class="p">,</span> <span class="n">hC1</span><span class="p">,</span> <span class="n">hC2</span> <span class="o">=</span> <span class="n">init_matrix</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s2">&quot;square_loss&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
        <span class="n">structure_cost</span> <span class="o">=</span> <span class="n">gwloss</span><span class="p">(</span><span class="n">constC</span><span class="p">,</span> <span class="n">hC1</span><span class="p">,</span> <span class="n">hC2</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">)</span>
            <span class="n">feature_cost</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feature_cost</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">log_</span><span class="p">[</span><span class="s2">&quot;qFGW_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">structure_cost</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">feature_cost</span>
        <span class="k">return</span> <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">log_</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span></div>



<div class="viewcode-block" id="get_partition_and_representants_samples">
<a class="viewcode-back" href="../../../gen_modules/ot.gromov.html#ot.gromov.get_partition_and_representants_samples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_partition_and_representants_samples</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">npart</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;kmeans&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `npart` partitions and representants over samples :math:`\mathbf{X} \in R^{n \times d}`</span>
<span class="sd">    using either a random or a kmeans algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like, shape (n, d)</span>
<span class="sd">        Samples endowed with an euclidean geometry.</span>
<span class="sd">    npart : int,</span>
<span class="sd">        number of partitions smaller than the number of samples in</span>
<span class="sd">        :math:`\mathbf{X}`.</span>
<span class="sd">    method : str, optional. Default is &#39;kmeans&#39;.</span>
<span class="sd">        Partitioning and representant selection algorithms to use among</span>
<span class="sd">        {&#39;random&#39;, &#39;kmeans&#39;}. &#39;random&#39; for random sampling of points; &#39;kmeans&#39;</span>
<span class="sd">        for k-means clustering using scikit-learn implementation where closest</span>
<span class="sd">        points to centroids are considered as representants.</span>
<span class="sd">    random_state: int, optional</span>
<span class="sd">        Random seed for the partitioning algorithm.</span>
<span class="sd">    nx : backend, optional</span>
<span class="sd">        POT backend.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    part : array-like, shape (npart,)</span>
<span class="sd">        Array of partition assignment for each node.</span>

<span class="sd">    rep_indices : list, shape (npart,)</span>
<span class="sd">        indices for representative node of each partition sorted</span>
<span class="sd">        according to partition identifiers.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [68] Chowdhury, S., Miller, D., &amp; Needham, T. (2021).</span>
<span class="sd">        Quantized gromov-wasserstein. ECML PKDD 2021. Springer International Publishing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">X</span>

    <span class="k">if</span> <span class="n">npart</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Requested number of partitions higher than the number of nodes&quot;</span>
            <span class="s2">&quot;hence we enforce each node to be a partition.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">part</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">rep_indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">npart</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">rep_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">))]</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
        <span class="c1"># randomly partition the space</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">list_to_array</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npart</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">X0</span><span class="p">)</span>

        <span class="c1"># randomly select representant in each partition</span>
        <span class="n">rep_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">part_ids</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">part_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_ids</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">part</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rep_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;kmeans&quot;</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">X0</span><span class="p">)</span>
        <span class="n">km</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">npart</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">km</span><span class="o">.</span><span class="n">labels_</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">X0</span><span class="p">)</span>

        <span class="n">rep_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">part_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npart</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">part</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">km</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">part_id</span><span class="p">][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">best_idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">dists</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
            <span class="n">rep_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_idx</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            Unknown `method=&#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39;`. Use one of: </span><span class="si">{</span><span class="s2">&quot;random&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;kmeans&quot;</span><span class="si">}</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">part</span><span class="p">,</span> <span class="n">rep_indices</span></div>



<div class="viewcode-block" id="format_partitioned_samples">
<a class="viewcode-back" href="../../../gen_modules/ot.gromov.html#ot.gromov.format_partitioned_samples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">format_partitioned_samples</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">rep_indices</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format an attributed graph :math:`(\mathbf{D}(\mathbf{X}), \mathbf{F}, \mathbf{p})`</span>
<span class="sd">    with euclidean structure matrix :math:`(\mathbf{D}(\mathbf{X}) \in R^{n \times n}`,</span>
<span class="sd">    feature matrix :math:`(\mathbf{F} \in R^{n \times d}` and node relative importance</span>
<span class="sd">    :math:`(\mathbf{p} \in \Sigma_n`, into a partitioned attributed graph</span>
<span class="sd">    taking into account partitions and representants :math:`\mathcal{P} = \left{(\mathbf{P_{i}}, \mathbf{r_{i}})\right}_i`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like, shape (n, d)</span>
<span class="sd">        Structure matrix.</span>
<span class="sd">    p : array-like, shape (n,),</span>
<span class="sd">        Node distribution.</span>
<span class="sd">    part : array-like, shape (n,)</span>
<span class="sd">        Array of partition assignment for each node.</span>
<span class="sd">    rep_indices : list of array-like of ints, shape (npart,)</span>
<span class="sd">        indices for representative node of each partition sorted according to</span>
<span class="sd">        partition identifiers.</span>
<span class="sd">    F : array-like, shape (n, p), optional. (Default is None)</span>
<span class="sd">        Optional feature matrix aligned with the samples.</span>
<span class="sd">    alpha: float, optional. Default is 1.</span>
<span class="sd">        Trade-off parameter in :math:`]0, 1]` between structure and features.</span>
<span class="sd">        If `alpha = 1` features are ignored. This trade-off is taken into account</span>
<span class="sd">        into the outputted relations between nodes and representants.</span>
<span class="sd">    nx : backend, optional</span>
<span class="sd">        POT backend</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    CR : array-like, shape (npart, npart)</span>
<span class="sd">        Structure matrix between partition representants.</span>
<span class="sd">    list_R : list of npart arrays,</span>
<span class="sd">        List of relations between a representant and nodes in its partition,</span>
<span class="sd">        for each partition.</span>
<span class="sd">    list_p : list of npart arrays,</span>
<span class="sd">        List of node distributions within each partition.</span>
<span class="sd">    FR : array-like, shape (npart, d), if `F != None`.</span>
<span class="sd">        Feature matrix of representants.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [68] Chowdhury, S., Miller, D., &amp; Needham, T. (2021).</span>
<span class="sd">        Quantized gromov-wasserstein. ECML PKDD 2021. Springer International Publishing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">part</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                `alpha == </span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s2"> != 1` but features information is not properly provided.</span>
<span class="s2">                &quot;&quot;&quot;</span>
            <span class="p">)</span>

    <span class="n">XR</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">rep_indices</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">CR</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">XR</span><span class="p">,</span> <span class="n">XR</span><span class="p">)</span>

    <span class="n">list_R</span><span class="p">,</span> <span class="n">list_p</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="n">part_ids</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">part_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_ids</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">part</span> <span class="o">==</span> <span class="n">part_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">structure_R</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">rep_indices</span><span class="p">[</span><span class="n">id_</span><span class="p">]][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">features_R</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="n">rep_indices</span><span class="p">[</span><span class="n">id_</span><span class="p">]][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">features_R</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">list_R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">structure_R</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">features_R</span><span class="p">)</span>
        <span class="n">list_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">F</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CR</span><span class="p">,</span> <span class="n">list_R</span><span class="p">,</span> <span class="n">list_p</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">FR</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">rep_indices</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">CR</span><span class="p">,</span> <span class="n">list_R</span><span class="p">,</span> <span class="n">list_p</span><span class="p">,</span> <span class="n">FR</span></div>



<div class="viewcode-block" id="quantized_fused_gromov_wasserstein_samples">
<a class="viewcode-back" href="../../../gen_modules/ot.gromov.html#ot.gromov.quantized_fused_gromov_wasserstein_samples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">quantized_fused_gromov_wasserstein_samples</span><span class="p">(</span>
    <span class="n">X1</span><span class="p">,</span>
    <span class="n">X2</span><span class="p">,</span>
    <span class="n">npart1</span><span class="p">,</span>
    <span class="n">npart2</span><span class="p">,</span>
    <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">F1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">F2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;kmeans&quot;</span><span class="p">,</span>
    <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">armijo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_iter</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span>
    <span class="n">tol_rel</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
    <span class="n">tol_abs</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the quantized Fused Gromov-Wasserstein transport between samples</span>
<span class="sd">    endowed with their respective euclidean geometry :math:`(\mathbf{D}(\mathbf{X_1}), \mathbf{F_1}, \mathbf{p})`</span>
<span class="sd">    and :math:`(\mathbf{D}(\mathbf{X_1}), \mathbf{F_2}, \mathbf{q})`, whose samples are assigned to partitions and</span>
<span class="sd">    representants :math:`\mathcal{P_1} = \{(\mathbf{P_{1, i}}, \mathbf{r_{1, i}})\}_{i \leq npart1}`</span>
<span class="sd">    and :math:`\mathcal{P_2} = \{(\mathbf{P_{2, j}}, \mathbf{r_{2, j}})\}_{j \leq npart2}`.</span>

<span class="sd">    The function estimates the following optimization problem:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{T}^* \in \mathop{\arg \min}_\mathbf{T} \quad \alpha \sum_{i,j,k,l}</span>
<span class="sd">        L(\mathbf{D}(\mathbf{X_1})_{i,k}, \mathbf{D}(\mathbf{X_2})_{j,l}) \mathbf{T}_{i,j} \mathbf{T}_{k,l}</span>
<span class="sd">        + (1-\alpha) \langle \mathbf{T}, \mathbf{D}(\mathbf{F_1}, \mathbf{F}_2) \rangle_F</span>
<span class="sd">        s.t. \ \mathbf{T} \mathbf{1} &amp;= \mathbf{p}</span>

<span class="sd">             \mathbf{T}^T \mathbf{1} &amp;= \mathbf{q}</span>

<span class="sd">             \mathbf{T} &amp;\geq 0</span>

<span class="sd">             \mathbf{T}_{|\mathbf{P_{1, i}}, \mathbf{P_{2, j}}} &amp;= T^{g}_{ij} \mathbf{T}^{(i,j)}</span>

<span class="sd">    using a two-step strategy computing: i) a global alignment :math:`\mathbf{T}^{g}`</span>
<span class="sd">    between representants across joint structure and feature spaces;</span>
<span class="sd">    ii) local alignments :math:`\mathbf{T}^{(i, j)}` between partitions</span>
<span class="sd">    :math:`\mathbf{P_{1, i}}` and :math:`\mathbf{P_{2, j}}` seen as 1D measures.</span>

<span class="sd">    Where :</span>

<span class="sd">    - :math:`\mathbf{X_1}`: Samples in the source space</span>
<span class="sd">    - :math:`\mathbf{X_2}`: Samples in the target space</span>
<span class="sd">    - :math:`\mathbf{F_1}`: Feature matrix in the source space</span>
<span class="sd">    - :math:`\mathbf{F_2}`: Feature matrix in the target space</span>
<span class="sd">    - :math:`\mathbf{D}(\mathbf{F_1}, \mathbf{F_2})`: Pairwise euclidean distance matrix between features</span>
<span class="sd">    - :math:`\mathbf{p}`: distribution in the source space</span>
<span class="sd">    - :math:`\mathbf{q}`: distribution in the target space</span>
<span class="sd">    - :math:`L`: quadratic loss function to account for the misfit between the similarity matrices</span>

<span class="sd">    .. note:: This function is backend-compatible and will work on arrays</span>
<span class="sd">        from all compatible backends. But the algorithm uses the C++ CPU backend</span>
<span class="sd">        which can lead to copy overhead on GPU arrays.</span>
<span class="sd">    .. note:: All computations in the conjugate gradient solver are done with</span>
<span class="sd">        numpy to limit memory overhead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X1 : array-like, shape (ns, ds)</span>
<span class="sd">        Samples in the source space.</span>
<span class="sd">    X2 : array-like, shape (nt, dt)</span>
<span class="sd">        Samples in the target space.</span>
<span class="sd">    npart1 : int,</span>
<span class="sd">        number of partition in the source space.</span>
<span class="sd">    npart2 : int,</span>
<span class="sd">        number of partition in the target space.</span>
<span class="sd">    p : array-like, shape (ns,), optional</span>
<span class="sd">        Distribution in the source space.</span>
<span class="sd">        If let to its default value None, uniform distribution is taken.</span>
<span class="sd">    q : array-like, shape (nt,), optional</span>
<span class="sd">        Distribution in the target space.</span>
<span class="sd">        If let to its default value None, uniform distribution is taken.</span>
<span class="sd">    F1 : array-like, shape (ns, d), optional. Default is None.</span>
<span class="sd">        Feature matrix in the source space.</span>
<span class="sd">    F2 : array-like, shape (nt, d), optional. Default is None.</span>
<span class="sd">        Feature matrix in the target space</span>
<span class="sd">    alpha: float, optional. Default is 1.</span>
<span class="sd">        FGW trade-off parameter in :math:`]0, 1]` between structure and features.</span>
<span class="sd">        If `alpha = 1` features are ignored hence computing qGW, if `alpha=0`</span>
<span class="sd">        structures are ignored and we compute the quantized Wasserstein transport.</span>
<span class="sd">    method : str, optional. Default is &#39;kmeans&#39;.</span>
<span class="sd">        Partitioning and representant selection algorithms to use among</span>
<span class="sd">        {&#39;random&#39;, &#39;kmeans&#39;, &#39;kmeans_fused&#39;}.</span>
<span class="sd">        If `part_method == &#39;kmeans_fused&#39;`, kmeans is performed on augmented</span>
<span class="sd">        samples :math:`[\alpha \mathbf{X}; (1 - \alpha) \mathbf{F}]`.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Print information along iterations</span>
<span class="sd">    log : bool, optional</span>
<span class="sd">        record log if True</span>
<span class="sd">    armijo : bool, optional</span>
<span class="sd">        If True the step of the line-search is found via an armijo research. Else closed form is used.</span>
<span class="sd">        If there are convergence issues use False.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Max number of iterations</span>
<span class="sd">    tol_rel : float, optional</span>
<span class="sd">        Stop threshold on relative error (&gt;0)</span>
<span class="sd">    tol_abs : float, optional</span>
<span class="sd">        Stop threshold on absolute error (&gt;0)</span>
<span class="sd">    random_state: int, optional</span>
<span class="sd">        Random seed for the partitioning algorithm</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        parameters can be directly passed to the ot.optim.cg solver</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T_global: array-like, shape (`npart1`, `npart2`)</span>
<span class="sd">        Fused Gromov-Wasserstein alignment :math:`\mathbf{T}^{g}` between representants.</span>
<span class="sd">    Ts_local: dict of local OT matrices.</span>
<span class="sd">        Dictionary with keys :math:`(i, j)` corresponding to 1D OT between</span>
<span class="sd">        :math:`\mathbf{P_{1, i}}` and :math:`\mathbf{P_{2, j}}` if :math:`T^{g}_{ij} \neq 0`.</span>
<span class="sd">    T: array-like, shape `(ns, nt)`</span>
<span class="sd">        Coupling between the two spaces.</span>
<span class="sd">    log : dict</span>
<span class="sd">        Convergence information for inner problems and qGW loss.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [68] Chowdhury, S., Miller, D., &amp; Needham, T. (2021).</span>
<span class="sd">        Quantized gromov-wasserstein. ECML PKDD 2021. Springer International Publishing.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;kmeans&quot;</span><span class="p">,</span> <span class="s2">&quot;kmeans_fused&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sklearn_import</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            Scikit-learn is not installed, so method=</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> cannot be used</span>
<span class="s2">            and is set to `random` default methods. Consider installing</span>
<span class="s2">            Scikit-learn to fix this.</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;fused&quot;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">F1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">F2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            `method=&#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39;` requires feature matrices which are not provided as inputs.</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_to_array</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">unif</span><span class="p">(</span><span class="n">X1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">type_as</span><span class="o">=</span><span class="n">X1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_to_array</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">unif</span><span class="p">(</span><span class="n">X2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">type_as</span><span class="o">=</span><span class="n">X1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">F1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">F2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>

    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span>

    <span class="c1"># compute attributed partitions and representants</span>
    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;fused&quot;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="n">X1_new</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">X1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">F1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">X2_new</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">X2</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">F2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">method_</span> <span class="o">=</span> <span class="n">method</span><span class="p">[:</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X1_new</span><span class="p">,</span> <span class="n">X2_new</span> <span class="o">=</span> <span class="n">X1</span><span class="p">,</span> <span class="n">X2</span>
        <span class="n">method_</span> <span class="o">=</span> <span class="n">method</span>
    <span class="n">part1</span><span class="p">,</span> <span class="n">rep_indices1</span> <span class="o">=</span> <span class="n">get_partition_and_representants_samples</span><span class="p">(</span>
        <span class="n">X1_new</span><span class="p">,</span> <span class="n">npart1</span><span class="p">,</span> <span class="n">method_</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span>
    <span class="p">)</span>
    <span class="n">part2</span><span class="p">,</span> <span class="n">rep_indices2</span> <span class="o">=</span> <span class="n">get_partition_and_representants_samples</span><span class="p">(</span>
        <span class="n">X2_new</span><span class="p">,</span> <span class="n">npart2</span><span class="p">,</span> <span class="n">method_</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">nx</span>
    <span class="p">)</span>
    <span class="c1"># format partitions over (C1, F1) and (C2, F2)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">F1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">F2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">CR1</span><span class="p">,</span> <span class="n">list_R1</span><span class="p">,</span> <span class="n">list_p1</span> <span class="o">=</span> <span class="n">format_partitioned_samples</span><span class="p">(</span>
            <span class="n">X1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">part1</span><span class="p">,</span> <span class="n">rep_indices1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span>
        <span class="p">)</span>
        <span class="n">CR2</span><span class="p">,</span> <span class="n">list_R2</span><span class="p">,</span> <span class="n">list_p2</span> <span class="o">=</span> <span class="n">format_partitioned_samples</span><span class="p">(</span>
            <span class="n">X2</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">part2</span><span class="p">,</span> <span class="n">rep_indices2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span>
        <span class="p">)</span>

        <span class="n">MR</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">CR1</span><span class="p">,</span> <span class="n">list_R1</span><span class="p">,</span> <span class="n">list_p1</span><span class="p">,</span> <span class="n">FR1</span> <span class="o">=</span> <span class="n">format_partitioned_samples</span><span class="p">(</span>
            <span class="n">X1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">part1</span><span class="p">,</span> <span class="n">rep_indices1</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>
        <span class="n">CR2</span><span class="p">,</span> <span class="n">list_R2</span><span class="p">,</span> <span class="n">list_p2</span><span class="p">,</span> <span class="n">FR2</span> <span class="o">=</span> <span class="n">format_partitioned_samples</span><span class="p">(</span>
            <span class="n">X2</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">part2</span><span class="p">,</span> <span class="n">rep_indices2</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nx</span>
        <span class="p">)</span>

        <span class="n">MR</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">FR1</span><span class="p">,</span> <span class="n">FR2</span><span class="p">)</span>

    <span class="c1"># call to partitioned quantized fused gromov-wasserstein solver</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">quantized_fused_gromov_wasserstein_partitioned</span><span class="p">(</span>
        <span class="n">CR1</span><span class="p">,</span>
        <span class="n">CR2</span><span class="p">,</span>
        <span class="n">list_R1</span><span class="p">,</span>
        <span class="n">list_R2</span><span class="p">,</span>
        <span class="n">list_p1</span><span class="p">,</span>
        <span class="n">list_p2</span><span class="p">,</span>
        <span class="n">MR</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">build_OT</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
        <span class="n">armijo</span><span class="o">=</span><span class="n">armijo</span><span class="p">,</span>
        <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
        <span class="n">tol_rel</span><span class="o">=</span><span class="n">tol_rel</span><span class="p">,</span>
        <span class="n">tol_abs</span><span class="o">=</span><span class="n">tol_abs</span><span class="p">,</span>
        <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">log_</span> <span class="o">=</span> <span class="n">res</span>

        <span class="n">C1</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>
        <span class="n">C2</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">X2</span><span class="p">)</span>

        <span class="c1"># compute the transport cost on structures</span>
        <span class="n">constC</span><span class="p">,</span> <span class="n">hC1</span><span class="p">,</span> <span class="n">hC2</span> <span class="o">=</span> <span class="n">init_matrix</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s2">&quot;square_loss&quot;</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
        <span class="n">structure_cost</span> <span class="o">=</span> <span class="n">gwloss</span><span class="p">(</span><span class="n">constC</span><span class="p">,</span> <span class="n">hC1</span><span class="p">,</span> <span class="n">hC2</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">)</span>
            <span class="n">feature_cost</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feature_cost</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">log_</span><span class="p">[</span><span class="s2">&quot;qFGW_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">structure_cost</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">feature_cost</span>
        <span class="k">return</span> <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">log_</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">T_global</span><span class="p">,</span> <span class="n">Ts_local</span><span class="p">,</span> <span class="n">T</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2025, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span> 0.9.6dev0
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>