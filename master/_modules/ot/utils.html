

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.utils &mdash; POT Python Optimal Transport 0.9.5dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=b2dc65b3"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick start guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../all.html">API and modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ot.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ot.utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Various useful functions</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Author: Remi Flamary &lt;remi.flamary@unice.fr&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: MIT License</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">.backend</span> <span class="kn">import</span> <span class="n">get_backend</span><span class="p">,</span> <span class="n">Backend</span><span class="p">,</span> <span class="n">NumpyBackend</span><span class="p">,</span> <span class="n">JaxBackend</span>

<span class="n">__time_tic_toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


<div class="viewcode-block" id="tic">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.tic">[docs]</a>
<span class="k">def</span> <span class="nf">tic</span><span class="p">():</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Python implementation of Matlab tic() function&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">__time_tic_toc</span>
    <span class="n">__time_tic_toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span></div>



<div class="viewcode-block" id="toc">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.toc">[docs]</a>
<span class="k">def</span> <span class="nf">toc</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;Elapsed time : </span><span class="si">{}</span><span class="s2"> s&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Python implementation of Matlab toc() function&quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">__time_tic_toc</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">t</span> <span class="o">-</span> <span class="n">__time_tic_toc</span></div>



<div class="viewcode-block" id="toq">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.toq">[docs]</a>
<span class="k">def</span> <span class="nf">toq</span><span class="p">():</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Python implementation of Julia toc() function&quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">t</span> <span class="o">-</span> <span class="n">__time_tic_toc</span></div>



<div class="viewcode-block" id="kernel">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.kernel">[docs]</a>
<span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute kernel matrix&quot;&quot;&quot;</span>

    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="s2">&quot;gauss&quot;</span><span class="p">,</span> <span class="s2">&quot;rbf&quot;</span><span class="p">]:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">K</span></div>



<div class="viewcode-block" id="laplacian">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.laplacian">[docs]</a>
<span class="k">def</span> <span class="nf">laplacian</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute Laplacian matrix&quot;&quot;&quot;</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">L</span></div>



<div class="viewcode-block" id="list_to_array">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.list_to_array">[docs]</a>
<span class="k">def</span> <span class="nf">list_to_array</span><span class="p">(</span><span class="o">*</span><span class="n">lst</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert a list if in numpy format&quot;&quot;&quot;</span>
    <span class="n">lst_not_empty</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># find backend</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst_not_empty</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">type_as</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">type_as</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="n">lst_not_empty</span><span class="p">)</span>
            <span class="n">type_as</span> <span class="o">=</span> <span class="n">lst_not_empty</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst_not_empty</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">type_as</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_as</span> <span class="o">=</span> <span class="n">lst_not_empty</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">type_as</span><span class="o">=</span><span class="n">type_as</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lst</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">type_as</span><span class="o">=</span><span class="n">type_as</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="proj_simplex">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.proj_simplex">[docs]</a>
<span class="k">def</span> <span class="nf">proj_simplex</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the closest point (orthogonal projection) on the</span>
<span class="sd">    generalized `(n-1)`-simplex of a vector :math:`\mathbf{v}` wrt. to the Euclidean</span>
<span class="sd">    distance, thus solving:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathcal{P}(w) \in \mathop{\arg \min}_\gamma \| \gamma - \mathbf{v} \|_2</span>

<span class="sd">        s.t. \ \gamma^T \mathbf{1} = z</span>

<span class="sd">             \gamma \geq 0</span>

<span class="sd">    If :math:`\mathbf{v}` is a 2d array, compute all the projections wrt. axis 0</span>

<span class="sd">    .. note:: This function is backend-compatible and will work on arrays</span>
<span class="sd">        from all compatible backends.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : {array-like}, shape (n, d)</span>
<span class="sd">    z : int, optional</span>
<span class="sd">        &#39;size&#39; of the simplex (each vectors sum to z, 1 by default)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    h : ndarray, shape (`n`, `d`)</span>
<span class="sd">        Array of projections on the simplex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># sort u in ascending order</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># take the descending order</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">cssv</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">v</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">cssv</span> <span class="o">/</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">cssv</span><span class="p">[</span><span class="n">rho</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span> <span class="o">/</span> <span class="n">rho</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">theta</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">nx</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">d1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">w</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">w</span></div>



<div class="viewcode-block" id="projection_sparse_simplex">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.projection_sparse_simplex">[docs]</a>
<span class="k">def</span> <span class="nf">projection_sparse_simplex</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">max_nz</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Projection of :math:`\mathbf{V}` onto the simplex with cardinality constraint (maximum number of non-zero elements) and then scaled by `z`.</span>

<span class="sd">    .. math::</span>
<span class="sd">        P\left(\mathbf{V}, max_nz, z\right) = \mathop{\arg \min}_{\substack{\mathbf{y} &gt;= 0 \\ \sum_i \mathbf{y}_i = z} \\ ||p||_0 \le \text{max_nz}} \quad \|\mathbf{y} - \mathbf{V}\|^2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    V: 1-dim or 2-dim ndarray</span>
<span class="sd">    z: float or array</span>
<span class="sd">        If array, len(z) must be compatible with :math:`\mathbf{V}`</span>
<span class="sd">    axis: None or int</span>
<span class="sd">        - axis=None: project :math:`\mathbf{V}` by :math:`P(\mathbf{V}.\mathrm{ravel}(), max_nz, z)`</span>
<span class="sd">        - axis=1: project each :math:`\mathbf{V}_i` by :math:`P(\mathbf{V}_i, max_nz, z_i)`</span>
<span class="sd">        - axis=0: project each :math:`\mathbf{V}_{:, j}` by :math:`P(\mathbf{V}_{:, j}, max_nz, z_j)`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    projection: ndarray, shape :math:`\mathbf{V}`.shape</span>

<span class="sd">    References:</span>
<span class="sd">        Sparse projections onto the simplex</span>
<span class="sd">        Anastasios Kyrillidis, Stephen Becker, Volkan Cevher and, Christoph Koch</span>
<span class="sd">        ICML 2013</span>
<span class="sd">        https://arxiv.org/abs/1206.1529</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">projection_sparse_simplex</span><span class="p">(</span>
            <span class="c1"># V[nx.newaxis, :], max_nz, z, axis=1).ravel()</span>
            <span class="n">V</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">max_nz</span><span class="p">,</span>
            <span class="n">z</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;V.ndim must be &lt;= 2&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># For each row of V, find top max_nz values; arrange the</span>
        <span class="c1"># corresponding column indices such that their values are</span>
        <span class="c1"># in a descending order.</span>
        <span class="n">max_nz_indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="o">-</span><span class="n">max_nz</span><span class="p">:]</span>
        <span class="n">max_nz_indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">max_nz_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">row_indices</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">row_indices</span> <span class="o">=</span> <span class="n">row_indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">row_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Extract the top max_nz values for each row</span>
        <span class="c1"># and then project to simplex.</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">max_nz_indices</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">))</span> <span class="o">*</span> <span class="n">z</span>
        <span class="n">cssv</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_nz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">U</span> <span class="o">-</span> <span class="n">cssv</span> <span class="o">/</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># rho = nx.count_nonzero(cond, axis=1)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">cssv</span><span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">)),</span> <span class="n">rho</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">rho</span>
        <span class="n">nz_projection</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">U</span> <span class="o">-</span> <span class="n">theta</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Put the projection of max_nz_values to their original column indices</span>
        <span class="c1"># while keeping other values zero.</span>
        <span class="n">sparse_projection</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">nz_projection</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">JaxBackend</span><span class="p">):</span>
            <span class="c1"># in Jax, we need to use the `at` property of `jax.numpy.ndarray`</span>
            <span class="c1"># to do in-place array modifications.</span>
            <span class="n">sparse_projection</span> <span class="o">=</span> <span class="n">sparse_projection</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">max_nz_indices</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">nz_projection</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sparse_projection</span><span class="p">[</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">max_nz_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">nz_projection</span>
        <span class="k">return</span> <span class="n">sparse_projection</span>

    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">projection_sparse_simplex</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">max_nz</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">projection_sparse_simplex</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">max_nz</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span></div>



<div class="viewcode-block" id="unif">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.unif">[docs]</a>
<span class="k">def</span> <span class="nf">unif</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a uniform histogram of length `n` (simplex).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        number of bins in the histogram</span>
<span class="sd">    type_as : array_like</span>
<span class="sd">        array of the same type of the expected output (numpy/pytorch/jax)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    h : array_like (`n`,)</span>
<span class="sd">        histogram of length `n` such that :math:`\forall i, \mathbf{h}_i = \frac{1}{n}`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">type_as</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span> <span class="o">/</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">type_as</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="n">type_as</span><span class="o">=</span><span class="n">type_as</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span></div>



<div class="viewcode-block" id="clean_zeros">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.clean_zeros">[docs]</a>
<span class="k">def</span> <span class="nf">clean_zeros</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Remove all components with zeros weights in :math:`\mathbf{a}` and :math:`\mathbf{b}`&quot;&quot;&quot;</span>
    <span class="n">M2</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># copy force c style matrix (froemd)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">M2</span></div>



<div class="viewcode-block" id="euclidean_distances">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.euclidean_distances">[docs]</a>
<span class="k">def</span> <span class="nf">euclidean_distances</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Considering the rows of :math:`\mathbf{X}` (and :math:`\mathbf{Y} = \mathbf{X}`) as vectors, compute the</span>
<span class="sd">    distance matrix between each pair of vectors.</span>

<span class="sd">    .. note:: This function is backend-compatible and will work on arrays</span>
<span class="sd">        from all compatible backends.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like, shape (n_samples_1, n_features)</span>
<span class="sd">    Y : array-like, shape (n_samples_2, n_features)</span>
<span class="sd">    squared : boolean, optional</span>
<span class="sd">        Return squared Euclidean distances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distances : array-like, shape (`n_samples_1`, `n_samples_2`)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

    <span class="n">a2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;i&quot;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;i&quot;</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nx</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">+=</span> <span class="n">a2</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">+=</span> <span class="n">b2</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">squared</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="n">Y</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nx</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">type_as</span><span class="o">=</span><span class="n">c</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">c</span></div>



<div class="viewcode-block" id="dist">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.dist">[docs]</a>
<span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;sqeuclidean&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute distance between samples in :math:`\mathbf{x_1}` and :math:`\mathbf{x_2}`</span>

<span class="sd">    .. note:: This function is backend-compatible and will work on arrays</span>
<span class="sd">        from all compatible backends.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    x1 : array-like, shape (n1,d)</span>
<span class="sd">        matrix with `n1` samples of size `d`</span>
<span class="sd">    x2 : array-like, shape (n2,d), optional</span>
<span class="sd">        matrix with `n2` samples of size `d` (if None then :math:`\mathbf{x_2} = \mathbf{x_1}`)</span>
<span class="sd">    metric : str | callable, optional</span>
<span class="sd">        &#39;sqeuclidean&#39; or &#39;euclidean&#39; on all backends. On numpy the function also</span>
<span class="sd">        accepts  from the scipy.spatial.distance.cdist function : &#39;braycurtis&#39;,</span>
<span class="sd">        &#39;canberra&#39;, &#39;chebyshev&#39;, &#39;cityblock&#39;, &#39;correlation&#39;, &#39;cosine&#39;, &#39;dice&#39;,</span>
<span class="sd">        &#39;euclidean&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;kulczynski1&#39;, &#39;mahalanobis&#39;,</span>
<span class="sd">        &#39;matching&#39;, &#39;minkowski&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;, &#39;seuclidean&#39;,</span>
<span class="sd">        &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;, &#39;wminkowski&#39;, &#39;yule&#39;.</span>
<span class="sd">    p : float, optional</span>
<span class="sd">        p-norm for the Minkowski and the Weighted Minkowski metrics. Default value is 2.</span>
<span class="sd">    w : array-like, rank 1</span>
<span class="sd">        Weights for the weighted metrics.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    M : array-like, shape (`n1`, `n2`)</span>
<span class="sd">        distance matrix computed with given metric</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;sqeuclidean&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;numpy&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">metric</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;minkowski&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cdist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cdist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cdist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span></div>



<div class="viewcode-block" id="dist0">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.dist0">[docs]</a>
<span class="k">def</span> <span class="nf">dist0</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;lin_square&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute standard cost matrices of size (`n`, `n`) for OT problems</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Size of the cost matrix.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Type of loss matrix chosen from:</span>

<span class="sd">        * &#39;lin_square&#39; : linear sampling between 0 and `n-1`, quadratic loss</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : ndarray, shape (`n1`, `n2`)</span>
<span class="sd">        Distance matrix computed with given metric.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;lin_square&quot;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="cost_normalization">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.cost_normalization">[docs]</a>
<span class="k">def</span> <span class="nf">cost_normalization</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply normalization to the loss matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : ndarray, shape (n1, n2)</span>
<span class="sd">        The cost matrix to normalize.</span>
<span class="sd">    norm : str</span>
<span class="sd">        Type of normalization from &#39;median&#39;, &#39;max&#39;, &#39;log&#39;, &#39;loglog&#39;. Any</span>
<span class="sd">        other value do not normalize.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : ndarray, shape (`n1`, `n2`)</span>
<span class="sd">        The input cost matrix normalized according to given norm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">/=</span> <span class="n">value</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;loglog&quot;</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nx</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">C</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Norm </span><span class="si">%s</span><span class="s2"> is not a valid option.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Valid options are:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;median, max, log, loglog&quot;</span> <span class="o">%</span> <span class="n">norm</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">C</span></div>



<div class="viewcode-block" id="dots">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.dots">[docs]</a>
<span class="k">def</span> <span class="nf">dots</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;dots function for multiple matrix multiply&quot;&quot;&quot;</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_all_finite">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.is_all_finite">[docs]</a>
<span class="k">def</span> <span class="nf">is_all_finite</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Tests element-wise for finiteness in all arguments.&quot;&quot;&quot;</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">nx</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="label_normalization">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.label_normalization">[docs]</a>
<span class="k">def</span> <span class="nf">label_normalization</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transform labels to start at a given value</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like, shape (n, )</span>
<span class="sd">        The vector of labels to be normalized.</span>
<span class="sd">    start : int</span>
<span class="sd">        Desired value for the smallest label in :math:`\mathbf{y}` (default=0)</span>
<span class="sd">    nx : Backend, optional</span>
<span class="sd">        Backend to perform computations on. If omitted, the backend defaults to that of `y`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : array-like, shape (`n1`, )</span>
<span class="sd">        The input vector of labels normalized according to given start value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">return</span> <span class="n">y</span> <span class="k">if</span> <span class="n">diff</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">diff</span><span class="p">)</span></div>



<div class="viewcode-block" id="labels_to_masks">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.labels_to_masks">[docs]</a>
<span class="k">def</span> <span class="nf">labels_to_masks</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transforms (n_samples,) vector of labels into a (n_samples, n_labels) matrix of masks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like, shape (n_samples, )</span>
<span class="sd">        The vector of labels.</span>
<span class="sd">    type_as : array_like</span>
<span class="sd">        Array of the same type of the expected output.</span>
<span class="sd">    nx : Backend, optional</span>
<span class="sd">        Backend to perform computations on. If omitted, the backend defaults to that of `y`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    masks : array-like, shape (n_samples, n_labels)</span>
<span class="sd">        The (n_samples, n_labels) matrix of label masks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">type_as</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">type_as</span> <span class="o">=</span> <span class="n">y</span>
    <span class="n">labels_u</span><span class="p">,</span> <span class="n">labels_idx</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">n_labels</span> <span class="o">=</span> <span class="n">labels_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_labels</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">type_as</span><span class="p">)[</span><span class="n">labels_idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">masks</span></div>



<div class="viewcode-block" id="parmap">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.parmap">[docs]</a>
<span class="k">def</span> <span class="nf">parmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;parallel map for multiprocessing.</span>
<span class="sd">    The function has been deprecated and only performs a regular map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span></div>



<div class="viewcode-block" id="check_params">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.check_params">[docs]</a>
<span class="k">def</span> <span class="nf">check_params</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;check_params: check whether some parameters are missing&quot;&quot;&quot;</span>

    <span class="n">missing_params</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">missing_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;POT - Warning: following necessary parameters are missing&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">missing_params</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">check</span></div>



<div class="viewcode-block" id="check_random_state">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.check_random_state">[docs]</a>
<span class="k">def</span> <span class="nf">check_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Turn `seed` into a np.random.RandomState instance</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seed : None | int | instance of RandomState</span>
<span class="sd">        If `seed` is None, return the RandomState singleton used by np.random.</span>
<span class="sd">        If `seed` is an int, return a new RandomState instance seeded with `seed`.</span>
<span class="sd">        If `seed` is already a RandomState instance, return it.</span>
<span class="sd">        Otherwise raise ValueError.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">seed</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">mtrand</span><span class="o">.</span><span class="n">_rand</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">seed</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> cannot be used to seed a numpy.random.RandomState&quot;</span> <span class="s2">&quot; instance&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="get_coordinate_circle">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.get_coordinate_circle">[docs]</a>
<span class="k">def</span> <span class="nf">get_coordinate_circle</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;For :math:`x\in S^1 \subset \mathbb{R}^2`, returns the coordinates in</span>
<span class="sd">    turn (in [0,1[).</span>

<span class="sd">    .. math::</span>
<span class="sd">        u = \frac{\pi + \mathrm{atan2}(-x_2,-x_1)}{2\pi}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: ndarray, shape (n, 2)</span>
<span class="sd">        Samples on the circle with ambient coordinates</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_t: ndarray, shape (n,)</span>
<span class="sd">        Coordinates on [0,1[</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; u = np.array([[0.2,0.5,0.8]]) * (2 * np.pi)</span>
<span class="sd">    &gt;&gt;&gt; x1, y1 = np.cos(u), np.sin(u)</span>
<span class="sd">    &gt;&gt;&gt; x = np.concatenate([x1, y1]).T</span>
<span class="sd">    &gt;&gt;&gt; get_coordinate_circle(x)</span>
<span class="sd">    array([0.2, 0.5, 0.8])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_t</span></div>



<div class="viewcode-block" id="reduce_lazytensor">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.reduce_lazytensor">[docs]</a>
<span class="k">def</span> <span class="nf">reduce_lazytensor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reduce a LazyTensor along an axis with function fun using batches.</span>

<span class="sd">    When axis=None, reduce the LazyTensor to a scalar as a sum of fun over</span>
<span class="sd">    batches taken along dim.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This function works for tensor of any order but the reduction can be done</span>
<span class="sd">        only along the first two axis (or global). Also, in order to work, it requires that the slice of size `batch_size` along the axis to reduce (or axis 0 if `axis=None`) is can be computed and fits in memory.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : LazyTensor</span>
<span class="sd">        LazyTensor to reduce</span>
<span class="sd">    func : callable</span>
<span class="sd">        Function to apply to the LazyTensor</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to reduce the LazyTensor. If None, reduce the</span>
<span class="sd">        LazyTensor to a scalar as a sum of fun over batches taken along axis 0.</span>
<span class="sd">        If 0 or 1 reduce the LazyTensor to a vector/matrix as a sum of fun over</span>
<span class="sd">        batches taken along axis.</span>
<span class="sd">    nx : Backend, optional</span>
<span class="sd">        Backend to use for the reduction</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Size of the batches to use for the reduction (default=100)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : array-like</span>
<span class="sd">        Result of the reduction</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">batch_size</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">type_as</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;jax&quot;</span><span class="p">,</span> <span class="s2">&quot;tf&quot;</span><span class="p">]:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">res</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;jax&quot;</span><span class="p">,</span> <span class="s2">&quot;tf&quot;</span><span class="p">]:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">res</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only axis=None, 0 or 1 is implemented for now.&quot;</span><span class="p">))</span></div>



<div class="viewcode-block" id="get_lowrank_lazytensor">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.get_lowrank_lazytensor">[docs]</a>
<span class="k">def</span> <span class="nf">get_lowrank_lazytensor</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a low rank LazyTensor T=Q@R^T or T=Q@diag(d)@R^T</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Q : ndarray, shape (n, r)</span>
<span class="sd">        First factor of the lowrank tensor</span>
<span class="sd">    R : ndarray, shape (m, r)</span>
<span class="sd">        Second factor of the lowrank tensor</span>
<span class="sd">    d : ndarray, shape (r,), optional</span>
<span class="sd">        Diagonal of the lowrank tensor</span>
<span class="sd">    nx : Backend, optional</span>
<span class="sd">        Backend to use for the reduction</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T : LazyTensor</span>
<span class="sd">        Lowrank tensor T=Q@R^T or T=Q@diag(d)@R^T</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">LazyTensor</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">LazyTensor</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">T</span></div>



<div class="viewcode-block" id="get_parameter_pair">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.get_parameter_pair">[docs]</a>
<span class="k">def</span> <span class="nf">get_parameter_pair</span><span class="p">(</span><span class="n">parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Extract a pair of parameters from a given parameter</span>
<span class="sd">    Used in unbalanced OT and COOT solvers</span>
<span class="sd">    to handle marginal regularization and entropic regularization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parameter : float or indexable object</span>
<span class="sd">    nx : backend object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    param_1 : float</span>
<span class="sd">    param_2 : float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">param_1</span><span class="p">,</span> <span class="n">param_2</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">parameter</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">param_1</span><span class="p">,</span> <span class="n">param_2</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Parameter must be either a scalar, </span><span class="se">\</span>
<span class="s2">                             or an indexable object of length 1 or 2.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_1</span><span class="p">,</span> <span class="n">param_2</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">param_1</span><span class="p">,</span> <span class="n">param_2</span></div>



<div class="viewcode-block" id="deprecated">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.deprecated">[docs]</a>
<span class="k">class</span> <span class="nc">deprecated</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Decorator to mark a function or class as deprecated.</span>

<span class="sd">    deprecated class from scikit-learn package</span>
<span class="sd">    https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/utils/deprecation.py</span>
<span class="sd">    Issue a warning when the function is called/the class is instantiated and</span>
<span class="sd">    adds a warning to the docstring.</span>
<span class="sd">    The optional extra argument will be appended to the deprecation message</span>
<span class="sd">    and the docstring.</span>

<span class="sd">    .. note::</span>
<span class="sd">        To use this with the default value for extra, use empty parentheses:</span>

<span class="sd">        &gt;&gt;&gt; from ot.deprecation import deprecated  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; @deprecated()  # doctest: +SKIP</span>
<span class="sd">        ... def some_function(): pass  # doctest: +SKIP</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    extra : str</span>
<span class="sd">        To be added to the deprecation messages.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Adapted from http://wiki.python.org/moin/PythonDecoratorLibrary,</span>
    <span class="c1"># but with many changes.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra</span> <span class="o">=</span> <span class="n">extra</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Call method</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorate_class</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorate_fun</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_decorate_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Class </span><span class="si">%s</span><span class="s2"> is deprecated&quot;</span> <span class="o">%</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span>

        <span class="c1"># FIXME: we should probably reset __new__ for full generality</span>
        <span class="n">init</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span>

        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">init</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">wrapped</span>

        <span class="n">wrapped</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;__init__&quot;</span>
        <span class="n">wrapped</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_doc</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="n">wrapped</span><span class="o">.</span><span class="n">deprecated_original</span> <span class="o">=</span> <span class="n">init</span>

        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">def</span> <span class="nf">_decorate_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Decorate function fun&quot;&quot;&quot;</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Function </span><span class="si">%s</span><span class="s2"> is deprecated&quot;</span> <span class="o">%</span> <span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span>

        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">wrapped</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">wrapped</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">wrapped</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_doc</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="nf">_update_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">olddoc</span><span class="p">):</span>
        <span class="n">newdoc</span> <span class="o">=</span> <span class="s2">&quot;DEPRECATED&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">:</span>
            <span class="n">newdoc</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">newdoc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">olddoc</span><span class="p">:</span>
            <span class="n">newdoc</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">newdoc</span><span class="p">,</span> <span class="n">olddoc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newdoc</span></div>



<span class="k">def</span> <span class="nf">_is_deprecated</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Helper to check if func is wrapped by our deprecated decorator&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This is only available for python3.5 &quot;</span> <span class="s2">&quot;or above&quot;</span><span class="p">)</span>
    <span class="n">closures</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__closure__&quot;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">if</span> <span class="n">closures</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">closures</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">is_deprecated</span> <span class="o">=</span> <span class="s2">&quot;deprecated&quot;</span> <span class="ow">in</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">cell_contents</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">closures</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">cell_contents</span><span class="p">,</span> <span class="nb">str</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">is_deprecated</span>


<div class="viewcode-block" id="BaseEstimator">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.BaseEstimator">[docs]</a>
<span class="k">class</span> <span class="nc">BaseEstimator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class for most objects in POT</span>

<span class="sd">    Code adapted from sklearn BaseEstimator class</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All estimators should specify all the parameters that can be set</span>
<span class="sd">    at the class level in their ``__init__`` as explicit keyword</span>
<span class="sd">    arguments (no ``*args`` or ``**kwargs``).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nx</span><span class="p">:</span> <span class="n">Backend</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_backend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">input_</span> <span class="k">for</span> <span class="n">input_</span> <span class="ow">in</span> <span class="n">arrays</span> <span class="k">if</span> <span class="n">input_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;tf&quot;</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Domain adaptation does not support TF backend.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="k">return</span> <span class="n">nx</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_param_names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get parameter names for the estimator&quot;&quot;&quot;</span>

        <span class="c1"># fetch the constructor or the original constructor before</span>
        <span class="c1"># deprecation wrapping if any</span>
        <span class="n">init</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="s2">&quot;deprecated_original&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__init__</span><span class="p">:</span>
            <span class="c1"># No explicit constructor to introspect</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># introspect the constructor arguments to find the model parameters</span>
        <span class="c1"># to represent</span>
        <span class="n">init_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
        <span class="c1"># Consider the constructor parameters excluding &#39;self&#39;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">p</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">init_signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;self&quot;</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;POT estimators should always &quot;</span>
                    <span class="s2">&quot;specify their parameters in the signature&quot;</span>
                    <span class="s2">&quot; of their __init__ (no varargs).&quot;</span>
                    <span class="s2">&quot; </span><span class="si">%s</span><span class="s2"> with constructor </span><span class="si">%s</span><span class="s2"> doesn&#39;t &quot;</span>
                    <span class="s2">&quot; follow this convention.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">init_signature</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="c1"># Extract and sort argument names excluding &#39;self&#39;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">])</span>

<div class="viewcode-block" id="BaseEstimator.get_params">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.BaseEstimator.get_params">[docs]</a>
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get parameters for this estimator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, optional</span>
<span class="sd">            If True, will return the parameters for this estimator and</span>
<span class="sd">            contained subobjects that are estimators.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : mapping of string to any</span>
<span class="sd">            Parameter names mapped to their values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">():</span>
            <span class="c1"># We need deprecation warnings to always be on in order to</span>
            <span class="c1"># catch deprecated param values.</span>
            <span class="c1"># This is set in utils/__init__.py but it gets overwritten</span>
            <span class="c1"># when running under python3 somehow.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">):</span>
                    <span class="c1"># if the parameter is deprecated, don&#39;t show it</span>
                    <span class="k">continue</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># XXX: should we rather test if instance of estimator?</span>
            <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;get_params&quot;</span><span class="p">):</span>
                <span class="n">deep_items</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">deep_items</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="BaseEstimator.set_params">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.BaseEstimator.set_params">[docs]</a>
    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set the parameters of this estimator.</span>

<span class="sd">        The method works on simple estimators as well as on nested objects</span>
<span class="sd">        (such as pipelines). The latter have parameters of the form</span>
<span class="sd">        ``&lt;component&gt;__&lt;parameter&gt;`` so that it&#39;s possible to update each</span>
<span class="sd">        component of a nested object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="c1"># Simple optimisation to gain speed (inspect is slow)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># for key, value in iteritems(params):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># nested objects case</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">sub_name</span> <span class="o">=</span> <span class="n">split</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid parameter </span><span class="si">%s</span><span class="s2"> for estimator </span><span class="si">%s</span><span class="s2">. &quot;</span>
                        <span class="s2">&quot;Check the list of available parameters &quot;</span>
                        <span class="s2">&quot;with `estimator.get_params().keys()`.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">sub_object</span> <span class="o">=</span> <span class="n">valid_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">sub_object</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">sub_name</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># simple objects case</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid parameter </span><span class="si">%s</span><span class="s2"> for estimator </span><span class="si">%s</span><span class="s2">. &quot;</span>
                        <span class="s2">&quot;Check the list of available parameters &quot;</span>
                        <span class="s2">&quot;with `estimator.get_params().keys()`.&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="UndefinedParameter">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.UndefinedParameter">[docs]</a>
<span class="k">class</span> <span class="nc">UndefinedParameter</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aim at raising an Exception when a undefined parameter is called</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>



<div class="viewcode-block" id="OTResult">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.OTResult">[docs]</a>
<span class="k">class</span> <span class="nc">OTResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for OT results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    potentials : tuple of array-like, shape (`n1`, `n2`)</span>
<span class="sd">        Dual potentials, i.e. Lagrange multipliers for the marginal constraints.</span>
<span class="sd">        This pair of arrays has the same shape, numerical type</span>
<span class="sd">        and properties as the input weights &quot;a&quot; and &quot;b&quot;.</span>
<span class="sd">    value : float, array-like</span>
<span class="sd">        Full transport cost, including possible regularization terms and</span>
<span class="sd">        quadratic term for Gromov Wasserstein solutions.</span>
<span class="sd">    value_linear : float, array-like</span>
<span class="sd">        The linear part of the transport cost, i.e. the product between the</span>
<span class="sd">        transport plan and the cost.</span>
<span class="sd">    value_quad : float, array-like</span>
<span class="sd">        The quadratic part of the transport cost for Gromov-Wasserstein</span>
<span class="sd">        solutions.</span>
<span class="sd">    plan : array-like, shape (`n1`, `n2`)</span>
<span class="sd">        Transport plan, encoded as a dense array.</span>
<span class="sd">    log : dict</span>
<span class="sd">        Dictionary containing potential information about the solver.</span>
<span class="sd">    backend : Backend</span>
<span class="sd">        Backend used to compute the results.</span>
<span class="sd">    sparse_plan : array-like, shape (`n1`, `n2`)</span>
<span class="sd">        Transport plan, encoded as a sparse array.</span>
<span class="sd">    lazy_plan : LazyTensor</span>
<span class="sd">        Transport plan, encoded as a symbolic POT or KeOps LazyTensor.</span>
<span class="sd">    status : int or str</span>
<span class="sd">        Status of the solver.</span>
<span class="sd">    batch_size : int</span>
<span class="sd">        Batch size used to compute the results/marginals for LazyTensor.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    potentials : tuple of array-like, shape (`n1`, `n2`)</span>
<span class="sd">        Dual potentials, i.e. Lagrange multipliers for the marginal constraints.</span>
<span class="sd">        This pair of arrays has the same shape, numerical type</span>
<span class="sd">        and properties as the input weights &quot;a&quot; and &quot;b&quot;.</span>
<span class="sd">    potential_a : array-like, shape (`n1`,)</span>
<span class="sd">        First dual potential, associated to the &quot;source&quot; measure &quot;a&quot;.</span>
<span class="sd">    potential_b : array-like, shape (`n2`,)</span>
<span class="sd">        Second dual potential, associated to the &quot;target&quot; measure &quot;b&quot;.</span>
<span class="sd">    value : float, array-like</span>
<span class="sd">        Full transport cost, including possible regularization terms and</span>
<span class="sd">        quadratic term for Gromov Wasserstein solutions.</span>
<span class="sd">    value_linear : float, array-like</span>
<span class="sd">        The linear part of the transport cost, i.e. the product between the</span>
<span class="sd">        transport plan and the cost.</span>
<span class="sd">    value_quad : float, array-like</span>
<span class="sd">        The quadratic part of the transport cost for Gromov-Wasserstein</span>
<span class="sd">        solutions.</span>
<span class="sd">    plan : array-like, shape (`n1`, `n2`)</span>
<span class="sd">        Transport plan, encoded as a dense array.</span>
<span class="sd">    sparse_plan : array-like, shape (`n1`, `n2`)</span>
<span class="sd">        Transport plan, encoded as a sparse array.</span>
<span class="sd">    lazy_plan : LazyTensor</span>
<span class="sd">        Transport plan, encoded as a symbolic POT or KeOps LazyTensor.</span>
<span class="sd">    marginals : tuple of array-like, shape (`n1`,), (`n2`,)</span>
<span class="sd">        Marginals of the transport plan: should be very close to &quot;a&quot; and &quot;b&quot;</span>
<span class="sd">        for balanced OT.</span>
<span class="sd">    marginal_a : array-like, shape (`n1`,)</span>
<span class="sd">        Marginal of the transport plan for the &quot;source&quot; measure &quot;a&quot;.</span>
<span class="sd">    marginal_b : array-like, shape (`n2`,)</span>
<span class="sd">        Marginal of the transport plan for the &quot;target&quot; measure &quot;b&quot;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">potentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_linear</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_quad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">log</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sparse_plan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lazy_plan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">status</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_potentials</span> <span class="o">=</span> <span class="n">potentials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_linear</span> <span class="o">=</span> <span class="n">value_linear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_quad</span> <span class="o">=</span> <span class="n">value_quad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span> <span class="o">=</span> <span class="n">plan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span> <span class="o">=</span> <span class="n">log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_plan</span> <span class="o">=</span> <span class="n">sparse_plan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span> <span class="o">=</span> <span class="n">lazy_plan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="n">backend</span> <span class="k">if</span> <span class="n">backend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">NumpyBackend</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="n">status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>

        <span class="c1"># I assume that other solvers may return directly</span>
        <span class="c1"># some primal objects?</span>
        <span class="c1"># In the code below, let&#39;s define the main quantities</span>
        <span class="c1"># that may be of interest to users.</span>
        <span class="c1"># An OT solver returns an object that inherits from OTResult</span>
        <span class="c1"># (e.g. SinkhornOTResult) and implements the relevant</span>
        <span class="c1"># methods (e.g. &quot;plan&quot; and &quot;lazy_plan&quot; but not &quot;sparse_plan&quot;, etc.).</span>
        <span class="c1"># log is a dictionary containing potential information about the solver</span>

    <span class="c1"># Dual potentials --------------------------------------------</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;OTResult(&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;value=</span><span class="si">{}</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_linear</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;value_linear=</span><span class="si">{}</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_linear</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;plan=</span><span class="si">{}</span><span class="s2">(shape=</span><span class="si">{}</span><span class="s2">),&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;lazy_plan=</span><span class="si">{}</span><span class="s2">(shape=</span><span class="si">{}</span><span class="s2">),&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">potentials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dual potentials, i.e. Lagrange multipliers for the marginal constraints.</span>

<span class="sd">        This pair of arrays has the same shape, numerical type</span>
<span class="sd">        and properties as the input weights &quot;a&quot; and &quot;b&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potentials</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">potential_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First dual potential, associated to the &quot;source&quot; measure &quot;a&quot;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potentials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potentials</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">potential_b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second dual potential, associated to the &quot;target&quot; measure &quot;b&quot;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potentials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potentials</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Transport plan -------------------------------------------</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transport plan, encoded as a dense array.&quot;&quot;&quot;</span>
        <span class="c1"># N.B.: We may catch out-of-memory errors and suggest</span>
        <span class="c1"># the use of lazy_plan or sparse_plan when appropriate.</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sparse_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transport plan, encoded as a sparse array.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_plan</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lazy_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transport plan, encoded as a symbolic KeOps LazyTensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span>

    <span class="c1"># Loss values --------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Full transport cost, including possible regularization terms and</span>
<span class="sd">        quadratic term for Gromov Wasserstein solutions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The &quot;minimal&quot; transport cost, i.e. the product between the transport plan and the cost.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_linear</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value_quad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The quadratic part of the transport cost for Gromov-Wasserstein solutions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_quad</span>

    <span class="c1"># Marginal constraints -------------------------</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">marginals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Marginals of the transport plan: should be very close to &quot;a&quot; and &quot;b&quot;</span>
<span class="sd">        for balanced OT.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginal_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginal_b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">marginal_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First marginal of the transport plan, with the same shape as &quot;a&quot;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span>
            <span class="n">bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span>
            <span class="k">return</span> <span class="n">reduce_lazytensor</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">bs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">marginal_b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second marginal of the transport plan, with the same shape as &quot;b&quot;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_plan</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_plan</span>
            <span class="n">bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span>
            <span class="k">return</span> <span class="n">reduce_lazytensor</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">bs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Optimization status of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary containing potential information about the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log</span>

    <span class="c1"># Barycentric mappings -------------------------</span>
    <span class="c1"># Return the displacement vectors as an array</span>
    <span class="c1"># that has the same shape as &quot;xa&quot;/&quot;xb&quot; (for samples)</span>
    <span class="c1"># or &quot;a&quot;/&quot;b&quot; * D (for images)?</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a_to_b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Displacement vectors from the first to the second measure.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">b_to_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Displacement vectors from the second to the first measure.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="c1"># # Wasserstein barycenters ----------------------</span>
    <span class="c1"># @property</span>
    <span class="c1"># def masses(self):</span>
    <span class="c1">#     &quot;&quot;&quot;Masses for the Wasserstein barycenter.&quot;&quot;&quot;</span>
    <span class="c1">#     raise NotImplementedError()</span>

    <span class="c1"># @property</span>
    <span class="c1"># def samples(self):</span>
    <span class="c1">#     &quot;&quot;&quot;Sample locations for the Wasserstein barycenter.&quot;&quot;&quot;</span>
    <span class="c1">#     raise NotImplementedError()</span>

    <span class="c1"># Miscellaneous --------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">citation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Appropriate citation(s) for this result, in plain text and BibTex formats.&quot;&quot;&quot;</span>

        <span class="c1"># The string below refers to the POT library:</span>
        <span class="c1"># successor methods may concatenate the relevant references</span>
        <span class="c1"># to the original definitions, solvers and underlying numerical backends.</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;POT library:</span>

<span class="s2">            POT Python Optimal Transport library, Journal of Machine Learning Research, 22(78):1−8, 2021.</span>
<span class="s2">            Website: https://pythonot.github.io/</span>
<span class="s2">            Rémi Flamary, Nicolas Courty, Alexandre Gramfort, Mokhtar Z. Alaya, Aurélie Boisbunon, Stanislas Chambon, Laetitia Chapel, Adrien Corenflos, Kilian Fatras, Nemo Fournier, Léo Gautheron, Nathalie T.H. Gayraud, Hicham Janati, Alain Rakotomamonjy, Ievgen Redko, Antoine Rolet, Antony Schutz, Vivien Seguy, Danica J. Sutherland, Romain Tavenard, Alexander Tong, Titouan Vayer;</span>

<span class="s2">            @article{flamary2021pot,</span>
<span class="s2">              author  = {R{</span><span class="se">\&#39;</span><span class="s2">e}mi Flamary and Nicolas Courty and Alexandre Gramfort and Mokhtar Z. Alaya and Aur{</span><span class="se">\&#39;</span><span class="s2">e}lie Boisbunon and Stanislas Chambon and Laetitia Chapel and Adrien Corenflos and Kilian Fatras and Nemo Fournier and L{</span><span class="se">\&#39;</span><span class="s2">e}o Gautheron and Nathalie T.H. Gayraud and Hicham Janati and Alain Rakotomamonjy and Ievgen Redko and Antoine Rolet and Antony Schutz and Vivien Seguy and Danica J. Sutherland and Romain Tavenard and Alexander Tong and Titouan Vayer},</span>
<span class="s2">              title   = {{POT}: </span><span class="si">{Python}</span><span class="s2"> </span><span class="si">{Optimal}</span><span class="s2"> </span><span class="si">{Transport}</span><span class="s2">},</span>
<span class="s2">              journal = {Journal of Machine Learning Research},</span>
<span class="s2">              year    = </span><span class="si">{2021}</span><span class="s2">,</span>
<span class="s2">              volume  = </span><span class="si">{22}</span><span class="s2">,</span>
<span class="s2">              number  = </span><span class="si">{78}</span><span class="s2">,</span>
<span class="s2">              pages   = {1-8},</span>
<span class="s2">              url     = {http://jmlr.org/papers/v22/20-451.html}</span>
<span class="s2">            }</span>
<span class="s2">        &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="LazyTensor">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.LazyTensor">[docs]</a>
<span class="k">class</span> <span class="nc">LazyTensor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A lazy tensor is a tensor that is not stored in memory. Instead, it is</span>
<span class="sd">    defined by a function that computes its values on the fly from slices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    shape : tuple</span>
<span class="sd">        shape of the tensor</span>
<span class="sd">    getitem : callable</span>
<span class="sd">        function that computes the values of the indices/slices and tensors</span>
<span class="sd">        as arguments</span>

<span class="sd">    kwargs : dict</span>
<span class="sd">        named arguments for the function, those names will be used as attributed</span>
<span class="sd">        of the LazyTensor object</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; def getitem(i,j, v):</span>
<span class="sd">    ...     return v[i,None]+v[None,j]</span>
<span class="sd">    &gt;&gt;&gt; T = LazyTensor((5,5),getitem, v=v)</span>
<span class="sd">    &gt;&gt;&gt; T[1,2]</span>
<span class="sd">    array([3])</span>
<span class="sd">    &gt;&gt;&gt; T[1,:]</span>
<span class="sd">    array([[1, 2, 3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; T[:]</span>
<span class="sd">    array([[0, 1, 2, 3, 4],</span>
<span class="sd">           [1, 2, 3, 4, 5],</span>
<span class="sd">           [2, 3, 4, 5, 6],</span>
<span class="sd">           [3, 4, 5, 6, 7],</span>
<span class="sd">           [4, 5, 6, 7, 8]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">getitem</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span> <span class="o">=</span> <span class="n">getitem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># set attributes for named arguments/arrays</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)):</span>
                <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Only integer, slice, and tuple indexing is supported&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;LazyTensor(shape=</span><span class="si">{}</span><span class="s2">,attributes=(</span><span class="si">{}</span><span class="s2">))&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="proj_SDP">
<a class="viewcode-back" href="../../gen_modules/ot.utils.html#ot.proj_SDP">[docs]</a>
<span class="k">def</span> <span class="nf">proj_SDP</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Project a symmetric matrix onto the space of symmetric matrices with</span>
<span class="sd">    eigenvalues larger or equal to `vmin`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : array_like (n, d, d) or (d, d)</span>
<span class="sd">        The input symmetric matrix or matrices.</span>
<span class="sd">    nx : module, optional</span>
<span class="sd">        The numerical backend module to use. If not provided, the backend will</span>
<span class="sd">        be fetched from the input matrix `S`.</span>
<span class="sd">    vmin : float, optional</span>
<span class="sd">        The minimum value for the eigenvalues. Eigenvalues below this value will</span>
<span class="sd">        be clipped to vmin.</span>

<span class="sd">    .. note:: This function is backend-compatible and will work on arrays</span>
<span class="sd">        from all compatible backends.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : ndarray (n, d, d) or (d, d)</span>
<span class="sd">        The projected symmetric positive definite matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="n">w</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># input was (d, d)</span>
        <span class="k">return</span> <span class="n">P</span> <span class="o">@</span> <span class="n">nx</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">@</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># input was (n, d, d): broadcasting</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ijk,ik-&gt;ijk&quot;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>  <span class="c1"># Q[i] = P[i] @ diag(w[i])</span>
        <span class="c1"># R[i] = Q[i] @ P[i].T</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ijk,ikl-&gt;ijl&quot;</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2023, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span>
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>