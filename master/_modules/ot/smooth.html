<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ot.smooth &mdash; POT Python Optimal Transport 0.9.3dev documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=8099e02f"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            POT Python Optimal Transport
              <img src="../../_static/logo_dark.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9.3dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">POT: Python Optimal Transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick start guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../all.html">API and modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html">Examples gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing to POT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_of_conduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">POT Python Optimal Transport</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ot.smooth</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ot.smooth</h1><div class="highlight"><pre>
<span></span><span class="c1">#Copyright (c) 2018, Mathieu Blondel</span>
<span class="c1">#All rights reserved.</span>
<span class="c1">#</span>
<span class="c1">#Redistribution and use in source and binary forms, with or without</span>
<span class="c1">#modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1">#1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#this list of conditions and the following disclaimer in the documentation and/or</span>
<span class="c1">#other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1">#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="c1">#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="c1">#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<span class="c1">#IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,</span>
<span class="c1">#INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<span class="c1">#NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,</span>
<span class="c1">#OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="c1">#LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR</span>
<span class="c1">#OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span>
<span class="c1">#THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="c1"># Author: Mathieu Blondel</span>
<span class="c1">#         Remi Flamary &lt;remi.flamary@unice.fr&gt;</span>
<span class="c1">#         Tianlin Liu &lt;t.liu@unibas.ch&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Smooth and Sparse (KL an L2 reg.) and sparsity-constrained OT solvers.</span>

<span class="sd">Implementation of :</span>
<span class="sd">Smooth and Sparse Optimal Transport.</span>
<span class="sd">Mathieu Blondel, Vivien Seguy, Antoine Rolet.</span>
<span class="sd">In Proc. of AISTATS 2018.</span>
<span class="sd">https://arxiv.org/abs/1710.06276</span>

<span class="sd">(Original code from https://github.com/mblondel/smooth-ot/)</span>

<span class="sd">Sparsity-Constrained Optimal Transport.</span>
<span class="sd">Liu, T., Puigcerver, J., &amp; Blondel, M. (2023).</span>
<span class="sd">Sparsity-constrained optimal transport.</span>
<span class="sd">Proceedings of the Eleventh International Conference on</span>
<span class="sd">Learning Representations (ICLR).</span>
<span class="sd">https://arxiv.org/abs/2209.15466</span>


<span class="sd">[17] Blondel, M., Seguy, V., &amp; Rolet, A. (2018). Smooth and Sparse Optimal</span>
<span class="sd">Transport. Proceedings of the Twenty-First International Conference on</span>
<span class="sd">Artificial Intelligence and Statistics (AISTATS).</span>

<span class="sd">[50] Liu, T., Puigcerver, J., &amp; Blondel, M. (2023).</span>
<span class="sd">Sparsity-constrained optimal transport.</span>
<span class="sd">Proceedings of the Eleventh International Conference on</span>
<span class="sd">Learning Representations (ICLR).</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">.backend</span> <span class="kn">import</span> <span class="n">get_backend</span>
<span class="kn">import</span> <span class="nn">ot</span>


<div class="viewcode-block" id="projection_simplex">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.projection_simplex">[docs]</a>
<span class="k">def</span> <span class="nf">projection_simplex</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Projection of :math:`\mathbf{V}` onto the simplex, scaled by `z`</span>

<span class="sd">    .. math::</span>
<span class="sd">        P\left(\mathbf{V}, z\right) = \mathop{\arg \min}_{\substack{\mathbf{y} &gt;= 0 \\ \sum_i \mathbf{y}_i = z}} \quad \|\mathbf{y} - \mathbf{V}\|^2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    V: ndarray, rank 2</span>
<span class="sd">    z: float or array</span>
<span class="sd">        If array, len(z) must be compatible with :math:`\mathbf{V}`</span>
<span class="sd">    axis: None or int</span>
<span class="sd">        - axis=None: project :math:`\mathbf{V}` by :math:`P(\mathbf{V}.\mathrm{ravel}(), z)`</span>
<span class="sd">        - axis=1: project each :math:`\mathbf{V}_i` by :math:`P(\mathbf{V}_i, z_i)`</span>
<span class="sd">        - axis=0: project each :math:`\mathbf{V}_{:, j}` by :math:`P(\mathbf{V}_{:, j}, z_j)`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    projection: ndarray, shape :math:`\mathbf{V}`.shape</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">))</span> <span class="o">*</span> <span class="n">z</span>
        <span class="n">cssv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_features</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">U</span> <span class="o">-</span> <span class="n">cssv</span> <span class="o">/</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">cssv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)),</span> <span class="n">rho</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">rho</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">V</span> <span class="o">-</span> <span class="n">theta</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">projection_simplex</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">projection_simplex</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span></div>



<div class="viewcode-block" id="Regularization">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.Regularization">[docs]</a>
<span class="k">class</span> <span class="nc">Regularization</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class for Regularization objects</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This class is not intended for direct use but as apparent for true</span>
<span class="sd">        regularization implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gamma: float</span>
<span class="sd">            Regularization parameter.</span>
<span class="sd">            We recover unregularized OT when gamma -&gt; 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

<div class="viewcode-block" id="Regularization.delta_Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.Regularization.delta_Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">delta_Omega</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute :math:`\delta_\Omega(\mathbf{X}_{:, j})` for each :math:`\mathbf{X}_{:, j}`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \delta_\Omega(\mathbf{x}) = \sup_{\mathbf{y} &gt;= 0} \</span>
<span class="sd">            \mathbf{y}^T \mathbf{x} - \Omega(\mathbf{y})</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array, shape = (len(a), len(b))</span>
<span class="sd">            Input array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        v: array, (len(b), )</span>
<span class="sd">            Values: :math:`\mathbf{v}_j = \delta_\Omega(\mathbf{X}_{:, j})`</span>
<span class="sd">        G: array, (len(a), len(b))</span>
<span class="sd">            Gradients: :math:`\mathbf{G}_{:, j} = \nabla \delta_\Omega(\mathbf{X}_{:, j})`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Regularization.max_Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.Regularization.max_Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">max_Omega</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute :math:`\mathrm{max}_{\Omega, j}(\mathbf{X}_{:, j})` for each :math:`\mathbf{X}_{:, j}`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{max}_{\Omega, j}(\mathbf{x}) =</span>
<span class="sd">            \sup_{\substack{\mathbf{y} &gt;= 0 \ \sum_i \mathbf{y}_i = 1}}</span>
<span class="sd">            \mathbf{y}^T \mathbf{x} - \frac{1}{\mathbf{b}_j} \Omega(\mathbf{b}_j \mathbf{y})</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array, shape = (len(a), len(b))</span>
<span class="sd">            Input array.</span>
<span class="sd">        b: array, shape = (len(b), )</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        v: array, (len(b), )</span>
<span class="sd">            Values: :math:`\mathbf{v}_j = \mathrm{max}_{\Omega, j}(\mathbf{X}_{:, j})`</span>
<span class="sd">        G: array, (len(a), len(b))</span>
<span class="sd">            Gradients: :math:`\mathbf{G}_{:, j} = \nabla \mathrm{max}_{\Omega, j}(\mathbf{X}_{:, j})`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Regularization.Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.Regularization.Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">Omega</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute regularization term.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        T: array, shape = len(a) x len(b)</span>
<span class="sd">            Input array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value: float</span>
<span class="sd">            Regularization term.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</div>



<div class="viewcode-block" id="NegEntropy">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.NegEntropy">[docs]</a>
<span class="k">class</span> <span class="nc">NegEntropy</span><span class="p">(</span><span class="n">Regularization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; NegEntropy regularization &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NegEntropy.delta_Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.NegEntropy.delta_Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">delta_Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="NegEntropy.max_Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.NegEntropy.max_Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">max_Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">max_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
        <span class="n">exp_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">-</span> <span class="n">max_X</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp_X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="n">max_X</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">exp_X</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp_X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="NegEntropy.Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.NegEntropy.Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="SquaredL2">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.SquaredL2">[docs]</a>
<span class="k">class</span> <span class="nc">SquaredL2</span><span class="p">(</span><span class="n">Regularization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Squared L2 regularization &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SquaredL2.delta_Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.SquaredL2.delta_Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">delta_Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">max_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">max_X</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">max_X</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="SquaredL2.max_Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.SquaredL2.max_Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">max_Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">projection_simplex</span><span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">G</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">G</span> <span class="o">*</span> <span class="n">G</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="SquaredL2.Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.SquaredL2.Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SparsityConstrained">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.SparsityConstrained">[docs]</a>
<span class="k">class</span> <span class="nc">SparsityConstrained</span><span class="p">(</span><span class="n">Regularization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Squared L2 regularization with sparsity constraints &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_nz</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_nz</span> <span class="o">=</span> <span class="n">max_nz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

<div class="viewcode-block" id="SparsityConstrained.delta_Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.SparsityConstrained.delta_Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">delta_Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="c1"># For each column of X, find entries that are not among the top max_nz.</span>
        <span class="n">non_top_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span>
            <span class="o">-</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nz</span><span class="p">:]</span>
        <span class="c1"># Set these entries to -inf.</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span><span class="p">[</span><span class="n">non_top_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span><span class="p">[</span><span class="n">non_top_indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">max_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">max_X</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">max_X</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="SparsityConstrained.max_Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.SparsityConstrained.max_Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">max_Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="c1"># Project the scaled X onto the simplex with sparsity constraint.</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">projection_sparse_simplex</span><span class="p">(</span>
            <span class="n">X</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">G</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">G</span> <span class="o">*</span> <span class="n">G</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="SparsityConstrained.Omega">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.SparsityConstrained.Omega">[docs]</a>
    <span class="k">def</span> <span class="nf">Omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="dual_obj_grad">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.dual_obj_grad">[docs]</a>
<span class="k">def</span> <span class="nf">dual_obj_grad</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">regul</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute objective value and gradients of dual objective.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha: array, shape = len(a)</span>
<span class="sd">    beta: array, shape = len(b)</span>
<span class="sd">        Current iterate of dual potentials.</span>
<span class="sd">    a: array, shape = len(a)</span>
<span class="sd">    b: array, shape = len(b)</span>
<span class="sd">        Input histograms (should be non-negative and sum to 1).</span>
<span class="sd">    C: array, shape = (len(a), len(b))</span>
<span class="sd">        Ground cost matrix.</span>
<span class="sd">    regul: Regularization object</span>
<span class="sd">        Should implement a `delta_Omega(X)` method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj: float</span>
<span class="sd">        Objective value (higher is better).</span>
<span class="sd">    grad_alpha: array, shape = len(a)</span>
<span class="sd">        Gradient w.r.t. `alpha`.</span>
<span class="sd">    grad_beta: array, shape = len(b)</span>
<span class="sd">        Gradient w.r.t. `beta`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">grad_alpha</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">grad_beta</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># X[:, j] = alpha + beta[j] - C[:, j]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">C</span>

    <span class="c1"># val.shape = len(b)</span>
    <span class="c1"># G.shape = len(a) x len(b)</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="n">regul</span><span class="o">.</span><span class="n">delta_Omega</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">obj</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">grad_alpha</span> <span class="o">-=</span> <span class="n">G</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">grad_beta</span> <span class="o">-=</span> <span class="n">G</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">grad_alpha</span><span class="p">,</span> <span class="n">grad_beta</span></div>



<div class="viewcode-block" id="solve_dual">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.solve_dual">[docs]</a>
<span class="k">def</span> <span class="nf">solve_dual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">regul</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the &quot;smoothed&quot; dual objective.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a: array, shape = (len(a), )</span>
<span class="sd">    b: array, shape = (len(b), )</span>
<span class="sd">        Input histograms (should be non-negative and sum to 1).</span>
<span class="sd">    C: array, shape = (len(a), len(b))</span>
<span class="sd">        Ground cost matrix.</span>
<span class="sd">    regul: Regularization object</span>
<span class="sd">        Should implement a `delta_Omega(X)` method.</span>
<span class="sd">    method: str</span>
<span class="sd">        Solver to be used (passed to `scipy.optimize.minimize`).</span>
<span class="sd">    tol: float</span>
<span class="sd">        Tolerance parameter.</span>
<span class="sd">    max_iter: int</span>
<span class="sd">        Maximum number of iterations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha: array, shape = (len(a), )</span>
<span class="sd">    beta: array, shape = (len(b), )</span>
<span class="sd">        Dual potentials.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
        <span class="c1"># Unpack alpha and beta.</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):]</span>

        <span class="n">obj</span><span class="p">,</span> <span class="n">grad_alpha</span><span class="p">,</span> <span class="n">grad_beta</span> <span class="o">=</span> <span class="n">dual_obj_grad</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">regul</span><span class="p">)</span>

        <span class="c1"># Pack grad_alpha and grad_beta.</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">grad_alpha</span><span class="p">,</span> <span class="n">grad_beta</span><span class="p">))</span>

        <span class="c1"># We need to maximize the dual.</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">obj</span><span class="p">,</span> <span class="o">-</span><span class="n">grad</span>

    <span class="c1"># Unfortunately, `minimize` only supports functions whose argument is a</span>
    <span class="c1"># vector. So, we need to concatenate alpha and beta.</span>
    <span class="n">alpha_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">beta_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="n">params_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">alpha_init</span><span class="p">,</span> <span class="n">beta_init</span><span class="p">))</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="n">params_init</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">verbose</span><span class="p">))</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):]</span>

    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">res</span></div>



<div class="viewcode-block" id="semi_dual_obj_grad">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.semi_dual_obj_grad">[docs]</a>
<span class="k">def</span> <span class="nf">semi_dual_obj_grad</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">regul</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute objective value and gradient of semi-dual objective.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha: array, shape = len(a)</span>
<span class="sd">        Current iterate of semi-dual potentials.</span>
<span class="sd">    a: array, shape = len(a)</span>
<span class="sd">    b: array, shape = len(b)</span>
<span class="sd">        Input histograms (should be non-negative and sum to 1).</span>
<span class="sd">    C: array, shape = (len(a), len(b))</span>
<span class="sd">        Ground cost matrix.</span>
<span class="sd">    regul: Regularization object</span>
<span class="sd">        Should implement a `max_Omega(X)` method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj: float</span>
<span class="sd">        Objective value (higher is better).</span>
<span class="sd">    grad: array, shape = len(a)</span>
<span class="sd">        Gradient w.r.t. alpha.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># X[:, j] = alpha - C[:, j]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span>

    <span class="c1"># val.shape = len(b)</span>
    <span class="c1"># G.shape = len(a) x len(b)</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="n">regul</span><span class="o">.</span><span class="n">max_Omega</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">obj</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">grad</span></div>



<div class="viewcode-block" id="solve_semi_dual">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.solve_semi_dual">[docs]</a>
<span class="k">def</span> <span class="nf">solve_semi_dual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">regul</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the &quot;smoothed&quot; semi-dual objective.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a: array, shape = (len(a), )</span>
<span class="sd">    b: array, shape = (len(b), )</span>
<span class="sd">        Input histograms (should be non-negative and sum to 1).</span>
<span class="sd">    C: array, shape = (len(a), len(b))</span>
<span class="sd">        Ground cost matrix.</span>
<span class="sd">    regul: Regularization object</span>
<span class="sd">        Should implement a `max_Omega(X)` method.</span>
<span class="sd">    method: str</span>
<span class="sd">        Solver to be used (passed to `scipy.optimize.minimize`).</span>
<span class="sd">    tol: float</span>
<span class="sd">        Tolerance parameter.</span>
<span class="sd">    max_iter: int</span>
<span class="sd">        Maximum number of iterations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alpha: array, shape = (len(a), )</span>
<span class="sd">        Semi-dual potentials.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
        <span class="n">obj</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">semi_dual_obj_grad</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">regul</span><span class="p">)</span>
        <span class="c1"># We need to maximize the semi-dual.</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">obj</span><span class="p">,</span> <span class="o">-</span><span class="n">grad</span>

    <span class="n">alpha_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="n">alpha_init</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">verbose</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">res</span></div>



<div class="viewcode-block" id="get_plan_from_dual">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.get_plan_from_dual">[docs]</a>
<span class="k">def</span> <span class="nf">get_plan_from_dual</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">regul</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve optimal transportation plan from optimal dual potentials.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha: array, shape = len(a)</span>
<span class="sd">    beta: array, shape = len(b)</span>
<span class="sd">        Optimal dual potentials.</span>
<span class="sd">    C: array, shape = (len(a), len(b))</span>
<span class="sd">        Ground cost matrix.</span>
<span class="sd">    regul: Regularization object</span>
<span class="sd">        Should implement a `delta_Omega(X)` method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T: array, shape = (len(a), len(b))</span>
<span class="sd">        Optimal transportation plan.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">C</span>
    <span class="k">return</span> <span class="n">regul</span><span class="o">.</span><span class="n">delta_Omega</span><span class="p">(</span><span class="n">X</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="get_plan_from_semi_dual">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.get_plan_from_semi_dual">[docs]</a>
<span class="k">def</span> <span class="nf">get_plan_from_semi_dual</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">regul</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve optimal transportation plan from optimal semi-dual potentials.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha: array, shape = len(a)</span>
<span class="sd">        Optimal semi-dual potentials.</span>
<span class="sd">    b: array, shape = len(b)</span>
<span class="sd">        Second input histogram (should be non-negative and sum to 1).</span>
<span class="sd">    C: array, shape = (len(a), len(b))</span>
<span class="sd">        Ground cost matrix.</span>
<span class="sd">    regul: Regularization object</span>
<span class="sd">        Should implement a `delta_Omega(X)` method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T: array, shape = (len(a), len(b))</span>
<span class="sd">        Optimal transportation plan.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span>
    <span class="k">return</span> <span class="n">regul</span><span class="o">.</span><span class="n">max_Omega</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span></div>



<div class="viewcode-block" id="smooth_ot_dual">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.smooth_ot_dual">[docs]</a>
<span class="k">def</span> <span class="nf">smooth_ot_dual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span>
                   <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="n">stopThr</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
                   <span class="n">numItermax</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_nz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the regularized OT problem in the dual and return the OT matrix</span>

<span class="sd">    The function solves the smooth relaxed dual formulation (7) in</span>
<span class="sd">    :ref:`[17] &lt;references-smooth-ot-dual&gt;`:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \max_{\alpha,\beta}\quad \mathbf{a}^T\alpha + \mathbf{b}^T\beta -</span>
<span class="sd">        \sum_j \delta_\Omega \left(\alpha+\beta_j-\mathbf{m}_j \right)</span>

<span class="sd">    where :</span>

<span class="sd">    - :math:`\mathbf{m}_j` is the j-th column of the cost matrix</span>
<span class="sd">    - :math:`\delta_\Omega` is the convex conjugate of the regularization term :math:`\Omega`</span>
<span class="sd">    - :math:`\mathbf{a}` and :math:`\mathbf{b}` are source and target weights (sum to 1)</span>

<span class="sd">    The OT matrix can is reconstructed from the gradient of :math:`\delta_\Omega`</span>
<span class="sd">    (See :ref:`[17] &lt;references-smooth-ot-dual&gt;` Proposition 1).</span>
<span class="sd">    The optimization algorithm is using gradient decent (L-BFGS by default).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : np.ndarray (ns,)</span>
<span class="sd">        samples weights in the source domain</span>
<span class="sd">    b : np.ndarray (nt,) or np.ndarray (nt,nbb)</span>
<span class="sd">        samples in the target domain, compute sinkhorn with multiple targets</span>
<span class="sd">        and fixed :math:`\mathbf{M}` if :math:`\mathbf{b}` is a matrix</span>
<span class="sd">        (return OT loss + dual variables in log)</span>
<span class="sd">    M : np.ndarray (ns,nt)</span>
<span class="sd">        loss matrix</span>
<span class="sd">    reg : float</span>
<span class="sd">        Regularization term &gt;0</span>
<span class="sd">    reg_type : str</span>
<span class="sd">        Regularization type, can be the following (default =&#39;l2&#39;):</span>

<span class="sd">            - &#39;kl&#39; : Kullback Leibler (~ Neg-entropy used in sinkhorn</span>
<span class="sd">              :ref:`[2] &lt;references-smooth-ot-dual&gt;`)</span>

<span class="sd">            - &#39;l2&#39; : Squared Euclidean regularization</span>
<span class="sd">            - &#39;sparsity_constrained&#39; : Sparsity-constrained regularization [50]</span>
<span class="sd">    max_nz : int or None, optional. Used only in the case of reg_type = &#39;sparsity_constrained&#39; to specify the maximum number of nonzeros per column of the optimal plan;</span>
<span class="sd">        not used for other regularization types.</span>
<span class="sd">    method : str</span>
<span class="sd">        Solver to use for scipy.optimize.minimize</span>
<span class="sd">    numItermax : int, optional</span>
<span class="sd">        Max number of iterations</span>
<span class="sd">    stopThr : float, optional</span>
<span class="sd">        Stop threshold on error (&gt;0)</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Print information along iterations</span>
<span class="sd">    log : bool, optional</span>
<span class="sd">        record log if True</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gamma : (ns, nt) ndarray</span>
<span class="sd">        Optimal transportation matrix for the given parameters</span>
<span class="sd">    log : dict</span>
<span class="sd">        log dictionary return only if log==True in parameters</span>


<span class="sd">    .. _references-smooth-ot-dual:</span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [2] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013</span>

<span class="sd">    .. [17] Blondel, M., Seguy, V., &amp; Rolet, A. (2018). Smooth and Sparse Optimal Transport. Proceedings of the Twenty-First International Conference on Artificial Intelligence and Statistics (AISTATS).</span>

<span class="sd">    .. [50] Liu, T., Puigcerver, J., &amp; Blondel, M. (2023). Sparsity-constrained optimal transport. Proceedings of the Eleventh International Conference on Learning Representations (ICLR).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ot.lp.emd : Unregularized OT</span>
<span class="sd">    ot.sinhorn : Entropic regularized OT</span>
<span class="sd">    ot.optim.cg : General regularized OT</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nx</span> <span class="o">=</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reg_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="s1">&#39;squaredl2&#39;</span><span class="p">]:</span>
        <span class="n">regul</span> <span class="o">=</span> <span class="n">SquaredL2</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">reg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reg_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;entropic&#39;</span><span class="p">,</span> <span class="s1">&#39;negentropy&#39;</span><span class="p">,</span> <span class="s1">&#39;kl&#39;</span><span class="p">]:</span>
        <span class="n">regul</span> <span class="o">=</span> <span class="n">NegEntropy</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">reg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reg_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sparsity_constrained&#39;</span><span class="p">,</span> <span class="s1">&#39;sparsity-constrained&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_nz</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;max_nz </span><span class="si">{</span><span class="n">max_nz</span><span class="si">}</span><span class="s1"> must be an integer&#39;</span><span class="p">)</span>
        <span class="n">regul</span> <span class="o">=</span> <span class="n">SparsityConstrained</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">reg</span><span class="p">,</span> <span class="n">max_nz</span><span class="o">=</span><span class="n">max_nz</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Unknown regularization&#39;</span><span class="p">)</span>

    <span class="n">a0</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="n">M0</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span>
    <span class="c1"># convert to humpy</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="c1"># solve dual</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">solve_dual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">regul</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">numItermax</span><span class="p">,</span>
                                  <span class="n">tol</span><span class="o">=</span><span class="n">stopThr</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># reconstruct transport matrix</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">get_plan_from_dual</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">regul</span><span class="p">),</span> <span class="n">type_as</span><span class="o">=</span><span class="n">M0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">log</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">a0</span><span class="p">),</span> <span class="s1">&#39;beta&#39;</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">type_as</span><span class="o">=</span><span class="n">b0</span><span class="p">),</span> <span class="s1">&#39;res&#39;</span><span class="p">:</span> <span class="n">res</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">log</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="smooth_ot_semi_dual">
<a class="viewcode-back" href="../../gen_modules/ot.smooth.html#ot.smooth.smooth_ot_semi_dual">[docs]</a>
<span class="k">def</span> <span class="nf">smooth_ot_semi_dual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">max_nz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="n">stopThr</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span>
                        <span class="n">numItermax</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the regularized OT problem in the semi-dual and return the OT matrix</span>

<span class="sd">    The function solves the smooth relaxed dual formulation (10) in</span>
<span class="sd">    :ref:`[17] &lt;references-smooth-ot-semi-dual&gt;`:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \max_{\alpha}\quad \mathbf{a}^T\alpha- \mathrm{OT}_\Omega^*(\alpha, \mathbf{b})</span>

<span class="sd">    where :</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{OT}_\Omega^*(\alpha,b)=\sum_j \mathbf{b}_j</span>

<span class="sd">    - :math:`\mathbf{m}_j` is the j-th column of the cost matrix</span>
<span class="sd">    - :math:`\mathrm{OT}_\Omega^*(\alpha,b)` is defined in Eq. (9) in</span>
<span class="sd">      :ref:`[17] &lt;references-smooth-ot-semi-dual&gt;`</span>
<span class="sd">    - :math:`\mathbf{a}` and :math:`\mathbf{b}` are source and target weights (sum to 1)</span>

<span class="sd">    The OT matrix can is reconstructed using :ref:`[17] &lt;references-smooth-ot-semi-dual&gt;` Proposition 2.</span>
<span class="sd">    The optimization algorithm is using gradient decent (L-BFGS by default).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : np.ndarray (ns,)</span>
<span class="sd">        samples weights in the source domain</span>
<span class="sd">    b : np.ndarray (nt,) or np.ndarray (nt,nbb)</span>
<span class="sd">        samples in the target domain, compute sinkhorn with multiple targets</span>
<span class="sd">        and fixed:math:`\mathbf{M}` if :math:`\mathbf{b}` is a matrix</span>
<span class="sd">        (return OT loss + dual variables in log)</span>
<span class="sd">    M : np.ndarray (ns,nt)</span>
<span class="sd">        loss matrix</span>
<span class="sd">    reg : float</span>
<span class="sd">        Regularization term &gt;0</span>
<span class="sd">    reg_type : str</span>
<span class="sd">        Regularization type, can be the following (default =&#39;l2&#39;):</span>

<span class="sd">            - &#39;kl&#39; : Kullback Leibler (~ Neg-entropy used in sinkhorn</span>
<span class="sd">              :ref:`[2] &lt;references-smooth-ot-semi-dual&gt;`)</span>

<span class="sd">            - &#39;l2&#39; : Squared Euclidean regularization</span>
<span class="sd">            - &#39;sparsity_constrained&#39; : Sparsity-constrained regularization [50]</span>
<span class="sd">    max_nz : int or None, optional. Used only in the case of reg_type = &#39;sparsity_constrained&#39; to specify the maximum number of nonzeros per column of the optimal plan;</span>
<span class="sd">        not used for other regularization types.</span>
<span class="sd">    method : str</span>
<span class="sd">        Solver to use for scipy.optimize.minimize</span>
<span class="sd">    numItermax : int, optional</span>
<span class="sd">        Max number of iterations</span>
<span class="sd">    stopThr : float, optional</span>
<span class="sd">        Stop threshold on error (&gt;0)</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Print information along iterations</span>
<span class="sd">    log : bool, optional</span>
<span class="sd">        record log if True</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gamma : (ns, nt) ndarray</span>
<span class="sd">        Optimal transportation matrix for the given parameters</span>
<span class="sd">    log : dict</span>
<span class="sd">        log dictionary return only if log==True in parameters</span>


<span class="sd">    .. _references-smooth-ot-semi-dual:</span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [2] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013</span>

<span class="sd">    .. [17] Blondel, M., Seguy, V., &amp; Rolet, A. (2018). Smooth and Sparse Optimal Transport. Proceedings of the Twenty-First International Conference on Artificial Intelligence and Statistics (AISTATS).</span>

<span class="sd">    .. [50] Liu, T., Puigcerver, J., &amp; Blondel, M. (2023). Sparsity-constrained optimal transport. Proceedings of the Eleventh International Conference on Learning Representations (ICLR).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ot.lp.emd : Unregularized OT</span>
<span class="sd">    ot.sinhorn : Entropic regularized OT</span>
<span class="sd">    ot.optim.cg : General regularized OT</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reg_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="s1">&#39;squaredl2&#39;</span><span class="p">]:</span>
        <span class="n">regul</span> <span class="o">=</span> <span class="n">SquaredL2</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">reg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reg_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;entropic&#39;</span><span class="p">,</span> <span class="s1">&#39;negentropy&#39;</span><span class="p">,</span> <span class="s1">&#39;kl&#39;</span><span class="p">]:</span>
        <span class="n">regul</span> <span class="o">=</span> <span class="n">NegEntropy</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">reg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reg_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sparsity_constrained&#39;</span><span class="p">,</span> <span class="s1">&#39;sparsity-constrained&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_nz</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;max_nz </span><span class="si">{</span><span class="n">max_nz</span><span class="si">}</span><span class="s1"> must be an integer&#39;</span><span class="p">)</span>
        <span class="n">regul</span> <span class="o">=</span> <span class="n">SparsityConstrained</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">reg</span><span class="p">,</span> <span class="n">max_nz</span><span class="o">=</span><span class="n">max_nz</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Unknown regularization&#39;</span><span class="p">)</span>

    <span class="c1"># solve dual</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">solve_semi_dual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">regul</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">numItermax</span><span class="p">,</span>
                                 <span class="n">tol</span><span class="o">=</span><span class="n">stopThr</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># reconstruct transport matrix</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">get_plan_from_semi_dual</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">regul</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">log</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;res&#39;</span><span class="p">:</span> <span class="n">res</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">log</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2023, POT Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note"
aria-label="versions">
  <!--  add shift_up to the class for force viewing ,
  data-toggle="rst-current-version" -->
    <span class="rst-current-version"  style="margin-bottom:1mm;">
      <span class="fa fa-book"> Python Optimal Transport</span>
      <hr  style="margin-bottom:1.5mm;margin-top:5mm;">
     <!--  versions
      <span class="fa fa-caret-down"></span>-->
      <span class="rst-current-version" style="display: inline-block;padding:
      0px;color:#fcfcfcab;float:left;font-size: 100%;">
        Versions: 
        <a href="https://pythonot.github.io/" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Release</a>
        <a href="https://pythonot.github.io/master" 
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Development</a>
        <a href="https://github.com/PythonOT/POT"
        style="padding: 3px;color:#fcfcfc;font-size: 100%;">Code</a>

      </span>

     
    </span>
  
     <!--
    <div class="rst-other-versions">

      

<div class="injected">

    
  <dl>
    <dt>Versions</dt>

    <dd><a href="https://pythonot.github.io/">Release</a></dd>
    
    <dd><a href="https://pythonot.github.io/master">Development</a></dd>
   
    

    <dt><a href="https://github.com/PythonOT/POT">Code on Github</a></dt>       

    
  </dl>
  <hr>

</div> 
</div>-->
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>